{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#polygon-id-an-introduction","title":"Polygon ID: An Introduction","text":"<p>Polygon ID\u2019s identity infrastructure facilitates trusted and secure relationships between apps and users, following the principles of self-sovereign identity and privacy by default. Polygon ID enables organizations on one side to issue verifiable credentials about users, and organizations on the other side to verify those claims via a suite of tools created for each member of the SSI ecosystem.</p>"},{"location":"#why-polygon-id","title":"Why Polygon ID?","text":"<p>Polygon ID, with the help of zero-knowledge proofs, lets users prove their identity without the need of exposing their private information. This ensures both the Freedom of Expression and Privacy by Default (User's identities are secured by zero-knowledge cryptography).</p>"},{"location":"#core-concepts-of-polygon-id-verifiable-credentials-identity-holder-issuer-and-verifier-triangle-of-trust","title":"Core Concepts of Polygon ID: Verifiable Credentials, Identity Holder, Issuer and Verifier (Triangle of Trust)","text":"<p>Every identity is identified by a unique identifier called DID (Decentralized Identifier). Every identity-based information is represented via a Verifiable Credentials (VCs).  In the simplest terms, a VC represents any type of information related to an individual/enterprise/object. The VC could be as simple as the age of the entity or the highest degree held by it. It could be a membership certificate issued by a DAO, for instance.</p> <p>The toolset made available by Polygon ID is fully compliant with the W3C standards. We have a definition spec. for the Polygon ID DID method.</p> <p>The architecture of the framework is composed of three modules: Identity Holder, Issuer, and Verifier. These three, together, form what we call the Triangle of Trust. Let us see what role each entity plays in Polygon ID. </p> <ol> <li> <p>Identity Holder: An entity that holds claims in its Wallet. A VC, as mentioned above, is issued by an Issuer to the Holder. The Identity Holder generates zero-knowledge proofs of the VCs issued and presents these proofs to the Verifier, which verifies that the proof is authentic and matches specific criteria. </p> </li> <li> <p>Issuer: An entity (person, organization, or thing) that issues VCs to the Holders. VCs are cryptographically signed by the Issuer. Every VC comes from an Issuer. </p> </li> <li> <p>Verifier: A Verifier verifies the proof presented by a Holder. It requests the Holder to send a proof based on the VCs they hold in their wallet. While verifying a proof, the Verifier performs a set of checks, for example that the VC was signed by the expected Issuer and that the VC matches the criteria requested by the Verifier. The simplest example of a Verifier is a Bar that wants to verify if you are over 18. In the real world, the Identity Holder would need to provide an ID and show all their personal information. With Polygon ID, they only need to pass a proof.</p> </li> </ol> <p>A core concept here is the trust that must exist between a Verifier and an Issuer: the fact that the information contained inside a VC is cryptographically verifiable doesn't guarantee its truth. The Issuer must be a trusted and reputable party so that Verifier can consume the VCs originated by that Issuer.</p> <p>The verification of a VC can happen either off-chain or on-chain!</p> <p></p>"},{"location":"#role-of-a-wallet","title":"Role of a Wallet","text":"<p>A Wallet plays a crucial role in the seamless exchange of VCs with the Issuer, on one hand, and proofs with the Verifier, on the other. As stated above, an Identity Holder carries his/her personal data, in the form of VC, within their wallet. At its core, the wallet stores the private key of a user, fetch VCs from the Issuer, and create zero-knowledge proofs to be presented to the Verifier. Being the carrier of the sensitive information, Wallet has been designed to ensure that the identity of its Holder is protected and preserved, and no sensitive data can be revealed to the third party without the consent of the Holder.  </p>"},{"location":"#what-can-you-achieve-using-polygon-id","title":"What Can you Achieve Using Polygon ID?","text":"<ol> <li> <p>Privacy using Zero-Knowledge Proofs: An Identity Holder, using zero-knowledge proofs, can keep his/her/its personal data private. During the process of VC verification, it just needs to show a proof that he is the owner of a VC that matches certain criteria without letting the Verifier know of the actual VC. For example, an Identity Holder can prove to a Verifier authority that s/he is above 18 years of age by presenting the proof that s/he is above 18 without revealing his/her actual age. This ensures minimum data exposure and hence ensures the safety of any sensitive data.  Another aspect of privacy comes from the fact that the Issuer would not be able to track the usage of VCs by an individual once it has been issued. </p> </li> <li> <p>Off-Chain and On-Chain Verification: Verification of proofs can be done either off-chain or on-chain via Smart Contracts. For example, developers can set up a contract that airdrops tokens only to users that meet certain criteria based on their VCs.</p> </li> <li> <p>Self-Sovereignty: Polygon ID renders self-sovereignty in the hands of the user. The user is the only custodian of his/her private keys; user-controlled data can be shared with third parties without taking any permission from the Issuer that has issued the VCs to the user.</p> </li> <li> <p>Transitive Trust: A transitive trust between the actors of the triangle means that the trust between two entities in one domain or context can be easily extended to other domains or contexts. For instance, the information generated by an Issuer can be conveniently used by more than one Verifier without asking for permission. Along similar lines, an Identity Holder can build up his/her trust by collecting multiple credentials from different Issuers in one digital wallet. </p> </li> </ol>"},{"location":"#polygon-id-and-iden3","title":"Polygon ID and Iden3","text":"<p>Iden3 is the open-source protocol at the basis of Polygon ID. The protocol defines on a low-level how the parties listed above communicate and interact with each other. Polygon ID is an abstraction layer to enable developers to build applications leveraging the Iden3 protocol.</p>"},{"location":"#further-resources-on-polygon-id","title":"Further Resources On Polygon ID","text":"<ul> <li>Polygon University - Courses on Polygon ID (free)</li> <li>Identity Layer for Web3 - Paris - July 2022</li> <li>The Future of Identity is Self-Sovereign: Build a dapp with Polygon ID - ETH Global - November 2022</li> <li>A Deep Dive into Polygon ID - ETH Vietnam - November 2022</li> <li>Frequently Asked Questions on Polygon ID (FAQ)</li> </ul>"},{"location":"#further-resources-on-verifiable-credentials","title":"Further Resources On Verifiable Credentials","text":"<ul> <li>Verifiable Credentials: The Ultimate Guide</li> <li>Understanding and Using Verifiable Credentials</li> <li>Polygon ID DID Method Specification</li> </ul>"},{"location":"#_1","title":"<p>Polygon ID on GitHub</p>","text":""},{"location":"quick-start-demo/","title":"Quick Start Demo","text":"<p>This tutorial is a quick demonstration of some of Polygon ID's main functionalities. To illustrate how Polygon ID works, we will walk you through some of its products and tools by following along a simple POAP use case. POAP stands for Proof of Attendance Protocol, which is used to prove that someone has taken part in a given event.</p> <p>This guide will briefly touch on the 3 roles of the Triangle of Trust, namely the Identity Holder, the Issuer and the Verifier. For that, we will take the case of an individual who needs to prove that they were able to participate in a particular event.</p> <p>These are the steps we will cover in this article:</p> <ol> <li>Set up a Polygon ID wallet</li> <li>Issue a new credential to attest to the ID Holder's attendance to the event</li> <li>Fetch the newly created credential</li> <li>Verify the credential validity</li> </ol>"},{"location":"quick-start-demo/#set-up-a-polygon-id-wallet","title":"Set up a Polygon ID wallet","text":"<p>As an Identity Holder, the individual who wants to have a credential to prove his age, for example, will need an application that can hold their credentials. In our case, we will be using the Polygon ID Wallet. </p> <p>Note</p> <p>You can also use any Polygon ID compatible wallet. Please, check our Ecosystem page for other options.</p> <p>To get started with the Polygon ID Wallet, download the Polygon ID Wallet App and create an Identity:</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul> <p>Note</p> <p>Polygon ID wallet is an implementation of the Wallet SDK, as a way of showcasing its possibilities. Head to the Polygon ID SDK documentation to know more about how it works. </p> <p>The process from downloading to creating an identity on the Polygon ID Wallet is just as it is shown below. You need to download the app, create a wallet, set up a PIN number and the wallet is ready to be used. </p> <p></p> <p>Warning</p> <p>This demo is using Polygon's Mumbai testnet. Go to the gear icon at the top right and ensure \"Polygon Mumbai\" is selected instead of \"Polygon Main\". </p>"},{"location":"quick-start-demo/#issue-a-new-credential-to-attest-to-the-id-holders-event-attendance","title":"Issue a new credential to attest to the ID Holder's event attendance","text":"<p>A trusted entity, for instance, a private institution will now play the role of an issuer. It will be responsible for creating the credential and sending it to the ID Holder.</p> <p>We are using a testing environment to manage credentials: https://issuer-ui.polygonid.me. This is the place where the trusted entity can create credentials, manage schemas and generate connections. </p> <p>However, if you are using a new credential type, you actually need to create a schema for that credential, which basically is the set of JSON files that gather all the attributes of that specific credential. </p> <p>To facilitate this issuance process, we have already created the credential schema whose URLs are the following:</p> <ul> <li>JSON schema URL     <code>ipfs://QmTSwnuCB9grYMB2z5EKXDagfChurK5MiMCS6efrRbsyVX</code></li> <li>JSON-LD Context     <code>ipfs://QmdH1Vu79p2NcZLFbHxzJnLuUHJiMZnBeT7SNpLaqK7k9X</code></li> </ul> <p>Note</p> <p>To learn how to set up your own issuer environment by deploying an issuer node, visit the Issuer section in the documentation.</p> <p>Info</p> <p>Learn more about creating new schemas on the Schema Builder UI guide </p>"},{"location":"quick-start-demo/#issue-the-credential","title":"Issue the credential","text":"<p>With the new schema in hand, the issuer should now be able to generate a credential.</p> <ol> <li> <p>First, go to the Issuer Node UI testing environment.</p> <p>Provide the following login data:</p> <ul> <li>user: <code>user-ui</code></li> <li>password: <code>password-ui</code></li> </ul> <p>Warning</p> <p>This Issuer Node is publicly available and used only for testing purposes. Do not use personal or sensitive data. All data is deleted every 48 hours.</p> </li> <li> <p>Now you need to import the schema. Click on Import Schema and paste our previously generated schema IPFS address <code>ipfs://QmTSwnuCB9grYMB2z5EKXDagfChurK5MiMCS6efrRbsyVX</code>:</p> <p></p> <p>You may preview the schema and then Import it.</p> </li> <li> <p>You can go ahead and click on Issue Credential in the top righ-hand corner. Choose Credential Link on the next page and your schema on the dropdown menu (\"POAP01\", in our case). For this credential, we are providing a proof of attendance to an event in Paris:</p> <p></p> </li> <li> <p>After you click on Create Credential Link, you can also click on View Link on the next screen to check the generated QR code.</p> <p></p> </li> </ol>"},{"location":"quick-start-demo/#fetch-the-newly-created-credential","title":"Fetch the newly created credential","text":"<p>Now we are back to the ID Holder role. They will use their mobile application to authenticate themselves by scanning the QR code generated by the issuer in the last step.</p> <p>Connect to the issuer:</p> <p>This will instantly trigger a notification on the mobile which will look like this:</p> <p>Accept the credential:</p> <p>The ID Holder successfully retrieved the credential and it is visible on the app: </p>"},{"location":"quick-start-demo/#verify-the-id-holder-credential","title":"Verify the ID holder credential","text":"<p>Here comes the third role in this tutorial: the verifier. This could be represented by an organization that needs to check the accuracy of someone's credentials. In our use case, this organization wants to verify whether the ID holder actually attended our made-up Paris event.</p> <p>Here are the steps to verify the credential:</p> <ol> <li> <p>Visit the Verifier website. As we are using a newly-created credential type, you need to choose Custom on the dropdown menu. Click on Sign In.</p> <p></p> </li> <li> <p>Now you will again make use of the JSON-LD URL we have also provided: <code>ipfs://QmdH1Vu79p2NcZLFbHxzJnLuUHJiMZnBeT7SNpLaqK7k9X</code>. Here is how the query should look like:</p> <p></p> </li> <li> <p>After clicking on Submit, you should scan the resulting QR code and follow the instructions on the mobile app.</p> <p></p> </li> <li> <p>The process of generating the proof is then started:  </p> <p></p> </li> <li> <p>And finally, the proof will be validated by the Verifier.</p> </li> </ol> <p>Info</p> <pre><code>This was a quick demonstration of Polygon ID's basic functionalities. However, Polygon ID is far more complex than this. It offers a range of SSI-focused tools that allow for decentralized identity and verifiable credentials management.\n</code></pre>"},{"location":"contracts/credential-linkage/","title":"Credential Linkage","text":"<p>There are 2 types of relationships between credentials and their issuers:</p> <ul> <li> <p>Issuer DID anchoring: as an issuer of credentials, issuers can choose to just leave their identifier in the genesis state, but it is recommended that they publish their issuer DID on-chain for visibility and traceability purposes. This is done by calling the \u201cTransit State function\u201d so that the issuer can register their identity state and identifier in the identity <code>StateV2.sol</code> contract. At this point, we can consider that the Issuer DID is anchored.</p> </li> <li> <p>Credential Linkage: after the issuer\u2019s DID is anchored to the blockchain, then the issuer can generate credentials with its identifier and signature (using either the BJJ or MTP, see credential issuance methods for more). At this point, we can consider that the credential has a linkage to the blockchain in which the issuer registered its DID. </p> </li> </ul> <p></p> <p>Note</p> <p>If the credential is issued using the MTP method, then the credential data is also \u201canchored\u201d (via an indirect merkle tree proof) to the blockchain. Otherwise, only the Issuer\u2019s DID is anchored to the blockchain.</p>"},{"location":"contracts/credential-linkage/#credential-linkage-to-different-blockchains","title":"Credential Linkage to Different Blockchains","text":"<p>Credentials could be linked to different Ethereum Virtual Machine (EVM) blockchains, they are not limited to only being linked to the Polygon mainnet when they are issued. For instance, credentials could be linked to a Supernets chain or another EVM chain. The issuer state contract could be deployed to other EVM-compatible chains, and verifiers could validate the proofs from these credentials as long as they have access to the particular chain. </p> <p>Note</p> <p>Credential linkage is only supported for a single chain for each credential (a credential cannot be linked to multiple blockchains at the same time).</p> <p></p>"},{"location":"contracts/overview/","title":"Overview","text":""},{"location":"contracts/overview/#smart-contracts","title":"Smart Contracts","text":"<p>Polygon ID Smart Contracts - Github</p>"},{"location":"contracts/overview/#blockchain-addresses","title":"Blockchain addresses","text":"<p>For situations where one needs to publish data on the blockchain, such as creating a mtp-type credential, generating on-chain proofs and make credential revocations effective, it is important to have the Smart Contracts addresses:</p> <ul> <li>Testnet(mumbai) -&gt; <code>0x134B1BE34911E39A8397ec6289782989729807a4</code></li> <li>Mainnet -&gt; <code>0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D</code></li> </ul>"},{"location":"contracts/overview/#validator-addresses","title":"Validator addresses","text":"<p>Current addresses on Polygon Mumbai testnet.</p> Sig MTP Validators 0xF2D4Eeb4d455fb673104902282Ce68B9ce4Ac450 0x3DcAe4c8d94359D31e4C89D7F2b944859408C618 ERC20 examples 0x9017a99afb69CB7B21C7DD29827b4762DECD53FD 0x3Bf7f4774DC3f92431fA690fa000f636562dCC18 <p>Current addresses on Polygon Main. (ERC20 example with airdrop use case, restricted to 1 request).</p> Sig MTP Verifier 0x6f6E19781600d6B06D64A6b86431FB7dB3E919e0 0x9DB901F3AFdAAA73F5B2123B186F566fA3Ed1551 Validators 0x9ee6a2682Caa2E0AC99dA46afb88Ad7e6A58Cd1b 0x5f24dD9FbEa358B9dD96daA281e82160fdefD3CD ERC20 examples 0x8732e29eE329fD19Ff868a3Df3D5F6A3116027A2 0x5c31BB88AA57C69FF537C5d86102246D61712C90 <p>ERC20 examples with airdrop use case, not restricted.</p> Sig MTP Validators 0x9ee6a2682Caa2E0AC99dA46afb88Ad7e6A58Cd1b 0x5f24dD9FbEa358B9dD96daA281e82160fdefD3CD ERC20 examples 0x7C14Aa764130852A8B64BA7058bf71E4292d677F 0xa3Bc012FCf034bee8d16161730CE4eAb34C35100"},{"location":"contracts/overview/#credentialatomicquerysigvalidator","title":"CredentialAtomicQuerySigValidator","text":"<p>CredentialAtomicQuerySigValidator.sol - Github</p> <p>The CredentialAtomicQuerySigValidator contract is used to verify any credential-related zk proof generated by user using the <code>credentialAtomicQuerySigV2OnChain</code> circuit. The contract only verifies proofs based on credential of type <code>Signature</code></p> <p>The core of the contract is its <code>verify</code> function that takes the proof generated by a user and executes a set of verifications:</p> <ul> <li>Verifies that the proof is valid. This verification is actually performed inside the  <code>verifierSig</code> contract which is automatically generated using circom.</li> <li>Verifies that the input used to generate the proof matches the query associated to that specific Request.</li> <li>Verifies that the user's and the Issuer's identity states are valid based on the State Contract.</li> </ul> <p>The CredentialAtomicQuerySigValidator executes the same set of verifications of the Verification Library. The former is required when performing on-chain verification while the latter is required for off-chain verification.</p> <p>CredentialAtomicQuerySigValidator address:</p> <ul> <li>Mumbai: 0xF2D4Eeb4d455fb673104902282Ce68B9ce4Ac450</li> </ul>"},{"location":"contracts/overview/#credentialatomicquerymtpvalidator","title":"CredentialAtomicQueryMTPValidator","text":"<p>CredentialAtomicQueryMTPValidator.sol - Github</p> <p>Performs the same set of verifications of the CredentialAtomicQuerySigValidator but for credential of type <code>MTP</code></p> <p>CredentialAtomicQueryMTPValidator address:</p> <ul> <li>Mumbai: 0x3DcAe4c8d94359D31e4C89D7F2b944859408C618</li> </ul> <p>Further protocol related contracts can be found at Iden3 - Smart Contracts</p>"},{"location":"issuer/cred-issue-methods/","title":"Credential Issuance Methods","text":""},{"location":"issuer/cred-issue-methods/#verifiable-presentations-leveraging-zk-proofs","title":"Verifiable Presentations leveraging ZK Proofs","text":"<p>The owner of a credential can prove to another party that a credential is true, without revealing any information beyond the validity of the credential itself using zkSNARK cryptography.</p> <p>The Verifier can request any proof of the information contained in the identity credential (using the zkQuery Request Language) and obtain guaranteed correctness without access to the private credential.</p> <p>There are two ways those credentials can be issued: using BJJ key Signature or Merkle Tree Proof.</p>"},{"location":"issuer/cred-issue-methods/#sig-method-issuance-of-credentials-with-baby-jubjubbjj-key-signatures","title":"SIG Method: Issuance of Credentials with Baby JubJub(BJJ) Key Signatures","text":"<p>The credential is not added to the Issuer\u2019s Merkle tree, instead a baby jub jub (BJJ) signature is used which is then verified upon presentation. With this method, issuers can issue a large number of credentials without needing to spend any gas to issue the credentials.</p>"},{"location":"issuer/cred-issue-methods/#mtp-method-issuance-of-credentials-with-merkle-tree-proof","title":"MTP Method: Issuance of Credentials with Merkle Tree Proof","text":"<p>The validation of the proof is done against the state published on-chain. No personal information is stored on-chain. A key difference with this method is that the identity state has to be published on-chain (the hash of the merkle trees), since the Identity State Transition function has to be executed. Another important difference is that through this method smart contracts can issue credentials. The estimated cost of calling this function is approximately 2 million gas on average ( 0.36 MATIC in the Polygon PoS mainnet as of June 2023), also furthermore, credential issuance batching could be done to optimize the gas cost of the issuance process.</p>"},{"location":"issuer/demo-issuer/","title":"Demo Issuer","text":""},{"location":"issuer/demo-issuer/#demo-issuer","title":"Demo Issuer","text":"<p>The Demo Issuer is a playground that allows you to create credentials without having to set up an Issuer Node and fetch it inside your wallet.</p>"},{"location":"issuer/demo-issuer/#prerequisites","title":"Prerequisites","text":"<p>Download the Polygon ID Wallet App and create an Identity.</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul>"},{"location":"issuer/demo-issuer/#quick-start","title":"Quick Start","text":"<p>To create a credential, you require a schema that contains semantics of the JSON vocabulary and is used to describe a large number of data sets. The schema contains links to JSON-LD Context and JSON URL. For this tutorial, we will be using a customized Schema named <code>ProofOfDaoLongevity</code> that attests to someone's <code>entryDate</code> inside a DAO. You can find more info about that schema and how to create a custom Schema.</p> <p>To create a credential, the Polygon ID app must be installed on your mobile. </p> <ol> <li> <p>On the Issuer website, click Sign up.</p> <p></p> <p>It shows the QR code on screen:</p> <p></p> </li> <li> <p>Open the Polygon ID app and authenticate with pin/biometrics</p> <p></p> </li> <li> <p>On the app, click Connect.</p> <p></p> </li> <li> <p>With the app, scan the QR code displayed on the site and click Connect Wallet. </p> <p></p> </li> <li> <p>Authenticate again with your pin/biometrics. This starts the authentication of the user's wallet. </p> <p></p> <p>After the authentication process is complete, the app shows the message if the identity is successfully authenticated or if it failed to authenticate.  </p> <p></p> <p>At this point, the Issuer has received information about your Identifier (DID) and can use it as the subject of the credential that will be issued in the next step.</p> </li> <li> <p>On the website, click Create Claim.</p> <p></p> <p>This shows the Create Claim window:</p> <p></p> </li> <li> <p>Click the Schema dropdown menu and select the type of schema you want to use for creating credentials. </p> <p>Two schemas types are already available in the drop-down menu: KYCAgeCredential and KYCCountryOfResidenceCredential.  If you want to use a custom schema, select custom from the drop-down menu. For this example, we are using the <code>ProofOfDaoLongevity</code> schema created in the Create Custom Schemas tutorial. The menu needs to be populated with the JSON Schema URL and the Type of the schema. Which in this case are: </p> <ul> <li><code>https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.json</code></li> <li><code>ProofOfDaoLongevity</code></li> </ul> <p>The expiration date sets the date on which the credential will expire.  The Data JSON contains the actual data that the credential is attesting to. In this case, the credential contains a single field <code>entryDate</code> that needs to be populated with the date the user joined the DAO.</p> <p>Once filled up, click Submit.</p> <p></p> <p>This creates a new credential. Scan the QR code from the wallet app to fetch the credential in the wallet.</p> <p></p> </li> <li> <p>Once a credential is created, you can view it on the Issuer site. For this, click the icon to open and view the credential. </p> <p></p> </li> </ol> <p>This shows all the information related to a credential; this includes:</p> <ul> <li>@Context (JSON-LD Schema) and CredentialSchema (JSON) URLs</li> <li>credentialStatus: URL to fetch the Revocation status of the credential from the Issuer along with the revocation nonce. </li> <li>credentialSubject: Information related to the Subject of the Credential. In this example, this includes subject's  <code>entryDate</code> and id of the Subject in the <code>did</code> format.</li> <li>Other information such as expiration date of the credential, issuance date, and ID of the Issuer in the <code>did</code> format.</li> <li>Proof which includes information such as state of the issuer identity published on-chain, the non-revocation proof for the authorization claim, and the actual credential signed by the Issuer. </li> </ul>"},{"location":"issuer/issuer-core/","title":"Overview","text":""},{"location":"issuer/issuer-core/#issuer-node-core-api","title":"Issuer Node Core API","text":"<p>The Issuer Node Core API is ideal for users who need multiple identities and for integrator profiles, who want to create solutions based on Polygon ID functionalities and might be interested in having access to low level information such as Merkle Trees. </p> <p> </p> Issuer Node Core API with Identity, Claim and Agent endpoints."},{"location":"issuer/issuer-core/#issuer-node-components","title":"Issuer Node Components","text":"<p>The Issuer Node comprises the following components and each one of these components can be either dockerized or each one of these can be launched as separate service. </p> <ul> <li> <p>Issuer Application to issue Verifiable Credentials and communicate with users' wallets.</p> </li> <li> <p>Vault: Based on HashiCorp, the Vault is used in the Issuer Node for providing key management services. It helps to secure sensitive data, such as the private key of the issuer, thus protecting them in a secure way. The Vault has been provided with a plugin called <code>vault-plugin-secrets-iden3</code>; this plugin is used to sign the data with Baby Jubjub Keys that are stored in the Vault. </p> </li> <li> <p>Redis: Redis is used for caching the schemas that we use in the Issuer Node. The schemas are downloaded from IPFS and stored on Redis. This way, every time, the Issuer Node issues a Credential, it doesn't need to fetch the schemas from an external source; it can fetch it directly from Redis. This boosts the performance of the application. </p> </li> <li> <p>DB: This container is used as the data source for the Issuer Node. In our implementation of the Issuer Node, we have used Postgres as the database. It is where all the data related to issued credentials are stored. </p> </li> </ul> <p>Note</p> <p>In a testing environment, you can run the Vault, Redis, and Postgres services inside a docker. But for production, you are advised to secure these services first before using them. </p> <p> </p> Issuer Node Core API architecture."},{"location":"issuer/issuer-node-ui/","title":"Overview","text":""},{"location":"issuer/issuer-node-ui/#issuer-node-ui","title":"Issuer Node UI","text":"<p>The Issuer Node UI provides only a single identity. However, it also presents a few extra features, such as establishing connections and importing schemas. The Issuer Node UI provides the full experience of having an Issuer Node with all its capabilities. It comes in an API format but there is also a possibility to generate a full-fledged user interface. </p> <p> </p> Issuer Node API UI with Managing Schemas, Credentials and other functionalities. <p> </p> Issuer Node User Interface with a more visual experience."},{"location":"issuer/issuer-node-ui/#issuer-node-components","title":"Issuer Node Components","text":"<p>The Issuer Node comprises the following components and each one of these components can be either dockerized or each one of these can be launched as separate service. </p> <ul> <li> <p>Issuer Application to issue Verifiable Credentials and communicate with users' wallets.</p> </li> <li> <p>Vault: Based on HashiCorp, the Vault is used in the Issuer Node for providing key management services. It helps to secure sensitive data, such as the private key of the issuer, thus protecting them in a secure way. The Vault has been provided with a plugin called <code>vault-plugin-secrets-iden3</code>; this plugin is used to sign the data with Baby Jubjub Keys that are stored in the Vault. </p> </li> <li> <p>Redis: Redis is used for caching the schemas that we use in the Issuer Node. The schemas are downloaded from IPFS and stored on Redis. This way, every time, the Issuer Node issues a Credential, it doesn't need to fetch the schemas from an external source; it can fetch it directly from Redis. This boosts the performance of the application. </p> </li> <li> <p>DB: This container is used as the data source for the Issuer Node. In our implementation of the Issuer Node, we have used Postgres as the database. It is where all the data related to issued credentials are stored. </p> </li> </ul> <p>Note</p> <p>In a testing environment, you can run the Vault, Redis, and Postgres services inside a docker. But for production, you are advised to secure these services first before using them. </p> <p> </p> Issuer Node Core API architecture."},{"location":"issuer/issuer-overview/","title":"Overview","text":""},{"location":"issuer/issuer-overview/#issuer-overview","title":"Issuer Overview","text":"<p>An Issuer is any subject that issues Verifiable Credentials. You can think of a credentials as a statement: something an Issuer says about another subject. For example, when a university (Issuer) says that a student (subject) has a degree, this is a credential.</p> <p>An issuer might be: </p> <ul> <li>A DAO that issues \u201cmembership claims\" to its members.</li> <li>A Government that issues ID to its citizens.</li> <li>A Face detection ML application that issues \"proof of personhood\" claims. </li> <li>An employer that endorses its employees.</li> </ul> <p>Verifiable Credentials are a flexible data format able to express any type of information so that developers can unleash their creativity.</p>"},{"location":"issuer/issuer-overview/#operating-an-issuer","title":"Operating an issuer","text":"<p>There are some different ways one can perform issuer-related actions, that is, manage and issue credentials, establish connections with holders etc. These are the currently available options:   </p> <ul> <li> <p>Running an Issuer Node directly in your infrastructure.</p> </li> <li> <p>Utilizing the issuer node available in the Google Cloud Marketplace (soon available also on the AWS Marketplace). </p> </li> <li> <p>Adapting the JS SDK to your application that issues credentials.</p> </li> <li> <p>Using SaaS vendors that leverage Polygon ID solutions.</p> </li> <li> <p>Making use of Polygon ID smart contracts for on-chain issuance.</p> </li> </ul>"},{"location":"issuer/issuer-overview/#issuer-nodes","title":"Issuer Nodes","text":"<p>To operate, an Issuer must run an Issuer Node, which is a self-hosted Node that exposes all the functionalities necessary to run an issuer.</p> <p>There are basically two ways the Issuer Node can be implemented:</p> <ul> <li>Issuer Node Core API</li> <li>Issuer Node UI</li> </ul> <p> </p> Issuer Node Core API represented by API, in green. Issuer Node UI represented by API UI, in blue."},{"location":"issuer/issuer-overview/#issuer-node-core-api","title":"Issuer Node Core API","text":"<p>The Issuer Node Core API is ideal for users who need multiple identities and for integrator profiles, who want to create solutions based on Polygon ID functionalities and might be interested in having access to low level information such as Merkle Trees. </p> <p> </p> Issuer Node Core API with Identity, Claim and Agent endpoints."},{"location":"issuer/issuer-overview/#issuer-node-ui","title":"Issuer Node UI","text":"<p>The Issuer Node UI provides only a single identity. However, it also presents a few extra features, such as establishing connections and importing schemas. The Issuer Node UI provides the full experience of having an Issuer Node with all its capabilities. It comes in an API format but there is also a possibility to generate a full-fledged user interface. </p> <p> </p> Issuer Node User Interface with a more visual experience. <p> </p> Issuer Node API UI with Managing Schemas, Credentials and other functionalities."},{"location":"issuer/schema-builder/","title":"Schema Builder UI","text":"<p>In order to create new types of credentials, it is necessary to generate JSON schemas. These are the underlying files that define the credential attributes.  The Schema Builder is a tool created to simplify the process of creating schemas by using an intuitive user interface and enabling everyone to check previously made schemas.</p> <p>Info</p> <p>All the information on this page is also in video format. You can check this playlist on Youtube to learn more about the Schema Explorer and the Schema Builder.  </p>"},{"location":"issuer/schema-builder/#schema-explorer","title":"Schema Explorer","text":"<p>The Schema Builder landing page presents a Schema Explorer, where you can find all previously created schemas and drill down your search for specific kinds of schemas. Not all schemas need to be created from scratch. It is a good practice to utilize the ones that are already in use.</p> <p> </p> Schema Explorer showing credentials and filters. <p>We highly recommend that you look for one of the available schemas before actually creating one. By doing so, you can save time for your project and leverage a full library of popular ready-to-use schemas. If you find a schema that is similar to what you need but you are not completely happy with its characteristics, you can always fork it.</p> <p> </p> Schema details page with options to fork, check other versions and change visualization. <p>Forking a schema is similar to GitHub forks. It creates a copy of the schema and lets you define new attributes. So you build your own out of another one.  </p> <p> </p> Building a new schema from a previously forked one. <p>Info</p> <p>The outcome of a forked schema shows its version and where it was forked from. </p> <p>The forked schema also shows its number of forks:</p> <p></p>"},{"location":"issuer/schema-builder/#schema-builder","title":"Schema Builder","text":"<p>As previously stated, the Schema Builder is the easiest way to generate new types of credentials as it allows users to define the attributes, data types, and constraints for their schemas, and the tool will generate the necessary JSON-LD files and other artifacts required to implement the schema.</p> <p> </p> Schema form and its JSON outcome. <p>Info</p> <p>If you already have access to a file containing a JSON schema or a URL where that schema might be located, you can always add it to the Schema Builder by clicking on the Import Schema button. Then you will be able to edit, create new JSON and JSON-LD files and publish it on IPFS. </p>"},{"location":"issuer/schema-builder/#schema-definition","title":"Schema definition","text":"<p>The first page of the Schema Builder flow lets you define the basic aspects of the schema, namely its title, type, version and description.</p> <p> </p> Main Schema fields. <ul> <li>Title: a name for the schema.</li> <li>Schema Type: a set of attributes used to shape the data stored in one credential. </li> <li>Version: this is important to register the current version of the schema, as it might be updated in the future.</li> <li>Description: a description of the schema should explain in simple terms what it will be used for. </li> </ul>"},{"location":"issuer/schema-builder/#attributes","title":"Attributes","text":"<p>You can add multiple attributes to your schema. All of them need to have the following characteristics: name, title, data type and description.</p> <p> </p> Schema attribute fields. <ul> <li>Name: the name of the attribute with a limited use of characters.</li> <li>Title: a more human-readable title for the attribute without restrictions for special characters or space.</li> <li>Data type: the kind of data the schema will support, such as integer, string, boolean etc.</li> <li>Description: a short human-readable explanation of the attribute.</li> </ul>"},{"location":"issuer/schema-builder/#publish-on-ipfs-or-download-json-file","title":"Publish on IPFS or Download JSON file","text":"<p>The last step of building a new schema is publishing it on IPFS. As an alternative, you can download the JSON file and store it in the location of your choice.</p>"},{"location":"issuer/schema-exs/","title":"Schema Examples","text":""},{"location":"issuer/schema-exs/#schema-examples","title":"Schema examples","text":"<p>Here are some schemas with different data types.</p>"},{"location":"issuer/schema-exs/#boolean","title":"Boolean","text":"<p>schema: https://raw.githubusercontent.com/0xPolygonID/issuer-node/main/docs/examples/schemas/json/exampleBoolean.json</p> <p>type: CodingExperienceCredential</p> <p>body:</p> <pre><code>{\n    \"credentialSchema\": \"https://raw.githubusercontent.com/0xPolygonID/sh-id-platform/adding-schema-examples/docs/examples/schemas/json/exampleBoolean.json\",\n    \"type\": \"CodingExperienceCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qLPX9XnujT2xhuiPMHrqXTUD96UCV87CtThRUZFQm\",\n        \"codingExperience\": true\n    },\n    \"expiration\": \"2025-04-05T08:34:07.117Z\",\n    \"signatureProof\": true,\n    \"mtProof\": false\n}\n</code></pre>"},{"location":"issuer/schema-exs/#date-date-time","title":"Date / Date-time","text":"<p>schema: https://raw.githubusercontent.com/0xPolygonID/issuer-node/main/docs/examples/schemas/json/exampleDate.json</p> <p>type: HireDateCredential</p> <p>body:</p> <pre><code>{\n    \"credentialSchema\": \"https://raw.githubusercontent.com/0xPolygonID/sh-id-platform/adding-schema-examples/docs/examples/schemas/json/exampleDate.json\",\n    \"type\": \"HireDateCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qLPX9XnujT2xhuiPMHrqXTUD96UCV87CtThRUZFQm\",\n        \"hireDate\": \"2020-12-12\"\n    },\n    \"expiration\": \"2025-04-05T08:34:07.117Z\",\n    \"signatureProof\": true,\n    \"mtProof\": false\n}\n</code></pre>"},{"location":"issuer/schema-exs/#integer","title":"Integer","text":"<p>schema: https://raw.githubusercontent.com/0xPolygonID/issuer-node/main/docs/examples/schemas/json/exampleInteger.json</p> <p>type: BirthdayCredential</p> <p>body:</p> <pre><code>{\n    \"credentialSchema\": \"https://raw.githubusercontent.com/0xPolygonID/sh-id-platform/adding-schema-examples/docs/examples/schemas/json/exampleInteger.json\",\n    \"type\": \"BirthdayCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qLPX9XnujT2xhuiPMHrqXTUD96UCV87CtThRUZFQm\",\n        \"birthday\": 20201012\n    },\n    \"expiration\": \"2025-04-05T08:34:07.117Z\",\n    \"signatureProof\": true,\n    \"mtProof\": false\n}\n</code></pre>"},{"location":"issuer/schema-exs/#number-floatdouble","title":"Number (float/double)","text":"<p>*schema:* https://raw.githubusercontent.com/0xPolygonID/issuer-node/main/docs/examples/schemas/json/exampleNumber.json</p> <p>type: SalaryCredential</p> <p>body:</p> <pre><code>{\n    \"credentialSchema\": \"https://raw.githubusercontent.com/0xPolygonID/sh-id-platform/adding-schema-examples/docs/examples/schemas/json/exampleNumber.json\",\n    \"type\": \"SalaryCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qLPX9XnujT2xhuiPMHrqXTUD96UCV87CtThRUZFQm\",\n        \"salary\": 1000.0\n    },\n    \"expiration\": \"2025-04-05T08:34:07.117Z\",\n    \"signatureProof\": true,\n    \"mtProof\": false\n}\n</code></pre>"},{"location":"issuer/schema-exs/#string","title":"String","text":"<p>schema: https://raw.githubusercontent.com/0xPolygonID/issuer-node/main/docs/examples/schemas/json/exampleString.json</p> <p>type: RoleCredential</p> <p>body:</p> <pre><code>{\n    \"credentialSchema\": \"https://raw.githubusercontent.com/0xPolygonID/sh-id-platform/adding-schema-examples/docs/examples/schemas/json/exampleString.json\",\n    \"type\": \"RoleCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qLPX9XnujT2xhuiPMHrqXTUD96UCV87CtThRUZFQm\",\n        \"role\": \"developer\"\n    },\n    \"expiration\": \"2025-04-05T08:34:07.117Z\",\n    \"signatureProof\": true,\n    \"mtProof\": false\n}\n</code></pre>"},{"location":"issuer/schema-exs/#full-example-multiple-types","title":"Full example - multiple types","text":"<p>schema: https://raw.githubusercontent.com/0xPolygonID/issuer-node/main/docs/examples/schemas/json/exampleEmployee.json</p> <p>type: EmployeeCredential</p> <p>body:</p> <pre><code>{\n    \"credentialSchema\": \"https://raw.githubusercontent.com/0xPolygonID/sh-id-platform/adding-schema-examples/docs/examples/schemas/json/exampleEmployee.json\",\n    \"type\": \"EmployeeCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qLPX9XnujT2xhuiPMHrqXTUD96UCV87CtThRUZFQm\",\n        \"role\": \"developer\",\n        \"hireDate\":\"2022-10-10\",\n        \"birthday\": 19901204,\n        \"salary\": 10000.0,\n        \"codingExperience\": true\n    },\n    \"expiration\": \"2025-04-05T08:34:07.117Z\",\n    \"signatureProof\": true,\n    \"mtProof\": false\n}\n</code></pre>"},{"location":"issuer/schema/","title":"Create Custom Schemas","text":""},{"location":"issuer/schema/#create-custom-schemas","title":"Create Custom Schemas","text":"<p>Info</p> <p>Polygon ID offers an intuitive, user-friendly user interface to create schemas: the Schema Builder. Here you can find a tutorial for this tool. You can also access it on https://schema-builder.polygonid.me/. </p> <p>A Schema Type encodes the structure of a particular Verifiable Credential (VC) by defining the type, the fields that must be included inside the VC, and a description for these fields.</p> <p>Schemas are a crucial component that allows for the interoperable use of VCs across different services. Just by parsing a schema, any program can interpret the content of a Verifiable Credential without having to interact with Issuer Party.</p> <p>In order to issue Verifiable Credentials, you can refer to existing schemas. If the existing ones are not able to describe the type of data you desire, you need to create your own schema <code>Type</code>.</p> <p>A schema type is made of two documents:</p> <ul> <li> <p><code>JSON-LD Context</code>, which contains a description of the type and its fields. Here is an example of JSON-LD Context for Schema Type <code>CodingExperienceCredential</code></p> </li> <li> <p><code>JSON Schema</code> which contains the validation rules for the Issuer Node. Here is an example of a JSON Schema for Schema Type <code>CodingExperienceCredential</code>.</p> </li> </ul> <p>Without further ado, let's jump into building a new Schema Type!</p>"},{"location":"issuer/schema/#tutorial","title":"Tutorial","text":"<p>Note: The executable code and further schemas examples for this section can be found here. </p> <p>Let's suppose we are a DAO that wants to issue VCs to its members. Unfortunately, there's no existing schemas that can accommodate this type of data attestation. In order to issue these VCs, a schema of type <code>ProofOfDaoLongevity</code> needs to be created. This example will show you how to create a schema type that contains a single field, you can extend it to include more fields.</p> <p>1. Define which field to include in the schema</p> <p>The <code>ProofOfDaoLongevity</code> should include a field defined <code>entryDate</code> able to attest the specific date when one joined the DAO. A credential can contain as many fields as you want!</p> <p>2. Create the vocabulary of the Schema Type</p> <p>Create a markdown file in your git repository to describe the vocabulary used inside the Schema Type. We decide to name the file <code>proof-of-dao-longevity-vocab.md</code>. This should contain a description of the (only) field <code>entryDate</code> included in the schema type.</p> <pre><code># entryDate\n\nDescribes the date when a contributor joined the DAO\n</code></pre> <p>3. Create the JSON-LD Context</p> <p>Create a <code>.jsonld</code> file in your repository to contain the JSON-LD Context of the Schema Type. We decide to name it <code>proof-of-dao-longevity.jsonld</code>.</p> <p>The JSON-LD Context contains:</p> <ul> <li> <p>the name of the Type</p> </li> <li> <p>its unique identifier <code>@id</code> which is a public URL where the context can be resolved. </p> <p>If you are working on Github, you can fetch the URL directly from your published repository based on the file path. In this case it is </p> <p><code>https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.jsonld#ProofOfDaoLongevity</code></p> </li> <li> <p>the definition of the vocabulary with its URL</p> <p>In this case we create a field defined <code>vocab</code> and attach the URL that identifies the vocabulary. In this case it is </p> <p><code>https://github.com/0xPolygonID/tutorial-examples/blob/main/credential-schema/proof-of-dao-longevity-vocab.md#</code></p> </li> <li> <p>The field that we want to include inside the credential, defined together with its identifier and its data type (all xsd data type are available)</p> <pre><code>{\n  \"@context\": [\n    {\n      \"@version\": 1.1,\n      \"@protected\": true,\n      \"id\": \"@id\",\n      \"type\": \"@type\",\n      \"ProofOfDaoLongevity\": {\n        \"@id\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.jsonld#ProofOfDaoLongevity\",\n        \"@context\": {\n          \"@version\": 1.1,\n          \"@protected\": true,\n          \"id\": \"@id\",\n          \"type\": \"@type\",\n          \"vocab\": \"https://github.com/0xPolygonID/tutorial-examples/blob/main/credential-schema/proof-of-dao-longevity-vocab.md#\",\n          \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n          \"entryDate\": {\n            \"@id\": \"vocab:entryDate\",\n            \"@type\": \"xsd:integer\"\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre> </li> </ul> <p>Note: The lines which are underlined are the only ones that need to be modified in order to create a new Schema Type.</p> <p>5. Create the JSON Schema</p> <p>Last but not least, we have to create the JSON Schema Document.  We decide to name it <code>proof-of-dao-longevity.json</code>. This a document that contains the serialization rule and the instruction for the Issuer to build Verifiable Credentials based on a specific schema type and spot any error in the process. Although it might seem complex and verbose, there are just a few values that need to be updated to adapt to your purpose:</p> <ul> <li> <p>Add the URIs to your specific <code>jsonLdContext</code> and <code>jsonSchema</code>:</p> </li> <li> <p>Inside <code>CredentialSubject</code> update the information related to your field:</p> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"$metadata\": {\n      \"uris\": {\n        \"jsonLdContext\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.jsonld\",\n        \"jsonSchema\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.json\"\n      }\n    },\n    \"required\": [\n      \"@context\",\n      \"id\",\n      \"type\",\n      \"issuanceDate\",\n      \"credentialSubject\",\n      \"credentialSchema\",\n      \"credentialStatus\",\n      \"issuer\"\n    ],\n    \"properties\": {\n      \"@context\": {\n        \"type\": [\n          \"string\",\n          \"array\",\n          \"object\"\n        ]\n      },\n      \"id\": {\n        \"type\": \"string\"\n      },\n      \"type\": {\n        \"type\": [\n          \"string\",\n          \"array\"\n        ],\n        \"items\": {\n          \"type\": \"string\"\n        }\n      },\n      \"issuer\": {\n        \"type\": [\n          \"string\",\n          \"object\"\n        ],\n        \"format\": \"uri\",\n        \"required\": [\n          \"id\"\n        ],\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          }\n        }\n      },\n      \"issuanceDate\": {\n        \"type\": \"string\",\n        \"format\": \"date-time\"\n      },\n      \"expirationDate\": {\n        \"type\": \"string\",\n        \"format\": \"date-time\"\n      },\n      \"credentialSchema\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"id\",\n          \"type\"\n        ],\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          },\n          \"type\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"subjectPosition\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"none\",\n          \"index\",\n          \"value\"\n        ]\n      },\n      \"merklizationRootPosition\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"none\",\n          \"index\",\n          \"value\"\n        ]\n      },\n      \"revNonce\": {\n        \"type\": \"integer\"\n      },\n      \"version\": {\n        \"type\": \"integer\"\n      },\n      \"updatable\": {\n        \"type\": \"boolean\"\n      },\n      \"credentialSubject\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"id\",\n          \"entryDate\"\n        ],\n        \"properties\": {\n          \"id\": {\n            \"title\": \"Credential Subject ID\",\n            \"type\": \"string\",\n            \"format\": \"uri\"\n          },\n          \"entryDate\": {\n            \"type\": \"integer\"\n          }\n        }\n      }\n    }\n  }\n</code></pre> </li> </ul> <p>6. Publish it!</p> <p>If you were working on a git repository, push all the files, make sure that the repo is public and that's it!</p>"},{"location":"issuer/schema/#further-resources","title":"Further Resources","text":"<ul> <li>JSON-LD - W3C VC Standard</li> <li>JSON-LD Context - W3C VC Standard </li> </ul>"},{"location":"issuer/setup-issuer-core/","title":"Setup Guide (Core API)","text":""},{"location":"issuer/setup-issuer-core/#getting-started","title":"Getting Started","text":"<p>This article details the steps that can be carried out to achieve full integration of the Issuer Node with the Polygon ID APIs.</p>"},{"location":"issuer/setup-issuer-core/#installation","title":"Installation","text":"<p>There are two options for installing and running the server alongside the UI:</p> <ol> <li>Docker Setup Guide</li> <li>Standalone Mode Guide</li> </ol> <p>Note</p> <p>You can follow the instructions below or watch this video showing the same steps to set up an issuer node.</p> <p></p> <p>For either one, you first have to clone the repository.</p> DockerStandalone Mode Guide"},{"location":"issuer/setup-issuer-core/#docker-setup-guide","title":"Docker Setup Guide","text":"<p>Running the app with Docker allows for minimal installation and a quick setup. This is recommended for evaluation use-cases only, such as local development builds.</p>"},{"location":"issuer/setup-issuer-core/#docker-guide-requirements","title":"Docker Guide Requirements","text":"<ul> <li>Unix-based operating system (e.g. Debian, Arch, Mac OS)</li> <li>Docker Engine <code>1.27+</code></li> <li>Makefile toolchain <code>GNU Make 3.81</code></li> </ul> <p>Warning</p> <p>There is no compatibility with Windows environments at this time.</p> <p>To help expedite a lot of the Docker commands, many have been abstracted using <code>make</code> commands. Included in the following sections are the equivalent Docker commands that show what is being run.</p>"},{"location":"issuer/setup-issuer-core/#create-docker-configuration-files","title":"Create Docker Configuration Files","text":"<p>Make sure you are in the root folder and then make a copy of the following environment variables files:</p> <pre><code># FROM: ./\n\ncp .env-api.sample .env-api;\ncp .env-issuer.sample .env-issuer;\n# (Optional - For issuer UI)\ncp .env-ui.sample .env-ui;\n</code></pre>"},{"location":"issuer/setup-issuer-core/#node-issuer-configuration","title":"Node Issuer Configuration","text":"<p>The <code>.env-issuer</code> will be loaded into the Docker compose initializer.</p> <p>Any of the following RPC providers can be used:</p> <ul> <li>Chainstack</li> <li>Ankr</li> <li>QuickNode</li> <li>Alchemy</li> <li>Infura</li> </ul> <p>Mainnet or Testnet?</p> <p>Using Mainnet or Testnet will depend on the RPC URL you are going to use in this step. After you decide which of the RPC providers you will be using, like any of the examples above, you will need to copy the URL for the network you are willing to use.</p> <p>If it is desired to run a free public forwarding URL, see Getting A Public URL.</p> <p>Configure <code>.env-issuer</code> with the following details (or amend as desired).</p> <pre><code># ...\n\n# See Section: Getting A Public URL\nISSUER_SERVER_URL=&lt;https://unique-forwaring-or-public-url.ngrok-free.app&gt;\n# Defaults for Basic Auth in Base64 (\"user-issuer:password-issuer\" = \"dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy\")\n# If you just want to get started, don't change these\nISSUER_API_AUTH_USER=user-issuer\nISSUER_API_AUTH_PASSWORD=password-issuer\n# !!!MUST BE SET or other steps will not work\nISSUER_ETHEREUM_URL=&lt;YOUR_RPC_PROVIDER_URI_ENDPOINT&gt;\n</code></pre> <p>Note</p> <p>In case the Vault was loaded multiple times and a fresh start is needed, the following will remove remnant data:</p> <pre><code># FROM: ./\n\nmake clean-vault;\n# (Equivalent)\n#   rm -R infrastructure/local/.vault/data/init.out\n#   rm -R infrastructure/local/.vault/file/core/\n#   rm -R infrastructure/local/.vault/file/logical/\n#   rm -R infrastructure/local/.vault/file/sys/\n\n# Expected Output/Prompt:\n#   rm -R infrastructure/local/.vault/data/init.out\n#   rm -R infrastructure/local/.vault/file/core/\n#   rm -R infrastructure/local/.vault/file/logical/\n#   rm -R infrastructure/local/.vault/file/sys/\n</code></pre>"},{"location":"issuer/setup-issuer-core/#start-redis-postgres-vault","title":"Start Redis Postgres &amp; Vault","text":"<p>This will start the necessary local services needed to store the wallet private key to the Hashicorp vault and allow storing data associated to the issuer. Don't forget to initialize Docker before running this command.</p> <pre><code># FROM: ./\n\nmake up;\n# (Equivalent)\n#   docker compose -p issuer -f ./infrastructure/local/docker-compose-infra.yml up -d redis postgres vault;\n\n# Expected Output:\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose-infra.yml up -d redis postgres vault\n#   [+] Running 4/4\n#   \u283f Network issuer-network       Created                                                                                   0.0s\n#   \u283f Container issuer-vault-1     Started                                                                                   0.5s\n#   \u283f Container issuer-redis-1     Started                                                                                   0.4s\n#   \u283f Container issuer-postgres-1  Started  \n</code></pre> <p>To remove all services, run the following (ignore the warnings):</p> <pre><code># FROM: ./\n\nmake down; \n# (Equivalent)\n#   docker compose -p issuer -f ./infrastructure/local/docker-compose-infra.yml down --remove-orphans -v;\n\n# Expected Output:\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose-infra.yml down --remove-orphans\n#   [+] Running 4/3\n#   \u283f Container issuer-postgres-1  Removed                                                                                   0.2s\n#   \u283f Container issuer-redis-1     Removed                                                                                   0.2s\n#   \u283f Container issuer-vault-1     Removed                                                                                   0.2s\n#   \u283f Network issuer-network       Removed                                                                                   0.0s\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml down --remove-orphans\n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string.\n</code></pre>"},{"location":"issuer/setup-issuer-core/#import-wallet-private-key-to-vault","title":"Import Wallet Private Key To Vault","text":"<p>In order to secure the wallet private key so that the issuer can use it to issue credentials, it must be stored in the Hashicorp Vault.</p> <p>Note</p> <p>Make sure the wallet that is provided has Testnet Matic to be able to send transactions and that you are providing the Private Key. Here's how you can extract the private key from MetaMask, for instance.</p> <pre><code># FROM: ./\n\n# Make sure to verify that the issuer-vault-1 is full initialized to avoid: \"Error writing data to iden3/import/pbkey: Error making API request.\"\nmake private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt; add-private-key;\n# (Equivalent)\n#   docker exec issuer-vault-1 vault write iden3/import/pbkey key_type=ethereum private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt;;\n\n# Expected Output:\n#   docker exec issuer-vault-1 \\\n#           vault write iden3/import/pbkey key_type=ethereum private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt;\n#   Success! Data written to: iden3/import/pbkey\n</code></pre>"},{"location":"issuer/setup-issuer-core/#add-vault-to-configuration-file","title":"Add Vault To Configuration File","text":"<p>This will get the vault token from the Hashicorp vault docker instance and add it to our <code>./env-issuer</code> file.</p> <pre><code># FROM: ./\n\nmake add-vault-token;\n# (Equivalent)\n#   TOKEN=$(docker logs issuer-vault-1 2&gt;&amp;1 | grep \" .hvs\" | awk  '{print $2}' | tail -1);\n# sed '/ISSUER_KEY_STORE_TOKEN/d' .env-issuer &gt; .env-issuer.tmp;\n# echo ISSUER_KEY_STORE_TOKEN=$TOKEN &gt;&gt; .env-issuer.tmp;\n# mv .env-issuer.tmp .env-issuer;\n\n# Expected Output:\n#   sed '/ISSUER_KEY_STORE_TOKEN/d' .env-issuer &gt; .env-issuer.tmp\n#   mv .env-issuer.tmp .env-issuer\n</code></pre>"},{"location":"issuer/setup-issuer-core/#start-issuer-api","title":"Start Issuer API","text":"<p>Now that the issuer API is configured, it can be started.</p> NON-Apple-M1/M2/Arm (ex: Intel/AMD)Apple-M1/M2/Arm <pre><code># FROM: ./\n\nmake run;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api;\n</code></pre> <pre><code># FROM: ./\n\nmake run-arm;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api;\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n</code></pre> <p>Navigating to http://localhost:3001 shows the issuer API endpoints:</p> <p></p>"},{"location":"issuer/setup-issuer-core/#standalone-mode-guide","title":"Standalone Mode Guide","text":"<p>Running the app in standalone mode means you will need to install the binaries for the server to run natively. This is essential for production deployments.</p> <p>Make sure you have Postgres, Redis and Vault properly installed &amp; configured. Do not use <code>make up</code> since those will start the containers for non-production builds, see Docker Setup Guide.</p>"},{"location":"issuer/setup-issuer-core/#standalone-mode-guide-requirements","title":"Standalone Mode Guide Requirements","text":"<ul> <li>Docker Engine 1.27</li> <li>Makefile toolchain</li> <li>Unix-based operating system (e.g. Debian, Arch, Mac OS X)</li> <li>Go 1.19</li> <li>Postgres</li> <li>Redis</li> <li>Hashicorp Vault</li> </ul>"},{"location":"issuer/setup-issuer-core/#standalone-mode-setup","title":"Standalone Mode Setup","text":"<ol> <li>Copy <code>.env-api.sample</code> as <code>.env-api</code> and <code>.env-issuer.sample</code> as <code>.env-issuer</code>. Please see the configuration section for more details.</li> <li>Run <code>make build-local</code>. This will generate a binary for each of the following commands:<ul> <li><code>platform</code></li> <li><code>platform_ui</code></li> <li><code>migrate</code></li> <li><code>pending_publisher</code></li> <li><code>notifications</code></li> </ul> </li> <li>Run <code>make db/migrate</code>. This checks the database structure and applies any changes to the database schema.</li> <li>Run <code>./bin/platform</code> command to start the issuer.</li> <li>Run <code>./bin/pending_publisher</code>. This checks that publishing transactions to the blockchain works.</li> <li>Follow the steps for adding an Ethereum private key to the Vault from the Docker installation mode.</li> </ol>"},{"location":"issuer/setup-issuer-core/#configuration","title":"Configuration","text":""},{"location":"issuer/setup-issuer-core/#getting-a-public-url","title":"Getting A Public URL","text":"<p>For the service to work, we'll need a public URL. An easy way to set this up is by using ngrok as a forwarding service that maps to a local port. After downloading and installing ngrok, run the follwing command and copy the Forwarding URL:</p> <pre><code># For issuer-api ISSUER_SERVER_URL env var (.env-issuer file)\n./ngrok http 3001; \n</code></pre> <p>Copy the Forwarding output value into the desired env var</p> <pre><code># FROM: /path/to/ngrok binary\n\n# Expected Output:\n# Add OAuth and webhook security to your ngrok (its free!): https://ngrok.com/free\n# \n# Session Status                online\n# Account                       YourAccountUsername (Plan: Free)\n# Update                        update available (version 3.2.1, Ctrl-U to update)\n# Version                       3.1.0\n# Region                        Europe (eu)\n# Latency                       -\n# Web Interface                 http://127.0.0.1:4040\n# Forwarding                    https://unique-forwading-address.eu.ngrok.io -&gt; http://localhost:3001\n# \n# Connections                   ttl     opn     rt1     rt5     p50     p90\n                              # 0       0       0.00    0.00    0.00    0.00\n</code></pre>"},{"location":"issuer/setup-issuer-ui/","title":"Setup Guide (API UI)","text":""},{"location":"issuer/setup-issuer-ui/#getting-started","title":"Getting Started","text":"<p>This article details the steps that can be carried out to achieve full integration of the Issuer Node with the Polygon ID APIs.</p>"},{"location":"issuer/setup-issuer-ui/#installation","title":"Installation","text":"<p>There are two options for installing and running the server alongside the UI:</p> <ol> <li>Docker Setup Guide</li> <li>Standalone Mode Guide</li> </ol> <p>For either one, you first have to clone the repository.</p> <p>Note</p> <p>You can follow the instructions below or watch this video showing the same steps to set up an issuer node.</p> <p></p> DockerStandalone Mode Guide"},{"location":"issuer/setup-issuer-ui/#docker-setup-guide","title":"Docker Setup Guide","text":"<p>Running the app with Docker allows for minimal installation and a quick setup. This is recommended for evaluation use-cases only, such as local development builds.</p>"},{"location":"issuer/setup-issuer-ui/#docker-guide-requirements","title":"Docker Guide Requirements","text":"<ul> <li>Unix-based operating system (e.g. Debian, Arch, Mac OS)</li> <li>Docker Engine <code>1.27+</code></li> <li>Makefile toolchain <code>GNU Make 3.81</code></li> </ul> <p>Warning</p> <p>There is no compatibility with Windows environments at this time.</p> <p>To help expedite a lot of the Docker commands, many have been abstracted using <code>make</code> commands. Included in the following sections are the equivalent Docker commands that show what is being run.</p>"},{"location":"issuer/setup-issuer-ui/#create-docker-configuration-files","title":"Create Docker Configuration Files","text":"<p>Make sure you are in the root folder and then make a copy of the following environment variables files:</p> <pre><code># FROM: ./\n\ncp .env-api.sample .env-api;\ncp .env-issuer.sample .env-issuer;\n# (Optional - For issuer UI)\ncp .env-ui.sample .env-ui;\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#node-issuer-configuration","title":"Node Issuer Configuration","text":"<p>The <code>.env-issuer</code> will be loaded into the Docker compose initializer.</p> <p>Any of the following RPC providers can be used:</p> <ul> <li>Chainstack</li> <li>Ankr</li> <li>QuickNode</li> <li>Alchemy</li> <li>Infura</li> </ul> <p>Mainnet or Testnet?</p> <p>Using Mainnet or Testnet will depend on the RPC URL you are going to use in this step. After you decide which of the RPC providers you will be using, like any of the examples above, you will need to copy the URL for the network you are willing to use.</p> <p>If it is desired to run a free public forwarding URL, see Getting A Public URL.</p> <p>Configure <code>.env-issuer</code> with the following details (or amend as desired).</p> <pre><code># ...\n\n# See Section: Getting A Public URL\nISSUER_SERVER_URL=&lt;https://unique-forwaring-or-public-url.ngrok-free.app&gt;\n# Defaults for Basic Auth in Base64 (\"user-issuer:password-issuer\" = \"dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy\")\n# If you just want to get started, don't change these\nISSUER_API_AUTH_USER=user-issuer\nISSUER_API_AUTH_PASSWORD=password-issuer\n# !!!MUST BE SET or other steps will not work\nISSUER_ETHEREUM_URL=&lt;YOUR_RPC_PROVIDER_URI_ENDPOINT&gt;\n</code></pre> <p>Note</p> <p>In case the Vault was loaded multiple times and a fresh start is needed, the following will remove remnant data:</p> <pre><code># FROM: ./\n\nmake clean-vault;\n# (Equivalent)\n#   rm -R infrastructure/local/.vault/data/init.out\n#   rm -R infrastructure/local/.vault/file/core/\n#   rm -R infrastructure/local/.vault/file/logical/\n#   rm -R infrastructure/local/.vault/file/sys/\n\n# Expected Output/Prompt:\n#   rm -R infrastructure/local/.vault/data/init.out\n#   rm -R infrastructure/local/.vault/file/core/\n#   rm -R infrastructure/local/.vault/file/logical/\n#   rm -R infrastructure/local/.vault/file/sys/\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#start-redis-postgres-vault","title":"Start Redis Postgres &amp; Vault","text":"<p>This will start the necessary local services needed to store the wallet private key to the Hashicorp vault and allow storing data associated to the issuer. Don't forget to initialize Docker before running this command.</p> <pre><code># FROM: ./\n\nmake up;\n# (Equivalent)\n#   docker compose -p issuer -f ./infrastructure/local/docker-compose-infra.yml up -d redis postgres vault;\n\n# Expected Output:\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose-infra.yml up -d redis postgres vault\n#   [+] Running 4/4\n#   \u283f Network issuer-network       Created                                                                                   0.0s\n#   \u283f Container issuer-vault-1     Started                                                                                   0.5s\n#   \u283f Container issuer-redis-1     Started                                                                                   0.4s\n#   \u283f Container issuer-postgres-1  Started  \n</code></pre> <p>To remove all services, run the following (ignore the warnings):</p> <pre><code># FROM: ./\n\nmake down; \n# (Equivalent)\n#   docker compose -p issuer -f ./infrastructure/local/docker-compose-infra.yml down --remove-orphans -v;\n\n# Expected Output:\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose-infra.yml down --remove-orphans\n#   [+] Running 4/3\n#   \u283f Container issuer-postgres-1  Removed                                                                                   0.2s\n#   \u283f Container issuer-redis-1     Removed                                                                                   0.2s\n#   \u283f Container issuer-vault-1     Removed                                                                                   0.2s\n#   \u283f Network issuer-network       Removed                                                                                   0.0s\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml down --remove-orphans\n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string.\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#import-wallet-private-key-to-vault","title":"Import Wallet Private Key To Vault","text":"<p>In order to secure the wallet private key so that the issuer can use it to issue credentials, it must be stored in the Hashicorp Vault.</p> <p>Note</p> <p>Make sure the wallet that is provided has Testnet Matic to be able to send transactions and that you are providing the Private Key. Here's how you can extract the private key from MetaMask, for instance.</p> <pre><code># FROM: ./\n\n# Make sure to verify that the issuer-vault-1 is full initialized to avoid: \"Error writing data to iden3/import/pbkey: Error making API request.\"\nmake private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt; add-private-key;\n# (Equivalent)\n#   docker exec issuer-vault-1 vault write iden3/import/pbkey key_type=ethereum private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt;;\n\n# Expected Output:\n#   docker exec issuer-vault-1 \\\n#           vault write iden3/import/pbkey key_type=ethereum private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt;\n#   Success! Data written to: iden3/import/pbkey\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#add-vault-to-configuration-file","title":"Add Vault To Configuration File","text":"<p>This will get the vault token from the Hashicorp vault docker instance and add it to our <code>./env-issuer</code> file.</p> <pre><code># FROM: ./\n\nmake add-vault-token;\n# (Equivalent)\n#   TOKEN=$(docker logs issuer-vault-1 2&gt;&amp;1 | grep \" .hvs\" | awk  '{print $2}' | tail -1);\n# sed '/ISSUER_KEY_STORE_TOKEN/d' .env-issuer &gt; .env-issuer.tmp;\n# echo ISSUER_KEY_STORE_TOKEN=$TOKEN &gt;&gt; .env-issuer.tmp;\n# mv .env-issuer.tmp .env-issuer;\n\n# Expected Output:\n#   sed '/ISSUER_KEY_STORE_TOKEN/d' .env-issuer &gt; .env-issuer.tmp\n#   mv .env-issuer.tmp .env-issuer\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#create-issuer-did","title":"Create Issuer DID","text":"<p>Note</p> <p>This can also be done via the UI API.</p> <p>This will create a new issuer DID by creating a new Docker instance of the issuer, generating the DID of the issuer, storing it in the database, then deleting the instance.</p> <p>It then copies the new DID to <code>.env-api</code>.</p> NON-Apple-M1/M2/Arm (ex: Intel/AMD)Apple-M1/M2/Arm <pre><code># FROM: ./\n\n# NON-Apple-M1/M2/Arm Command:\nmake generate-issuer-did;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f ./infrastructure/local/docker-compose.yml up -d initializer\n# sleep 5\n#  $(eval DID = $(shell docker logs -f --tail 1 issuer-initializer-1 | grep \"did\"))\n#  @echo $(DID)\n#  sed '/ISSUER_API_UI_ISSUER_DID/d' .env-api &gt; .env-api.tmp\n#  @echo ISSUER_API_UI_ISSUER_DID=$(DID) &gt;&gt; .env-api.tmp\n#  mv .env-api.tmp .env-api\n#  docker rm issuer-initializer-1\n</code></pre> <pre><code># FROM: ./\n\n# Apple-M1/M2/Arm Command:\nmake generate-issuer-did-arm;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d initializer;\n# sleep 5;\n#   DID=$(docker logs -f --tail 1 issuer-initializer-1 | grep \"did\");\n#   echo $DID;\n#   sed '/ISSUER_API_UI_ISSUER_DID/d' .env-api &gt; .env-api.tmp;\n#   echo ISSUER_API_UI_ISSUER_DID=$DID &gt;&gt; .env-api.tmp;\n#   mv .env-api.tmp .env-api;\n#   docker rm issuer-initializer-1;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d initializer\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n#   [+] Running 1/1\n#   \u283f Container issuer-initializer-1  Started                                                                                0.2s\n#   sleep 5\n#   did:polygonid:polygon:mumbai:uniqueAlphanumericKeyGenerated\n#   sed '/ISSUER_API_UI_ISSUER_DID/d' .env-api &gt; .env-api.tmp\n#   mv .env-api.tmp .env-api\n#   docker rm issuer-initializer-1\n#   issuer-initializer-1\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#configure-ui","title":"Configure UI","text":"<p>This step is required to run the separate UI application, which allows intuitive and convenient management of schemas, credentials, connections and issuer state.</p> <p>Tip</p> <p>Running and using the UI is optional, since it implements funcionality already exposed via the UI API. It is highly recommended though, because it makes issuer management far simpler and more intuitive.</p> <pre><code># FROM: ./\n\ncp .env-ui.sample .env-ui;\n</code></pre> <p>Configure the <code>.env-ui</code> file with the following details (or amend as desired):</p> <pre><code>ISSUER_UI_BLOCK_EXPLORER_URL=https://mumbai.polygonscan.com\nISSUER_UI_AUTH_USERNAME=user-ui\nISSUER_UI_AUTH_PASSWORD=password-ui\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#start-api-ui-ui-notifications-server-publisher","title":"Start API UI, UI, Notifications server &amp; Publisher","text":"<p>This will start the UI API that exposes endpoints to manage schemas, credentials, connections and issuer state, as well as the UI that relies on it.</p> NON-Apple-M1/M2/Arm (ex: Intel/AMD)Apple-M1/M2/Arm <pre><code># FROM: ./\n\nmake run-ui;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api-ui ui notifications pending_publisher;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api-ui ui notifications pending_publisher\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n#   [+] Running 4/4\n#    \u283f Container issuer-ui-1                 Started                                                                                                           0.5s\n#    \u283f Container issuer-api-ui-1             Started                                                                                                           0.5s\n#    \u283f Container issuer-notifications-1      Started                                                                                                           0.4s\n#    \u283f Container issuer-pending_publisher-1  Running  \n</code></pre> <pre><code># FROM: ./\n\nmake run-ui-arm;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api-ui ui notifications pending_publisher;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api-ui ui notifications pending_publisher\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n#   [+] Running 4/4\n#    \u283f Container issuer-ui-1                 Started                                                                                                           0.5s\n#    \u283f Container issuer-api-ui-1             Started                                                                                                           0.5s\n#    \u283f Container issuer-notifications-1      Started                                                                                                           0.4s\n#    \u283f Container issuer-pending_publisher-1  Running  \n</code></pre> <p>Now navigate to http://localhost:3002 to see the UI API's frontend:</p> <p></p>"},{"location":"issuer/setup-issuer-ui/#using-the-ui-api","title":"Using the UI API","text":"<p>Make sure to set the HTTP authentication credentials in <code>.env-api</code> to the following:</p> <pre><code># ...\n\nISSUER_API_UI_AUTH_USER=user-api\nISSUER_API_UI_AUTH_PASSWORD=password-api\n</code></pre> <p>Then authenticate via the following form on http://localhost:3002:</p> <p></p> <p>This allows you to make a request via any of the endpoints using this frontend.</p> <p></p>"},{"location":"issuer/setup-issuer-ui/#optional-using-the-ui","title":"(Optional) Using the UI","text":"<p>This service is running on http://localhost:8088.</p> <p>Note</p> <p>If you are using Chrome, you might get the HTTP auth modal showing and disappearing quickly. To remedy this, use the following URL: http://user-api:password-api@localhost:8088/.</p> <p>File containing the basic auth credentials: <code>.env-ui</code></p> <pre><code># ...\n\nISSUER_UI_AUTH_USERNAME=user-ui\nISSUER_UI_AUTH_PASSWORD=password-ui\n</code></pre> <p></p> <p>Note</p> <p>If you want to run the UI app in development mode, i.e. with HMR enabled, please follow the steps in the Development (UI) section.</p>"},{"location":"issuer/setup-issuer-ui/#standalone-mode-guide","title":"Standalone Mode Guide","text":"<p>Running the app in standalone mode means you will need to install the binaries for the server to run natively. This is essential for production deployments.</p> <p>Make sure you have Postgres, Redis and Vault properly installed &amp; configured. Do not use <code>make up</code> since those will start the containers for non-production builds, see Docker Setup Guide.</p>"},{"location":"issuer/setup-issuer-ui/#standalone-mode-guide-requirements","title":"Standalone Mode Guide Requirements","text":"<ul> <li>Docker Engine 1.27</li> <li>Makefile toolchain</li> <li>Unix-based operating system (e.g. Debian, Arch, Mac OS X)</li> <li>Go 1.19</li> <li>Postgres</li> <li>Redis</li> <li>Hashicorp Vault</li> </ul>"},{"location":"issuer/setup-issuer-ui/#standalone-mode-setup","title":"Standalone Mode Setup","text":"<ol> <li>Copy <code>.env-api.sample</code> as <code>.env-api</code> and <code>.env-issuer.sample</code> as <code>.env-issuer</code>. Please see the configuration section for more details.</li> <li>Run <code>make build-local</code>. This will generate a binary for each of the following commands:<ul> <li><code>platform</code></li> <li><code>platform_ui</code></li> <li><code>migrate</code></li> <li><code>pending_publisher</code></li> <li><code>notifications</code></li> </ul> </li> <li>Run <code>make db/migrate</code>. This checks the database structure and applies any changes to the database schema.</li> <li>Run <code>./bin/platform</code> command to start the issuer.</li> <li>Run <code>./bin/pending_publisher</code>. This checks that publishing transactions to the blockchain works.</li> <li>Follow the steps for adding an Ethereum private key to the Vault.</li> <li>Follow the steps for creating an identity as your issuer DID.</li> <li>(Optional) To set up the UI with its own API, first copy <code>.env-ui.sample</code> as <code>.env-ui</code>. Please see the configuration section for more details.</li> </ol>"},{"location":"issuer/setup-issuer-ui/#configuration","title":"Configuration","text":""},{"location":"issuer/setup-issuer-ui/#getting-a-public-url","title":"Getting A Public URL","text":"<p>In order for the service to work, we'll need a public URL. An easy way to set this up is by using ngrok as a forwarding service that maps to a local port. After downloading and installing ngrok, run the follwing command and copy the Forwarding URL:</p> <pre><code># For issuer-api ISSUER_SERVER_URL env var (.env-issuer file)\n./ngrok http 3001; \n</code></pre> <pre><code># For issuer-api-ui ISSUER_API_UI_SERVER_URL env var (.env-api file)\n./ngrok http 3002; \n</code></pre> <p>Copy the Forwarding output value into the desired env var</p> <pre><code># FROM: /path/to/ngrok binary\n\n# Expected Output:\n# Add OAuth and webhook security to your ngrok (its free!): https://ngrok.com/free\n# \n# Session Status                online\n# Account                       YourAccountUsername (Plan: Free)\n# Update                        update available (version 3.2.1, Ctrl-U to update)\n# Version                       3.1.0\n# Region                        Europe (eu)\n# Latency                       -\n# Web Interface                 http://127.0.0.1:4040\n# Forwarding                    https://unique-forwading-address.eu.ngrok.io -&gt; http://localhost:3001\n# \n# Connections                   ttl     opn     rt1     rt5     p50     p90\n                              # 0       0       0.00    0.00    0.00    0.00\n</code></pre>"},{"location":"issuer/setup-issuer-ui/#development-ui","title":"Development (UI)","text":"<p>Completing the installation process yields the UI as a minified Javascript app. Any changes to the UI source code would necessitate a full re-build to apply them. In most development scenarios this is undesirable, so the UI app can also be run in development mode like any React application to enable hot module replacement (HMR).</p> <ol> <li>Make sure that the UI API is set up and running properly (default http://localhost:3002).</li> <li>Go to the <code>ui/</code> folder.</li> <li>Copy the <code>.env.sample</code> file as <code>.env</code></li> <li>All variables are required to be set, with the exception of <code>VITE_ISSUER_LOGO</code>. The following are the corresponding variables present in the parent folder's <code>.env-api</code>, which need to be the same. Only <code>VITE_ISSUER_NAME</code> can differ for the UI to function in development mode.<ul> <li><code>VITE_API_URL -&gt; ISSUER_API_UI_SERVER_URL</code></li> <li><code>VITE_API_USERNAME -&gt; ISSUER_API_UI_AUTH_USER</code></li> <li><code>VITE_API_PASSWORD -&gt; ISSUER_API_UI_AUTH_PASSWORD</code></li> <li><code>VITE_BLOCK_EXPLORER_URL -&gt; ISSUER_UI_BLOCK_EXPLORER_URL</code></li> <li><code>VITE_ISSUER_DID -&gt; ISSUER_API_UI_ISSUER_DID</code></li> <li><code>VITE_ISSUER_NAME -&gt; ISSUER_API_UI_ISSUER_NAME</code></li> <li><code>VITE_ISSUER_LOGO -&gt; ISSUER_API_UI_ISSUER_LOGO</code></li> </ul> </li> <li>Run <code>npm install</code></li> <li>Run <code>npm start</code></li> <li>The app will be running on http://localhost:5173.</li> </ol>"},{"location":"issuer/source-code/","title":"Source Code","text":""},{"location":"issuer/source-code/#core-library","title":"Core Library","text":"<ul> <li>Issuer Node</li> </ul>"},{"location":"issuer/source-code/#support-libraries","title":"Support Libraries","text":"<ul> <li>go Iden3 Core: Go implementation of iden3 core functionality  </li> <li>go Iden3 Crypto: Go implementation of important cryptographic elements including baby jubjub key, Keccak256, and poseidon </li> <li>go Merkle Tree SQL: Go implementation of Merkle tree based on the library of circuit templates</li> </ul>"},{"location":"issuer/on-chain-issuer/on-chain-overview/","title":"Overview","text":"<p>The On-chain Issuer is a way of issuing credentials by leveraging the full power of a smart contract. As it is commonly known, a smart contract is software that resides in a blockchain network, meaning that its code and data aren\u2019t necessarily stored in a server, but rather it is distributed in a decentralized manner. Therefore, an on-chain issuer could be considered a decentralized issuer, as all the underlying logic of the credentials is written on a smart contract with its inherent publicity. </p> <p>This issuance method then serves as an alternative to the Issuer Node, whose implementation depends on a dedicated setup and its own infrastructure. </p> <p>The fact that all this logic is present on the blockchain enables credential issuance for DAOs in a programmatic way. It can also be useful for entities like oracles and on-chain analytics companies since the contract code can be audited and verified. </p>"},{"location":"issuer/on-chain-issuer/on-chain-overview/#on-chain-issuance","title":"On-chain issuance","text":"<p>On-chain issuance is trustless or trust-minimized, depending on smart contract business logic. It reduces dependency on non-auditable decisions for issuing credentials. The properties of smart contracts make them good candidates to act as trusted attestation services since the attestation mechanism is transparent and auditable to everyone. This serves as an alternative to a number of centralized issuers for use cases when an Identity needs to issue credentials about themselves or their activity, which can be verified by the smart contract logic.</p> <p>In simple words, you can see everything happening, all the logic used to generate the credential is live on the blockchain and ready to be checked and verified.</p> <p>Info</p> <pre><code>An On-chain Issuer, in fact, is a special case of the On-chain Identity. You can find more information about it on the [Iden3 documentation](https://docs.iden3.io/getting-started/identity/onchain-identity/).\n</code></pre>"},{"location":"issuer/on-chain-issuer/on-chain-overview/#smart-contracts","title":"Smart contracts","text":"<p>Smart contracts generate and manage identities. They can also manage Merkle Trees on-chain.  Each issuer has its own identity contract. Each contract, which is linked to an identity, will have its own custom verification logic:  what they are issuing and to whom. </p> <p>There are still the possibilities of either using one smart contract with a set of different business logic for specific credentials or having one smart contract for each use case.</p> <p></p> <p>Some of the methods that can be performed by the SC:</p> <ul> <li>Add claim / claim hash</li> <li>Revoke claim</li> <li>Build credential</li> </ul> <p>There is a set of features to be implemented in Solidity and provided to developers, protocols or dApps. You would have to integrate it as a library or as a standalone contract, thus controlling the identity of your users.</p>"},{"location":"issuer/on-chain-issuer/on-chain-overview/#possible-use-cases","title":"Possible use cases","text":"<p>There are many possible use cases enabled by an on-chain issuer. One of them is the possibility of the ID holder using an application to check their own data validity and send a zero-knowledge proof to an on-chain issuer, which will be responsible for generating a verifiable credential. </p> <p>Another way of using the on-chain issuer is gathering available data on-chain for a particular identity and producing a verifiable credential from it. In fact, on-chain issuers enable two categories of credentials: public and private ones. </p>"},{"location":"issuer/on-chain-issuer/on-chain-overview/#public-use-cases","title":"Public use cases","text":"<p>A public credential will leverage all the available data of a particular address and aggregate it to generate a claim, such as a reputation score, linked to an identity - there is no personal information revealed and it can be made available on-chain.</p> <p>In this case, the value is in the aggregation of large amounts of information into ready-to-use credentials that are linked to an identity. This way, the identity holder could prove his assets without disclosing the Ethereum accounts that control these assets.</p> <p>Some interesting examples of public use cases would be: </p> <ul> <li>An oracle that summarizes the on-chain activity of one account could issue a credential to an identity holder that proves control of that address. Then, the identity holder could present a zero-knowledge proof of that credential to operate on DAOs, DEFI, etc.</li> <li>Signing a transaction to a smart contract could trigger the creation of a credential attesting to the ownership of a crypto address by a DID holder.</li> </ul>"},{"location":"issuer/on-chain-issuer/on-chain-overview/#private-use-cases","title":"Private use cases","text":"<p>On the other hand, private credentials usually stem from privately-held data that are used for self-attestation, meaning that the ID holder is able to create a credential himself with his data and share zero-knowledge proofs of its validity.</p> <p>When the information used to generate the credential contains personal data that shouldn\u2019t be on-chain, the zk-circuit is used to verify that the credentials were built correctly. In this case, the credential is generated off-chain by the end user in a way that it includes some cryptographic proofs of validity: </p> <p>After generating the credential and using a contract-specific circuit, the application that generated the credential could send a zero-knowledge proof of \u201cValidity of Credential\u201d to the on-chain issuer smart contract. Then, what the Smart Contract would verify is that there is a Verifiable Credential that was built following a certain process (that includes the cryptographical proof of validity, such as government public keys).</p> <p>In this scenario, the value is in allowing end users to leverage existing cryptographic proofs of different types that they have available (government keys, JWT tokens in Web2 accounts etc) to self-issue credentials that they can add to their identities.</p> <p>Some interesting examples of private use cases would be: </p> <ul> <li>User performs a self-attestation of their identity backed by the government public signature. Circuits running privately on a user's mobile phone could verify the input of an NFC chip, build credential and then send the transaction to a smart contract, which will be able to verify proof and issue (by adding its hash to claims merkle tree) a credential from it.</li> <li>Using JWT claims from Web2 applications through a browser extension - i.e. creating a credential with a date of birth and address from a company store.</li> </ul>"},{"location":"issuer/on-chain-issuer/on-chain-tutorial/","title":"Tutorial","text":"<p>This guide presents an example of how to use the on-chain issuer. We created a small application, where we communicate with Metamask to retrieve the user's balance and a claim about this balance is generated via the on-chain issuer.</p> <p>There are three main components in this application:</p> <ol> <li>On-chain issuer (demo|contract)</li> <li>Server for user authorization</li> <li>Front-end component for communication with Metamask</li> </ol> <p>Warning</p> <p>Currently, the state contract on the mainnet does not support onchain issuers. Please, use the Mumbai network instead.</p>"},{"location":"issuer/on-chain-issuer/on-chain-tutorial/#requirements","title":"Requirements:","text":"<ol> <li>Node js =&gt; 18.x</li> <li>Go =&gt; 1.20.x</li> <li>npm =&gt; 9.x.x</li> <li>docker =&gt; 20.x</li> <li>Polygon ID wallet app</li> </ol>"},{"location":"issuer/on-chain-issuer/on-chain-tutorial/#how-to-run-the-on-chain-issuer","title":"How to run the On-chain Issuer","text":"<ol> <li> <p>Clone this repository:     </p><pre><code>git clone https://github.com/0xPolygonID/onchain-issuer-integration-demo\n</code></pre> <p>All the variables which need to be altered are in the <code>run.sh</code> file:</p> <pre><code>ONCHAIN_ISSUER_CONTRACT_ADDRESS=&lt;ONCHAIN_ISSUER_CONTRACT_ADDRESS&gt;\nURL_MUMBAI_NODE=&lt;URL_TO_POLYGON_MUMBAI_NODE&gt;\nURL_POLYGON_NODE=&lt;URL_TO_POLYGON_MAINNET_NODE&gt;\nONCHAIN_CONTRACT_OWNER=&lt;PRIVATE_KEY_IS_USED_FOR_DEPLOY_ONCHAIN_ISSUER_CONTRACT&gt;\nMUMBAI_CONTRACT_STATE_ADDRESS=0x134B1BE34911E39A8397ec6289782989729807a4\nMAIN_CONTRACT_STATE_ADDRESS=0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D\nONCHAIN_ISSUER_CONTRACT_BLOCKCHAIN=&lt;BLOCKCHAIN_OF_ISSUER_CONTRACT&gt;\nONCHAIN_ISSUER_CONTRACT_NETWORK=&lt;BLOCKCHAIN_OF_WITH_ISSUER_CONTRACT&gt;\n</code></pre> </li> <li> <p>Deploy an on-chain issuer contract. You can use this sample here or create your own smart contract with custom logic.</p> <p>Use the following State Contract addresses:</p> <ul> <li>For mumbai network: <code>0x134B1BE34911E39A8397ec6289782989729807a4</code></li> <li>For mainnet network: <code>0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D</code></li> </ul> <p>Note</p> <p>You can find more information on how to deploy a smart contract using Hardhat in this readme.</p> </li> <li> <p>Fill in the configuration files with the actual values.</p> <ul> <li><code>ONCHAIN_ISSUER_CONTRACT_ADDRESS</code> should be retrieved from the smart contract deployment.</li> <li><code>URL_MUMBAI_NODE</code> is easily acquired with any Infrastructure provider, such as Alchemy, Infura etc.</li> <li><code>URL_POLYGON_NODE</code>is easily acquired with any Infrastructure provider, such as Alchemy, Infura etc.</li> <li><code>ONCHAIN_CONTRACT_OWNER</code> is where a private key should be set to deploy the contract.</li> <li><code>MUMBAI_CONTRACT_STATE_ADDRESS</code> represents the already deployed Mumbai State Contract and shouldn't be changed.</li> <li><code>MAIN_CONTRACT_STATE_ADDRESS</code> represents the already deployed Mainnet State Contract and shouldn't be changed.</li> <li><code>ONCHAIN_ISSUER_CONTRACT_BLOCKCHAIN</code> sets the blockchain where the on-chain issuer contract was deployed as <code>eth</code> or <code>polygon</code>.</li> <li><code>ONCHAIN_ISSUER_CONTRACT_NETWORK</code> sets the blockchain network where the on-chain issuer contract was deployed, as <code>main</code>, <code>mumbai</code> or <code>goerli</code>.</li> </ul> </li> <li> <p>Run the run.sh script:     </p><pre><code>./run.sh\n</code></pre> </li> </ol> <p>Note</p> <pre><code>Don't forget to download and install the Polygon ID wallet app before you go the next steps.\n\n- For Android: &lt;a href=\"https://play.google.com/store/apps/details?id=com.polygonid.wallet\" target=\"_blank\"&gt;Polygon ID on Google Play&lt;/a&gt;\n- For iOS: &lt;a href=\"https://apps.apple.com/us/app/polygon-id/id1629870183\" target=\"_blank\"&gt;Polygon ID on the App Store&lt;/a&gt;\n</code></pre>"},{"location":"issuer/on-chain-issuer/on-chain-tutorial/#issue-and-fetch-credential","title":"Issue and fetch credential","text":"<ol> <li> <p>Open <code>http://localhost:3000</code> in your web browser and click on Sign Up.</p> <p></p> </li> <li> <p>Scan the QR code with your Polygon ID wallet app and follow the instructions on the application. </p> <p></p> </li> <li> <p>You will see your DID and now you can connect to MetaMask. Follow the flow on the MetaMask app.</p> <p></p> </li> <li> <p>The On-chain issuer application will now display your account. Now share your account balance with the application.</p> <p></p> </li> <li> <p>The account balance will be shown in gwei together with some other information about the claim.</p> <p></p> </li> <li> <p>Clicking on Get Claim will finally lead to the QR Code used to fetch the credential with MTP proof. Here we are making a request to the on-chain issuer node. This node then saves this claim in a contract address. Scan it with the Polygon ID wallet and the credential should be added to the mobile app. </p> <p></p> </li> </ol> <p>Here is the credential on the mobile app:</p>"},{"location":"issuer/on-chain-issuer/on-chain-tutorial/#how-to-verify-the-balance-claim","title":"How to verify the balance claim","text":"<ol> <li>Go to the Verifier website.</li> <li> <p>Choose <code>custom</code> from the dropdown menu.</p> <p></p> </li> <li> <p>Fill up the form.</p> <ul> <li>Circuit Id: Credential Atomic Query MTP;</li> <li>URL: https://gist.githubusercontent.com/ilya-korotya/b06baa37453ed9aedfcb79100b84d51f/raw/balance-v1.jsonld</li> <li>Type: BalanceCredential</li> <li>Field: balance</li> <li>Operator: all the operators work for the claim. More information here</li> <li>Value: set the value that you want to verify.</li> </ul> <p>Here is an example:</p> <p></p> </li> <li> <p>Press submit.</p> </li> <li> <p>Use the mobile application to scan the QR code and complete the verification process. The verifier will check revocation status and additional information and the proof will be sent to the verifier. The Verifier website will present then the proof information.</p> <p></p> </li> </ol>"},{"location":"issuer/platform-api/introduction/","title":"Polygon ID Platform API","text":""},{"location":"issuer/platform-api/introduction/#polygon-id-platform-api","title":"Polygon ID Platform API","text":"<p>The Polygon ID Platform API exposes all the functionalities necessary to run an issuer.</p> <p>To become familiar with the role of the issuer, it is advised to use  Polygon Platform UI as a testing sandbox. All the functionalities included in the UI are exposed here as independent APIs.</p> <p>The core functionality of the Platform API are:</p> <ul> <li>Onboarding Orgs to register and manage an Organization Account</li> <li>Issuer to set up an Issuer</li> <li>Schemas to create and manage Claim Schemas</li> <li>Claim Offers to issue Claims based on existing schemas and offer them to your users via a QR code</li> </ul> <p></p> <p>Disclaimer: Polygon ID APIs will be subject to improvments and changes in the upcoming months.</p> <p>The APIs categories are sequential steps: you cannot start creating Schemas and issuing claims without having an Issuer. Similarly, you need an Organization account to create an Issuer on Polygon ID Platform. To start playing around with the Platform APIs, complete the Issuer Integration Full Flow Tutorial</p>"},{"location":"issuer/platform-api/introduction/#core-resources","title":"Core resources:","text":"<ul> <li>OpenAPI specification for API Methods</li> <li>Postman collection for API Methods</li> </ul>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/","title":"Getting Started - Full Flow Tutorial","text":""},{"location":"issuer/platform-api/flow-tutorial/happy-path/#getting-started-full-flow-tutorial","title":"Getting Started - Full Flow Tutorial","text":"<p>This tutorial will walk you through a Full Flow Issuer Integration using Polygon ID APIs. </p> <p>The main role of the issuer is to Issue Claims. In this tutorial, you'll impersonate a DAO that wants to issue claims for its contributors. In particular, the Claim itself will contain two type of information: the \"Season\" in which the contributor joined the DAO and its role inside the DAO. By the end of the tutorial, every contributor will be able to use their Polygon ID App to scan a QR code and receive a claim inside their wallet attesting their information as DAO contributor.</p> <p>The tutorial is made of 9 steps: </p> <ol> <li>Create an Organization Account</li> <li>Sign-in to an Organization Account</li> <li>Activate your Organization Account</li> <li>Create an Issuer</li> <li>Refresh the Token</li> <li>Create a Schema</li> <li>Create Claim Offer</li> <li>Create QR Code of Claim Offer</li> <li>Get a QR Code of Offer</li> </ol>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#initial-set-up","title":"Initial Set Up","text":"<p>We already created a Postman Collection to make your life easier. To start, access the Polygon ID Postman Collection. From the left-hand side menu click on \"Collections\" and then \"Create a Fork\". This will fork the Collection inside your private workspace. Once you moved into your private workspace there are different ways in which you can start testing the endpoints:</p> <ul> <li>Using the built-in Postman Platform allows you to make API calls directly from your browser.</li> </ul> <p> </p> <ul> <li>Using auto-generated code snippets from Postman in Axios, cURL, Python, HTTP and many more.</li> </ul> <p> </p> <p>In this tutorial we are using cURL code snippet to make API calls. Nevertheless any method will generate the same output.</p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#1-create-an-organization-account","title":"1. Create An Organization Account","text":"<p>The first mandatory thing is to create an account for your Organization passing in an <code>email</code> and <code>password</code>. This action is performed via the Create Organization Endpoint. The password and the email must be passed inside the Body Request. This action has to be executed only once. </p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/account-management' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"email\": \"mypersonalemail2@test.com\",\n    \"password\": \"Some123456789123123Pwd!\"\n}'\n</code></pre> <p>Remember to modify the <code>email</code> otherwise you'll get an error message as this email is already associated to an Organization Account</p> <p>The response contains the details of the newly created Organization Account. The <code>verified</code> key is equal to <code>false</code>. It means that the account still requires to be activated. This action will be performed in step 3](#3-activate-your-organization-account) of this tutorial.</p> <pre><code>{\n    \"createdAt\": \"2022-11-28T10:34:01.825579Z\",\n    \"email\": \"mypersonalemail2@test.com\",\n    \"id\": \"d926a8c4-6545-4e00-aa26-53b7055d10cd\",\n    \"modifiedAt\": \"2022-11-28T10:34:01.825579Z\",\n    \"type\": \"OWNER\",\n    \"verified\": false\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#2-sign-in-to-an-organization-account","title":"2. Sign-in to an Organization Account","text":"<p>The credential used to create your Organization Account are then used to Sign-in into your Organization Account. This action is performed via the Sign-in Endpoint. The <code>email</code> and <code>password</code> used previously to create the Organization Account need to be passed inside the Body Request.  This action needs to be executed in order to perform every further action within Polygon ID APIs.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/sign-in' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"email\": \"mypersonalemail2@test.com\",\n    \"password\": \"Some123456789123123Pwd!\"\n}'\n</code></pre> <p>The Response Body contains a JWT <code>Bearer Token</code>. This token will be used in order to authenticate yourself as a Signed-in Organization Account and get the authorization to use the API Endpoints.</p> <pre><code>{\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxMTYsImp0aSI6IjFmYTQ2NDAwLWU5YTgtNGExYS05OTEwLWQ3MjA3MDM2OTA1NCIsImlhdCI6MTY2OTYzMTcxNiwibmJmIjoxNjY5NjMxNzE2LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOmZhbHNlLCJvcmdhbml6YXRpb24iOm51bGwsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.3h5_EZjCT2vzX3xHodJ6XhZRdKoZRxPH0bobEUHUDIQ\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#3-activate-your-organizations-account","title":"3. Activate your Organization's Account","text":"<p>Now it is mandatory to Activate your Organization Account. This action is performed via the Activate Endpoint. The <code>Bearer Token</code> generated from the last request needs to be passed inside the Authorization Request Header. This action has to be executed only once.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/account-management/activate' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxMTYsImp0aSI6IjFmYTQ2NDAwLWU5YTgtNGExYS05OTEwLWQ3MjA3MDM2OTA1NCIsImlhdCI6MTY2OTYzMTcxNiwibmJmIjoxNjY5NjMxNzE2LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOmZhbHNlLCJvcmdhbml6YXRpb24iOm51bGwsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.3h5_EZjCT2vzX3xHodJ6XhZRdKoZRxPH0bobEUHUDIQ' \\\n--data-raw ''\n</code></pre> <p>The Response Body contains an updated JWT <code>Bearer Token</code> that attests that the Organization Account has been activated.</p> <pre><code>{\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxNzUsImp0aSI6IjJmZTE1NmYzLWM0ZTUtNGZjNi05NDYzLWNlZmIzN2EzMWE2MCIsImlhdCI6MTY2OTYzMTc3NSwibmJmIjoxNjY5NjMxNzc1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6bnVsbCwicm9sZSI6Ik9XTkVSIiwiZW1haWwiOiJteXBlcnNvbmFsZW1haWwyQHRlc3QuY29tIn19.daxoACgJFW9E5rWc2E2bUCNl6boIsHe-bE6UmUrgC04\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#4-create-an-issuer","title":"4. Create an Issuer","text":"<p>Before starting Issuing Claims, it is necessary to set up an Issuer. To set up an issuer it is required to have an Organization Account activated and signed-in. Each Organization Account can only manage a single Issuer. This action is performed via the Create Issuer Endpoint. </p> <p>This Endpoint requires to pass various details about the Issuer such as its <code>displayName</code> (required) and other optional parameters such as <code>legalName</code>, <code>logo</code> and <code>region</code>. The displayName and the logo are public values that will be visible to the user, while legalName and region will not be shown to the outside. The logo data file needs to be filled with an image encoded in base64 format. Lastly, the <code>Bearer Token</code> generated from the last request needs to be passed inside the Authorization Request Header. This action has to be executed only once.</p> <p>Today an Organization can only set up one Issuer. Soon more actions will be enabled for an Organization such as setting up multiple Issuers or a Verifier.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/issuers' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxNzUsImp0aSI6IjJmZTE1NmYzLWM0ZTUtNGZjNi05NDYzLWNlZmIzN2EzMWE2MCIsImlhdCI6MTY2OTYzMTc3NSwibmJmIjoxNjY5NjMxNzc1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6bnVsbCwicm9sZSI6Ik9XTkVSIiwiZW1haWwiOiJteXBlcnNvbmFsZW1haWwyQHRlc3QuY29tIn19.daxoACgJFW9E5rWc2E2bUCNl6boIsHe-bE6UmUrgC04' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"displayName\" : \"IssuerTest1234\",\n    \"legalName\" : \"IssuerLegalOrg1\",\n    \"logo\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=\",\n    \"region\" : \"USA\"\n}'\n</code></pre> <p>The Response Body contains the details of the newly created Issuer. Later on, you'll be referring to this Issuer by its <code>id</code>.</p> <pre><code>{\n    \"createdAt\": \"2022-11-28T10:38:10.639675Z\",\n    \"did\": \"114uHUxT37dnr4JJiAcsE9mNK2PKWm9umrHNuM8S35\",\n    \"displayName\": \"IssuerTest1234\",\n    \"id\": \"40b4018f-83f1-4db5-a878-c2d002ef6532\",\n    \"legalName\": \"IssuerLegalOrg1\",\n    \"logo\": \"https://s3.eu-west-1.amazonaws.com/polygonid-assets/logo/12fa8d61-0b32-4827-a6ea-9f31acdb3f1b\",\n    \"modifiedAt\": \"2022-11-28T10:38:10.639675Z\",\n    \"ownerEmail\": \"mypersonalemail2@test.com\",\n    \"region\": \"USA\",\n    \"slug\": \"issuertest1234\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#5-refresh-the-token","title":"5. Refresh the Token","text":"<p>The next step is to Refresh the Bearer Token in order to add to it the updated information regarding the newly created Issuer such as its <code>id</code>. This action is performed via the Refresh Token Endpoint. The last valid <code>Bearer Token</code> (the one generated in step 3) needs to be passed inside the Authorization Request Header. </p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/account-management/refresh-token' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxNzUsImp0aSI6IjJmZTE1NmYzLWM0ZTUtNGZjNi05NDYzLWNlZmIzN2EzMWE2MCIsImlhdCI6MTY2OTYzMTc3NSwibmJmIjoxNjY5NjMxNzc1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6bnVsbCwicm9sZSI6Ik9XTkVSIiwiZW1haWwiOiJteXBlcnNvbmFsZW1haWwyQHRlc3QuY29tIn19.daxoACgJFW9E5rWc2E2bUCNl6boIsHe-bE6UmUrgC04'\n</code></pre> <p>The Response Body contains a refreshed JWT <code>Bearer Token</code> with the updated details regarding the Issuer added to the Organization Account.</p> <pre><code>{\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgzMzUsImp0aSI6IjcyZDM4NzVhLTI4MTQtNDY0YS04NzIxLWExYmY3NDY2M2ZiYiIsImlhdCI6MTY2OTYzMTkzNSwibmJmIjoxNjY5NjMxOTM1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6IjQwYjQwMThmLTgzZjEtNGRiNS1hODc4LWMyZDAwMmVmNjUzMiIsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.BjwZuIiI1ekSbrlAz_eCFLmWoEiH-PgUDgf-3g5TV8E\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#6-create-a-schema","title":"6. Create a Schema","text":"<p>Before issuing the actual Claims, it is necessary to define a Schema. In simple terms, a Schema defines the structure of the Claim, while a Claim is generated by starting from the structure defined by a Schema and filling it up with actual data.  </p> <p></p> <p>In this case, the Schema, named <code>daoContributor2</code> will define that the Claim must contain two different attributes:</p> <ul> <li>An attribute defined <code>CoreContributor</code> that defines whether the user is a core contributor for the DAO or not.</li> <li>An attributed define <code>SinceSeason</code> that contains the number of the DAO Season in which the contributor Joined. </li> </ul> <p>This action is performed via the Create Schema Endpoint. It requires passing a set of values inside the Body Request: </p> <ul> <li>The name of the <code>schema</code>, which in this case is daoContributor2</li> <li>The <code>mandatoryExpiration</code> of the schema, which in this case we set to false</li> <li>An array of <code>attributes</code>, which contains the details of the attributes defined previously, such as their <code>name</code>, <code>description</code> and <code>type</code>. The attribute <code>CoreContributor</code> is of type boolean while <code>SinceSeason</code> is of type number</li> </ul> <p>The refreshed <code>Bearer Token</code> from the last step needs to be passed inside the Authorization Request Header. Furthermore, it requires to pass the issuer <code>id</code> as Path Parameter. An Issuer can create as many schemas he/she wants!</p> <p>you can retreive the Issuer ID from the response obtained in Step 4 or by parsing the latest JWT token here and checking the <code>organization</code> field.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/issuers/40b4018f-83f1-4db5-a878-c2d002ef6532/schemas' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgzMzUsImp0aSI6IjcyZDM4NzVhLTI4MTQtNDY0YS04NzIxLWExYmY3NDY2M2ZiYiIsImlhdCI6MTY2OTYzMTkzNSwibmJmIjoxNjY5NjMxOTM1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6IjQwYjQwMThmLTgzZjEtNGRiNS1hODc4LWMyZDAwMmVmNjUzMiIsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.BjwZuIiI1ekSbrlAz_eCFLmWoEiH-PgUDgf-3g5TV8E' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"schema\": \"daoContributor2\",\n  \"mandatoryExpiration\": false,\n  \"attributes\": [\n    {\n      \"name\": \"CoreContributor\",\n      \"type\": \"boolean\",\n      \"description\": \"Role as contributor in the DAO\"\n    },\n    {\n    \"name\": \"SinceSeason\",\n      \"type\": \"number\",\n      \"description\": \"Number of season in which the contributor joined the DAO\"\n    }\n  ]\n}'\n</code></pre> <p>The response contains the details of the newly created schema. Later on, you'll be referring to this Schema by its <code>id</code></p> <pre><code>{\n    \"active\": true,\n    \"attributes\": [\n        {\n            \"description\": \"Role as contributor in the DAO\",\n            \"name\": \"CoreContributor\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"description\": \"Number of season in which the contributor joined the DAO\",\n            \"name\": \"SinceSeason\",\n            \"type\": \"number\"\n        }\n    ],\n    \"createdAt\": \"2022-11-28T11:35:17.066679Z\",\n    \"id\": \"88a9b947-31b9-443e-8473-4344949815b4\",\n    \"issuerID\": \"40b4018f-83f1-4db5-a878-c2d002ef6532\",\n    \"mandatoryExpiration\": false,\n    \"modifiedAt\": \"2022-11-28T11:35:17.066679Z\",\n    \"schema\": \"daoContributor2\",\n    \"schemaHash\": \"f877157e9a88239180178212736c5e7e\",\n    \"schemaURL\": \"https://s3.eu-west-1.amazonaws.com/polygonid-schemas/8589aba5-e973-4dab-9cac-0955731f4d27.json-ld\",\n    \"technicalName\": \"\",\n    \"version\": \"1.1\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#7-create-claim-offer","title":"7. Create Claim Offer","text":"<p>Now it's time to actually create a Claim. We already have a schema, now we just need to fill it up with data of a user. We do that by assigning values to the attributes defined in the Schema Creation.</p> <p>Let's consider the case of Issuing a Claim to a user that has been part of a DAO since season 4 as a Core Contributor. This action is performed via the Create Offer Endpoint. It requires passing an array of <code>attributes</code> inside the Body Request. Each attribute object contains the <code>attributeKey</code>, namely the name of the Schema Attribute it refers to, and the <code>attributeValue</code>, namely the value to be assigned to that specific attributeKey. </p> <p>Setting up the logic to verify the role of a Contributor inside the DAO and the Season he/she joined it are responsability of the implementer.</p> <p>A valid <code>Bearer Token</code> needs to be passed inside the Authorization Request Header. Furthermore, it requires to pass the Issuer <code>id</code> and the Schema <code>id</code> as Path Parameters. You can find the Schema id inside the Response Body in step 6.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/issuers/40b4018f-83f1-4db5-a878-c2d002ef6532/schemas/88a9b947-31b9-443e-8473-4344949815b4/offers' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgzMzUsImp0aSI6IjcyZDM4NzVhLTI4MTQtNDY0YS04NzIxLWExYmY3NDY2M2ZiYiIsImlhdCI6MTY2OTYzMTkzNSwibmJmIjoxNjY5NjMxOTM1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6IjQwYjQwMThmLTgzZjEtNGRiNS1hODc4LWMyZDAwMmVmNjUzMiIsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.BjwZuIiI1ekSbrlAz_eCFLmWoEiH-PgUDgf-3g5TV8E' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"attributes\": [\n        {\n            \"attributeKey\": \"CoreContributor\", \n            \"attributeValue\": 1\n        },\n        {\n            \"attributeKey\": \"SinceSeason\", \n            \"attributeValue\": 4\n        }\n    ]\n}'\n</code></pre> <p>You can only pass numeric values as <code>attributeValue</code>. That's why we cannot define the attributeValue for the key CoreContributor as true. Instead, we assign 1 which corresponds to true. If it was false, the corresponsing value would have been 0</p> <p>The response contains the details of the newly created Claim. In particular, you can see that the DAO contributor data are defined inside the <code>attributeValues</code> field. Later on, you'll be referring to this Claim by its <code>id</code></p> <pre><code>{\n    \"attributeValues\": [\n        {\n            \"attributeKey\": \"CoreContributor\",\n            \"attributeValue\": 1\n        },\n        {\n            \"attributeKey\": \"SinceSeason\",\n            \"attributeValue\": 4\n        }\n    ],\n    \"attributes\": [\n        {\n            \"description\": \"Role as contributor in the DAO\",\n            \"name\": \"CoreContributor\",\n            \"type\": \"boolean\"\n        },\n        {\n            \"description\": \"Number of season in which the contributor joined the DAO\",\n            \"name\": \"SinceSeason\",\n            \"type\": \"number\"\n        }\n    ],\n    \"createdAt\": \"2022-11-28T11:39:03.845512Z\",\n    \"expiresAt\": null,\n    \"id\": \"cc3570ed-2bae-4b4c-b2f9-11f636a30151\",\n    \"limitedClaims\": null,\n    \"schemaTemplateID\": \"88a9b947-31b9-443e-8473-4344949815b4\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#8-create-qr-code-of-claim-offer","title":"8. Create QR Code of Claim Offer","text":"<p>The claim has now been created. Now we need to share it with the designated DAO Contributor. This action is performed via the Create QRCode of Offer Endpoint. This Endpoint only requires to pass the Claim <code>id</code> as Path Parameter.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/offers-qrcode/cc3570ed-2bae-4b4c-b2f9-11f636a30151'\n</code></pre> <p>The response contains the details of the claim Offer, identified via its <code>id</code>. In particular, it generates a <code>sessionID</code> for the user to authenticate and fetch the claim inside their wallet. With this endpoint, a <code>qrcode</code> gets created and associated with that user. This QR Code has to be displayed to the specific DAO Contributor that is entitled to receive the claim. The sessionID expires in 2 minutes after which the qrcode will no longer be scannable.</p> <pre><code>{\n    \"issuer\": {\n        \"displayName\": \"IssuerTest1234\",\n        \"logo\": \"https://s3.eu-west-1.amazonaws.com/polygonid-assets/logo/12fa8d61-0b32-4827-a6ea-9f31acdb3f1b\"\n    },\n    \"offerDetails\": {\n        \"attributeValues\": [\n            {\n                \"attributeKey\": \"CoreContributor\",\n                \"attributeValue\": 1\n            },\n            {\n                \"attributeKey\": \"SinceSeason\",\n                \"attributeValue\": 4\n            }\n        ],\n        \"attributes\": [\n            {\n                \"description\": \"Role as contributor in the DAO\",\n                \"name\": \"CoreContributor\",\n                \"type\": \"boolean\"\n            },\n            {\n                \"description\": \"Number of season in which the contributor joined the DAO\",\n                \"name\": \"SinceSeason\",\n                \"type\": \"number\"\n            }\n        ],\n        \"createdAt\": \"2022-11-28T11:39:03.845512Z\",\n        \"expiresAt\": null,\n        \"id\": \"cc3570ed-2bae-4b4c-b2f9-11f636a30151\",\n        \"limitedClaims\": null,\n        \"schemaTemplateID\": \"88a9b947-31b9-443e-8473-4344949815b4\",\n        \"schemaTemplateName\": \"daoContributor2\"\n    },\n    \"qrcode\": {\n        \"body\": {\n            \"callbackUrl\": \"https://api-staging.polygonid.com/v1/offers-qrcode/cc3570ed-2bae-4b4c-b2f9-11f636a30151/callback?sessionID=9d0a2cb5-9020-4e7e-af54-c4c067fcd391\",\n            \"reason\": \"auth login\",\n            \"scope\": []\n        },\n        \"from\": \"114uHUxT37dnr4JJiAcsE9mNK2PKWm9umrHNuM8S35\",\n        \"id\": \"0cf483fa-0b3d-46f3-8e47-7c2dafe9da05\",\n        \"thid\": \"0cf483fa-0b3d-46f3-8e47-7c2dafe9da05\",\n        \"typ\": \"application/iden3comm-plain-json\",\n        \"type\": \"https://iden3-communication.io/authorization/1.0/request\"\n    },\n    \"sessionID\": \"9d0a2cb5-9020-4e7e-af54-c4c067fcd391\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#9-fetch-the-claim-inside-users-wallet","title":"9. Fetch the claim inside User's wallet","text":"<p>To fetch a claim inside their wallet, the user either needs to scan a QR code or use deeplinking. After scanning the QR Code or clicking the deeplink, the user will be required to authenticate. On successful authentication, they will receive a notification to add the claim inside their wallet.</p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#9a-via-qr-code","title":"9.a. Via QR Code","text":"<p>To Download the QRCode previously created as PNG file we use the Download a QRCode of Offer Endpoint. For it, we need to pass the claim offer <code>id</code>, generated in step 7, as Path Parameter and the <code>sessionID</code>, generated from the previous step, as Query Parameter.</p> <pre><code>curl --location --request GET 'https://api-staging.polygonid.com/v1/offers-qrcode/cc3570ed-2bae-4b4c-b2f9-11f636a30151/download?sessionID=9d0a2cb5-9020-4e7e-af54-c4c067fcd391'\n</code></pre> <p>the --output flag is necessary to tell where to save the output file</p> <p></p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#9b-via-deep-linking","title":"9.b. Via Deep Linking","text":"<p>The same Claim Offer can also be delivered to users via Deep Linking. One way to utilize deep linking is by passing a base64 encoded message as the value of the i_m query parameter. The related deep link would be <code>iden3comm://?i_m={{base64EncodedRequestHere}}</code>. For example, in this specific case the deep link would be <code>iden3comm://?i_m=ewogICAgICAgICJib2R5IjogewogICAgICAgICAgICAiY2FsbGJhY2tVcmwiOiAiaHR0cHM6Ly9hcGktc3RhZ2luZy5wb2x5Z29uaWQuY29tL3YxL29mZmVycy1xcmNvZGUvY2MzNTcwZWQtMmJhZS00YjRjLWIyZjktMTFmNjM2YTMwMTUxL2NhbGxiYWNrP3Nlc3Npb25JRD05ZDBhMmNiNS05MDIwLTRlN2UtYWY1NC1jNGMwNjdmY2QzOTEiLAogICAgICAgICAgICAicmVhc29uIjogImF1dGggbG9naW4iLAogICAgICAgICAgICAic2NvcGUiOiBbXQogICAgICAgIH0sCiAgICAgICAgImZyb20iOiAiMTE0dUhVeFQzN2RucjRKSmlBY3NFOW1OSzJQS1dtOXVtckhOdU04UzM1IiwKICAgICAgICAiaWQiOiAiMGNmNDgzZmEtMGIzZC00NmYzLThlNDctN2MyZGFmZTlkYTA1IiwKICAgICAgICAidGhpZCI6ICIwY2Y0ODNmYS0wYjNkLTQ2ZjMtOGU0Ny03YzJkYWZlOWRhMDUiLAogICAgICAgICJ0eXAiOiAiYXBwbGljYXRpb24vaWRlbjNjb21tLXBsYWluLWpzb24iLAogICAgICAgICJ0eXBlIjogImh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXF1ZXN0IgogICAgfQ==</code> For instance, if you have a specific message that you want to deliver as part of the deep link, you can encode it in base64 format and include it using the <code>i_m</code> parameter. This method is particularly useful when the message is relatively small and can be included directly in the link.</p> <p>In situations where the message content is too large to be included directly in the deep link, there is also support of passing an encoded link. To do so, you may want to utilize a URL shortening service to create a more compact and user-friendly link. URL shortening services help convert long URLs into shorter, more manageable links that are easier to share and use. With this approach, the deep link will include the <code>request_uri</code> query parameter, which will contain a URL-encoded link. The deep link structure is as follows: <code>iden3comm://?request_uri=urlEncodedLinkHere</code>. Some examples of encoded link: <code>iden3comm://?request_uri=https%3A%2F%2Fissuer-demo.polygonid.me%2Fapi%2Fqr-store%3Fid%3Df780a169-8959-4380-9461-f7200e2ed3f4</code> By using this method, you can include a link that points to the location where the message can be fetched via an HTTP GET request. This allows you to deliver more substantial messages without encountering issues related to the size constraints of the deep link itself.</p> <p>In summary, our platform's deep linking capabilities provide two flexible methods for delivering Credential Offers. Whether you choose to pass a base64 encoded message or an encoded link, you can ensure that users have a seamless and efficient experience when interacting with the content you provide.</p> <p>Polygon ID wallet</p> <p>Polygon ID wallet will support handling of <code>request_uri</code> in the next release, while your client can already implement this specification.</p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#optional-10-get-qrcode-of-offer","title":"(OPTIONAL) 10. Get QRCode of Offer","text":"<p>The notification will only show up if the user has turned on the notifications for Polygon ID App. If that's not the case, the user will need to scan a second QR Code to fetch the claim inside their wallet. This action is performed via the Get QRCode of Offer.</p>"},{"location":"issuer/platform-api/issuer/apis/","title":"Issuer","text":""},{"location":"issuer/platform-api/issuer/apis/#issuer","title":"Issuer","text":"<p>The Issuer endpoints represent all the actions needed to manage an Issuer, such as Creating, Updating or Deleting an Issuer. Each Organization Account can only manage a single Issuer. </p>"},{"location":"issuer/platform-api/issuer/apis/#create-issuer","title":"Create Issuer","text":"<p>Function: Endpoint to create a new Issuer for an Organization Account. </p> <p>How it works: It requires passing the name of the Issuer <code>displayName</code> as required Request Body parameters. Other non-required Request Body parameters are the <code>logo</code>, the <code>legalName</code> and the <code>region</code> of your Issuer. This information will represent your Polygon ID Issuer profile. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains a set of details related to the newly created Issuer such as its <code>id</code>. </p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/issuer/apis/#get-issuer","title":"Get Issuer","text":"<p>Function: Endpoint to fetch key information about an Issuer.</p> <p>How it works: It requires passing the Issuer <code>id</code> as Path Parameter. This endpoint can be used to fetch information about any issuer existing on Polygon ID. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of details related to the requested Issuer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/issuer/apis/#update-issuer","title":"Update Issuer","text":"<p>Function: Endpoint to update the details of an existing Issuer. </p> <p>How it works: It allows passing the <code>displayName</code>, <code>logo</code>, <code>legalName</code> and <code>region</code> as optional Request Body parameters. You can choose passing only one of these value or all of them according to the type of information about the Issuer to update. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of details related to the updated Issuer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/issuer/apis/#delete-issuer","title":"Delete Issuer","text":"<p>Function: Endpoint to delete an existing Issuer. </p> <p>How it works: It requires passing the Issuer <code>id</code> as Path Parameter. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request the Issuer will be deleted and no longer able to perform actions on Polygon ID Platform.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/","title":"Claim Offers","text":""},{"location":"issuer/platform-api/offers/apis/#claim-offers","title":"Claim Offers","text":"<p>Once an Issuer has been set up and created schemas, they can start offering Claims to their users. A Claim Offer is a Schema filled with data of actual users delivered to users' Wallets.</p>"},{"location":"issuer/platform-api/offers/apis/#create-offer","title":"Create Offer","text":"<p>Function: Endpoint to create a new Claim Offer based on an existing Claim Schema.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the Schema of the Claim intended to offer, as Path Parameters. </p> <p>Furthermore, It requires passing the following as Request Body parameters:</p> <ul> <li> <p><code>attributes</code> (required) an array of maximum two objects that describe the attributes of the Claim Offer. It's important that the number of objects matches the number of attributes defined inside the Schema Creation. Each object contains: attribute key` (required), name of the attribute as defined in the Schema</p> <ul> <li><code>attributeValue</code> (required), value to be assigned to that attribute; its type must match the type defined inside the Schema Creation;</li> </ul> </li> <li> <p><code>expirationDate</code>, a string that defines the expirationDate of the claim. It is a required value if you specified mandatoryExpiration as true in the Schema Creation.</p> </li> <li><code>limitedClaims</code>, a number that can be optionally set to define a limit to the amount of claim, based on this offer, that can be redeemed.</li> <li><code>claimLinkExpiration</code>, expiration date in ISO 8601 format for the Claim Offer Link. After that Date a Claim Offer will not be redeemable anymore using that Link.</li> </ul> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains a set of information related to your newly created Claim Offer such as its <code>id</code>.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/offers/apis/#get-offers-by-schema","title":"Get Offers By Schema","text":"<p>Function: Endpoint to fetch all the Claim Offers created for an existing Schema.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the existing Schema you are querying, as Path Parameters. </p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains an array of Objects where each object contains the details of a Claim Offer generated by a specific Issuer using the queried Schema.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#get-offers-by-issuer","title":"Get Offers By Issuer","text":"<p>Function: Endpoint to fetch all the Claim Offers created by an Issuer.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, as Path Parameter. Optionally, it accepts a <code>query</code> as Query Parameter which is a search keyword. </p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains an array of Objects where each object contains the details of a Claim Offer generated by the queried Issuer.</p> <p>Compared to the <code>Get Offers By Schema</code> endpoint, this endpoint doesn't require to specify the <code>id</code> of a specific schema therefore the Response can contain offers based on different Schemas. </p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#get-offer","title":"Get Offer","text":"<p>Function: Endpoint to fetch a specific Claim Offer.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the Schema used to create the Claim Offer, and the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you are querying, as Path Parameters.</p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains an Object with the details of that specific Claim Offer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#update-offer","title":"Update Offer","text":"<p>Function: Endpoint to update a specific Claim Offer. </p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the Schema used to create the Claim Offer, and the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you want to delete, as Path Parameters.</p> <p>Furthermore, It requires passing a boolean for <code>active</code> as Request Body parameter: setting active to true will activate an Offer, setting active to false will deactivate an Offer.</p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request, the Claim Offer, identifier by its <code>id</code>, gets deactivated. It means that you will no longer be able to <code>Create QRCode of Offer</code> based on that offer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#create-qrcode-of-offer","title":"Create QRCode of Offer","text":"<p>Function: Endpoint to generate a QR Code based on a specific Claim Offer for User Authentication.</p> <p>How it works: It requires passing the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you want to generate the QR Code for, as Path Parameter.</p> <p>The Response Body contains a set of details about the Claim Offer including the <code>qrCode</code>. The JSON file included in the <code>qrCode</code> can be parsed into a QR Code and presented to the user in order to authenticate. This endpoint will also create a specific <code>sessionID</code> for the user that is going to scan that QR Code.</p> <p>In order to execute this endpoint correctly it is necessary that: </p> <ul> <li>The Claim Offer is active (namely, it hasn't been deactivated using Delete Offer)</li> <li>The Claim Offer hasn't expired (namely, the <code>expirationDate</code> set in Offer Creation hasn't passed)</li> <li>The Claim Offer hasn't exceeded the limit (namely, the <code>limitedClaims</code> set in Offer Creation hasn't been exceeded)</li> </ul> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/offers/apis/#download-qrcode-of-offer","title":"Download QRCode of Offer","text":"<p>Function: Endpoint to download the QR Code based on a Claim Offer.</p> <p>How it works: The Endpoint requires passing the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you want to generate the QR Code for, as Path Parameter and the <code>sessionID</code> of the specific user that has been previously authenticated, as Query Parameter.</p> <p>On successful Request, the Response contains the actual QR Code to be displayed to the user in order to fetch a claim inside their Wallet.</p> <p>This endpoint downloads the same <code>qrCode</code> returned from the previous Endpoint as PNG Format.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/offers/apis/#get-qrcode-of-offer","title":"Get QRCode of Offer","text":"<p>Function: Returns the status of the scan of the QR Code. </p> <p>How it works: The Endpoint requires passing the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you used to generate the QR Code, as Path Parameter and the <code>sessionID</code> generated on QR Code Creation, as Query Parameter.</p> <p>The Response Body contains the status of the scan of the first QR Code: - <code>pending</code> if it hasn't been scanned the status is pending - <code>error</code> if there's been an error in the process - <code>success</code> if the authorization was successful. In this case, it will also return a JSON file inside the <code>qrCode</code> field. </p> <p>The JSON File can be parsed into a QR Code and presented to the user in order to fetch a claim inside their Wallet.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/","title":"Onboarding Orgs","text":""},{"location":"issuer/platform-api/onboarding-orgs/apis/#onboarding-orgs","title":"Onboarding Orgs","text":"<p>The Onboarding Orgs endpoints contain all the actions needed to manage an Organization Account, such as Creating an Account, Activating an Account, Sign-in to an Account or Resetting its password.</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#create-org","title":"Create Org","text":"<p>Function: Endpoint to create a new Account for an Organization. </p> <p>How it works: It requires passing <code>email</code> and <code>password</code> as required Request Body parameters. These represent the login credentials for your Organization. The Response Body contains a set of information related to your Organization Account such as its identifier <code>id</code>. </p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#sign-in","title":"Sign in","text":"<p>Function: Endpoint to sign-in to your Organization Account.</p> <p>How it works: It requires passing your Organization Account credentials <code>email</code> and <code>password</code> as required Request Body parameters. The Response Body contains a JWT token that will be used as <code>Bearer Token</code> in order to use other Endpoints. The token, if not deactivated or refreshed, will be active for 24 hours.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#activate-account","title":"Activate Account","text":"<p>Function: Endpoint to activate your Organization Account. </p> <p>How it works: It requires passing a valid <code>Bearer Token</code> token inside the Authorization Request Header. The Response Body contains an updated <code>Bearer Token</code>.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#resend-email","title":"Resend Email","text":"<p>Function: Endpoint to request an email that contains a link to activate your Organization Account.</p> <p>How it works: It requires passing your organization <code>email</code> as required Request Body parameters. As a result of this Request you will receive an email containing a link to activate your Organization Account.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#update-account","title":"Update Account","text":"<p>Function: Endpoint to update the password of your Organization Account.</p> <p>How it works: The Endpoint requires passing the Organization Account <code>id</code> as Path Parameter (you retrieve it as Response from the Create Org Endpoint) and the current password (<code>password</code>) and the new password <code>newPassword</code> as required Request Body parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the updated set of information related to your Organization Account. </p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#request-reset-password","title":"Request Reset Password","text":"<p>Function: Endpoint to request for a link to reset a new password for your Organziation Account. </p> <p>How it works: It requires passing your Organization Account <code>email</code> as required Request Body parameters. As a result of this Request you will receive an email containing a link to Reset your Organization Account password.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#reset-password","title":"Reset Password","text":"<p>Function: Endpoint to set a new password for your Organziation Account. </p> <p>How it works: It requires passing the new <code>password</code> as required Request Body parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request you will change the password used to sign-in to your Organization Account.</p> <p>API Reference</p> <p></p> <p>The Reset Password Endpoint requires to be already sign-in to an Organization Account while the Request Reset Password doesn't. You will likely use the latter only when you forget your password!</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#update-account-email","title":"Update Account Email","text":"<p>Function: Endpoint to update the account email associated to your Organziation Account. </p> <p>How it works: It requires passing the <code>password</code> associated to your Organization Account and the new <code>email</code> that you want to associate to your Organization Account. The Endpoint requires passing a valid <code>Bearer Token</code>inside the Authorization Request Header. As a result of this Request a confirmation notification will be sent to the old account email with a deeplink to accept the change.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#refresh-token","title":"Refresh Token","text":"<p>Function: Endpoint to refresh the Bearer Token for an Organization Account. </p> <p>How it works: It requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains a refreshed <code>Bearer Token</code>.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#sign-out","title":"Sign Out","text":"<p>Function: Endpoint to sign-out to your Organization Account.</p> <p>How it works: It requires passing an active <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request your Bearer Token will be deactivated.</p> <p>This action has to be performed every time you intend to deactive the Bearer Token.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/schemas/apis/","title":"Schemas","text":""},{"location":"issuer/platform-api/schemas/apis/#schemas","title":"Schemas","text":"<p>The Schemas APIs allow the creation of customized Schema for your Claims. A Claim Schema encodes the structure of a particular claim by defining the usage and the vocabulary of its Attributes. To achieve claim reusability across multiple verifiers is important to consistently use the same schema to represent the same type of information. As a rule of thumb, existing claim schemas should always be preferred in order to achieve interoperability inside the Polygon ID ecosystem.</p>"},{"location":"issuer/platform-api/schemas/apis/#create-schema","title":"Create Schema","text":"<p>Function: Endpoint to create a new Claim Schema Template for an Issuer</p> <p>How it works: The Endpoint requires passing the Issuer <code>id</code> as Path Parameter. </p> <p>It requires passing the following as Request Body parameters:</p> <ul> <li><code>schema</code> (required), name of the schema in a human-readable</li> <li><code>mandatoryExpiration</code> (required), a boolean that indicates whether to make the claim with mandatory expiration or not</li> <li><code>technicalName</code> (required), name of the schema with formatting constraints, such as no special characters and spaces</li> <li> <p><code>attributes</code> (required) an array of maximum two objects that describe the type of data stored inside the Claim Schema. Each object contains: </p> <ul> <li><code>name</code> (required), name of the attribute in a human-readable</li> <li><code>technicalName</code> (required), name of the attribute with formatting constraints, such as no special characters and spaces</li> <li><code>type</code> (required), type of the attribute which can be <code>boolean</code>, <code>date</code>, <code>datetime</code>, <code>multichoice</code> and <code>number</code>.</li> <li><code>description</code>, a string that may add further details about the Schema or describes the vocabulary used to define the attributes</li> <li><code>values</code>, an array of strings that represent the range of possible values that the attribute can cover in the case the chosen type is <code>multichoice</code>. There should be at least 2 values, while there's no upper limit</li> </ul> </li> </ul> <p>\u26a0\ufe0f The <code>multichoice</code> type is not supported yet from the Polygon ID Wallet</p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains a set of information related to your newly created Schemas such as its <code>id</code>.</p> <p>Remember that the Schema is only a Template which will be filled with actual user data inside the Claim Offer.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/schemas/apis/#get-schema","title":"Get Schema","text":"<p>Function: Endpoint to fetch the details of a specific Claim Schema starting from its <code>id</code>.</p> <p>How it works: It requires passing your Issuer <code>id</code> and the Schema <code>id</code> as Path Parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of information related to the required Claim Schema.</p> <p>You can query a Schema created by a different Issuer. In order to do that you just need to pass the identifier of the queried Schema. The issuer identifier passed as Path Parameter must be your one!</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/schemas/apis/#get-all-schemas","title":"Get All Schemas","text":"<p>Function: Endpoint to fetch the details of all the Claim Schemas created by an Issuer.</p> <p>How it works: It requires passing the Issuer <code>id</code> as Path Parameter. Optionally, it accepts a <code>query</code> and a boolean <code>active</code> as Query Parameters which are search keywords. </p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of information related to the required Claim Schema.</p> <p>The Endpoint requires passing the Issuer <code>id</code> as Path Parameter. In order to use this endpoint, you need passing an active <code>Bearer Token</code> token inside the Authorization Request Header. The Response Body contains the entire set of information related to the Claim Schemas created by that specific Issuer. If the query was set to a specific value, for example <code>query=role</code> the Reponse Body will contain only the Schemas that contain the given keyword either in the schema Name or across its Attributes.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/schemas/apis/#get-schema-claims","title":"Get Schema Claims","text":"<p>Function: Endpoint to return all the Claims issued based on a particular Schema.</p> <p>How it works: It requires passing the Issuer <code>id</code> and the Schema <code>id</code> of the queried Schema as Path Parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/getting-started-flow/","title":"Getting Started","text":""},{"location":"issuer-node/getting-started-flow/#getting-started","title":"Getting Started","text":"<p>This article details the steps that can be carried out to achieve full integration of the Issuer Node with the Polygon ID APIs.</p>"},{"location":"issuer-node/getting-started-flow/#installation","title":"Installation","text":"<p>There are two options for installing and running the server alongside the UI:</p> <ol> <li>Docker Setup Guide</li> <li>Standalone Mode Guide</li> </ol> <p>For either one, you first have to clone the repository.</p> DockerStandalone Mode Guide"},{"location":"issuer-node/getting-started-flow/#docker-setup-guide","title":"Docker Setup Guide","text":"<p>Running the app with Docker allows for minimal installation and a quick setup. This is recommended for evaluation use-cases only, such as local development builds.</p>"},{"location":"issuer-node/getting-started-flow/#docker-guide-requirements","title":"Docker Guide Requirements","text":"<ul> <li>Unix-based operating system (e.g. Debian, Arch, Mac OS)</li> <li>Docker Engine <code>1.27+</code></li> <li>Makefile toolchain <code>GNU Make 3.81</code></li> </ul> <p>Warning</p> <p>There is no compatibility with Windows environments at this time.</p> <p>To help expedite a lot of the Docker commands, many have been abstracted using <code>make</code> commands. Included in the following sections are the equivalent Docker commands that show what is being run.</p>"},{"location":"issuer-node/getting-started-flow/#create-docker-configuration-files","title":"Create Docker Configuration Files","text":"<p>Make sure you are in the root folder and then make a copy of the following environment variables files:</p> <pre><code># FROM: ./\n\ncp .env-api.sample .env-api;\ncp .env-issuer.sample .env-issuer;\n# (Optional - For issuer UI)\ncp .env-ui.sample .env-ui;\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#node-issuer-configuration","title":"Node Issuer Configuration","text":"<p>The <code>.env-issuer</code> will be loaded into the Docker compose initializer.</p> <p>Any of the following RPC providers can be used:</p> <ul> <li>Chainstack</li> <li>Ankr</li> <li>QuickNode</li> <li>Alchemy</li> <li>Infura</li> </ul> <p>Mainnet or Testnet?</p> <p>Using Mainnet or Testnet will depend on the RPC URL you are going to use in this step. After you decide which of the RPC providers you will be using, like any of the examples above, you will need to copy the URL for the network you are willing to use.</p> <p>If it is desired to run a free public forwarding URL, see Getting A Public URL.</p> <p>Configure <code>.env-issuer</code> with the following details (or amend as desired).</p> <pre><code># ...\n\n# See Section: Getting A Public URL\nISSUER_SERVER_URL=&lt;https://unique-forwaring-or-public-url.ngrok-free.app&gt;\n# Defaults for Basic Auth in Base64 (\"user-issuer:password-issuer\" = \"dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy\")\n# If you just want to get started, don't change these\nISSUER_API_AUTH_USER=user-issuer\nISSUER_API_AUTH_PASSWORD=password-issuer\n# !!!MUST BE SET or other steps will not work\nISSUER_ETHEREUM_URL=&lt;YOUR_RPC_PROVIDER_URI_ENDPOINT&gt;\n</code></pre> <p>Note</p> <p>In case the Vault was loaded multiple times and a fresh start is needed, the following will remove remnant data:</p> <pre><code># FROM: ./\n\nmake clean-vault;\n# (Equivalent)\n#   rm -R infrastructure/local/.vault/data/init.out\n#   rm -R infrastructure/local/.vault/file/core/\n#   rm -R infrastructure/local/.vault/file/logical/\n#   rm -R infrastructure/local/.vault/file/sys/\n\n# Expected Output/Prompt:\n#   rm -R infrastructure/local/.vault/data/init.out\n#   rm -R infrastructure/local/.vault/file/core/\n#   rm -R infrastructure/local/.vault/file/logical/\n#   rm -R infrastructure/local/.vault/file/sys/\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#start-redis-postgres-vault","title":"Start Redis Postgres &amp; Vault","text":"<p>This will start the necessary local services needed to store the wallet private key to the Hashicorp vault and allow storing data associated to the issuer. Don't forget to initialize Docker before running this command.</p> <pre><code># FROM: ./\n\nmake up;\n# (Equivalent)\n#   docker compose -p issuer -f ./infrastructure/local/docker-compose-infra.yml up -d redis postgres vault;\n\n# Expected Output:\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose-infra.yml up -d redis postgres vault\n#   [+] Running 4/4\n#   \u283f Network issuer-network       Created                                                                                   0.0s\n#   \u283f Container issuer-vault-1     Started                                                                                   0.5s\n#   \u283f Container issuer-redis-1     Started                                                                                   0.4s\n#   \u283f Container issuer-postgres-1  Started  \n</code></pre> <p>To remove all services, run the following (ignore the warnings):</p> <pre><code># FROM: ./\n\nmake down; \n# (Equivalent)\n#   docker compose -p issuer -f ./infrastructure/local/docker-compose-infra.yml down --remove-orphans -v;\n\n# Expected Output:\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose-infra.yml down --remove-orphans\n#   [+] Running 4/3\n#   \u283f Container issuer-postgres-1  Removed                                                                                   0.2s\n#   \u283f Container issuer-redis-1     Removed                                                                                   0.2s\n#   \u283f Container issuer-vault-1     Removed                                                                                   0.2s\n#   \u283f Network issuer-network       Removed                                                                                   0.0s\n#   docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml down --remove-orphans\n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string. \n#   WARN[0000] The \"DOCKER_FILE\" variable is not set. Defaulting to a blank string.\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#import-wallet-private-key-to-vault","title":"Import Wallet Private Key To Vault","text":"<p>In order to secure the wallet private key so that the issuer can use it to issue credentials, it must be stored in the Hashicorp Vault.</p> <p>Note</p> <p>Make sure the wallet that is provided has Testnet Matic to be able to send transactions and that you are providing the Private Key. Here's how you can extract the private key from MetaMask, for instance.</p> <pre><code># FROM: ./\n\n# Make sure to verify that the issuer-vault-1 is full initialized to avoid: \"Error writing data to iden3/import/pbkey: Error making API request.\"\nmake private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt; add-private-key;\n# (Equivalent)\n#   docker exec issuer-vault-1 vault write iden3/import/pbkey key_type=ethereum private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt;;\n\n# Expected Output:\n#   docker exec issuer-vault-1 \\\n#           vault write iden3/import/pbkey key_type=ethereum private_key=&lt;YOUR_WALLET_PRIVATE_KEY&gt;\n#   Success! Data written to: iden3/import/pbkey\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#add-vault-to-configuration-file","title":"Add Vault To Configuration File","text":"<p>This will get the vault token from the Hashicorp vault docker instance and add it to our <code>./env-issuer</code> file.</p> <pre><code># FROM: ./\n\nmake add-vault-token;\n# (Equivalent)\n#   TOKEN=$(docker logs issuer-vault-1 2&gt;&amp;1 | grep \" .hvs\" | awk  '{print $2}' | tail -1);\n# sed '/ISSUER_KEY_STORE_TOKEN/d' .env-issuer &gt; .env-issuer.tmp;\n# echo ISSUER_KEY_STORE_TOKEN=$TOKEN &gt;&gt; .env-issuer.tmp;\n# mv .env-issuer.tmp .env-issuer;\n\n# Expected Output:\n#   sed '/ISSUER_KEY_STORE_TOKEN/d' .env-issuer &gt; .env-issuer.tmp\n#   mv .env-issuer.tmp .env-issuer\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#create-issuer-did","title":"Create Issuer DID","text":"<p>Note</p> <p>This can also be done via the UI API.</p> <p>This will create a new issuer DID by creating a new Docker instance of the issuer, generating the DID of the issuer, storing it in the database, then deleting the instance.</p> <p>It then copies the new DID to <code>.env-api</code>.</p> NON-Apple-M1/M2/Arm (ex: Intel/AMD)Apple-M1/M2/Arm <pre><code># FROM: ./\n\n# NON-Apple-M1/M2/Arm Command:\nmake generate-issuer-did;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f ./infrastructure/local/docker-compose.yml up -d initializer\n# sleep 5\n#  $(eval DID = $(shell docker logs -f --tail 1 issuer-initializer-1 | grep \"did\"))\n#  @echo $(DID)\n#  sed '/ISSUER_API_UI_ISSUER_DID/d' .env-api &gt; .env-api.tmp\n#  @echo ISSUER_API_UI_ISSUER_DID=$(DID) &gt;&gt; .env-api.tmp\n#  mv .env-api.tmp .env-api\n#  docker rm issuer-initializer-1\n</code></pre> <pre><code># FROM: ./\n\n# Apple-M1/M2/Arm Command:\nmake generate-issuer-did-arm;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d initializer;\n# sleep 5;\n#   DID=$(docker logs -f --tail 1 issuer-initializer-1 | grep \"did\");\n#   echo $DID;\n#   sed '/ISSUER_API_UI_ISSUER_DID/d' .env-api &gt; .env-api.tmp;\n#   echo ISSUER_API_UI_ISSUER_DID=$DID &gt;&gt; .env-api.tmp;\n#   mv .env-api.tmp .env-api;\n#   docker rm issuer-initializer-1;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d initializer\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n#   [+] Running 1/1\n#   \u283f Container issuer-initializer-1  Started                                                                                0.2s\n#   sleep 5\n#   did:polygonid:polygon:mumbai:uniqueAlphanumericKeyGenerated\n#   sed '/ISSUER_API_UI_ISSUER_DID/d' .env-api &gt; .env-api.tmp\n#   mv .env-api.tmp .env-api\n#   docker rm issuer-initializer-1\n#   issuer-initializer-1\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#start-issuer-api","title":"Start Issuer API","text":"<p>Now that the issuer API is configured, it can be started.</p> NON-Apple-M1/M2/Arm (ex: Intel/AMD)Apple-M1/M2/Arm <pre><code># FROM: ./\n\nmake run;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api;\n</code></pre> <pre><code># FROM: ./\n\nmake run-arm;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api;\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n</code></pre> <p>Navigating to http://localhost:3001 shows the issuer API's frontend:</p> <p></p>"},{"location":"issuer-node/getting-started-flow/#optional-configure-ui","title":"(Optional) Configure UI","text":"<p>This step is required to run the separate UI application, which allows intuitive and convenient management of schemas, credentials, connections and issuer state.</p> <p>Tip</p> <p>Running and using the UI is optional, since it implements funcionality already exposed via the UI API. It is highly recommended though, because it makes issuer management far simpler and more intuitive.</p> <pre><code># FROM: ./\n\ncp .env-ui.sample .env-ui;\n</code></pre> <p>Configure the <code>.env-ui</code> file with the following details (or amend as desired):</p> <pre><code>ISSUER_UI_BLOCK_EXPLORER_URL=https://mumbai.polygonscan.com\nISSUER_UI_AUTH_USERNAME=user-ui\nISSUER_UI_AUTH_PASSWORD=password-ui\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#start-api-ui-ui-notifications-server-publisher","title":"Start API UI, UI, Notifications server &amp; Publisher","text":"<p>This will start the UI API that exposes endpoints to manage schemas, credentials, connections and issuer state, as well as the UI that relies on it.</p> NON-Apple-M1/M2/Arm (ex: Intel/AMD)Apple-M1/M2/Arm <pre><code># FROM: ./\n\nmake run-ui;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api-ui ui notifications pending_publisher;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api-ui ui notifications pending_publisher\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n#   [+] Running 4/4\n#    \u283f Container issuer-ui-1                 Started                                                                                                           0.5s\n#    \u283f Container issuer-api-ui-1             Started                                                                                                           0.5s\n#    \u283f Container issuer-notifications-1      Started                                                                                                           0.4s\n#    \u283f Container issuer-pending_publisher-1  Running  \n</code></pre> <pre><code># FROM: ./\n\nmake run-ui-arm;\n# (Equivalent)\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/local/docker-compose.yml up -d api-ui ui notifications pending_publisher;\n\n# Expected Output:\n#   COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_FILE=\"Dockerfile-arm\" docker compose -p issuer -f /Users/username/path/to/sh-id-platform/infrastructure/local/docker-compose.yml up -d api-ui ui notifications pending_publisher\n#   WARN[0000] Found orphan containers ([issuer-vault-1 issuer-postgres-1 issuer-redis-1]) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. \n#   [+] Running 4/4\n#    \u283f Container issuer-ui-1                 Started                                                                                                           0.5s\n#    \u283f Container issuer-api-ui-1             Started                                                                                                           0.5s\n#    \u283f Container issuer-notifications-1      Started                                                                                                           0.4s\n#    \u283f Container issuer-pending_publisher-1  Running  \n</code></pre> <p>Now navigate to http://localhost:3002 to see the UI API's frontend:</p> <p></p>"},{"location":"issuer-node/getting-started-flow/#using-the-ui-api","title":"Using the UI API","text":"<p>Make sure to set the HTTP authentication credentials in <code>.env-api</code> to the following:</p> <pre><code># ...\n\nISSUER_API_UI_AUTH_USER=user-api\nISSUER_API_UI_AUTH_PASSWORD=password-api\n</code></pre> <p>Then authenticate via the following form on http://localhost:3002:</p> <p></p> <p>This allows you to make a request via any of the endpoints using this frontend.</p> <p></p>"},{"location":"issuer-node/getting-started-flow/#optional-using-the-ui","title":"(Optional) Using the UI","text":"<p>This service is running on http://localhost:8088.</p> <p>Note</p> <p>If you are using Chrome, you might get the HTTP auth modal showing and disappearing quickly. To remedy this, use the following URL: http://user-api:password-api@localhost:8088/.</p> <p>File containing the basic auth credentials: <code>.env-ui</code></p> <pre><code># ...\n\nISSUER_UI_AUTH_USERNAME=user-ui\nISSUER_UI_AUTH_PASSWORD=password-ui\n</code></pre> <p></p> <p>Note</p> <p>If you want to run the UI app in development mode, i.e. with HMR enabled, please follow the steps in the Development (UI) section.</p>"},{"location":"issuer-node/getting-started-flow/#standalone-mode-guide","title":"Standalone Mode Guide","text":"<p>Running the app in standalone mode means you will need to install the binaries for the server to run natively. This is essential for production deployments.</p> <p>Make sure you have Postgres, Redis and Vault properly installed &amp; configured. Do not use <code>make up</code> since those will start the containers for non-production builds, see Docker Setup Guide.</p>"},{"location":"issuer-node/getting-started-flow/#standalone-mode-guide-requirements","title":"Standalone Mode Guide Requirements","text":"<ul> <li>Docker Engine 1.27</li> <li>Makefile toolchain</li> <li>Unix-based operating system (e.g. Debian, Arch, Mac OS X)</li> <li>Go 1.19</li> <li>Postgres</li> <li>Redis</li> <li>Hashicorp Vault</li> </ul>"},{"location":"issuer-node/getting-started-flow/#standalone-mode-setup","title":"Standalone Mode Setup","text":"<ol> <li>Copy <code>.env-api.sample</code> as <code>.env-api</code> and <code>.env-issuer.sample</code> as <code>.env-issuer</code>. Please see the configuration section for more details.</li> <li>Run <code>make build</code>. This will generate a binary for each of the following commands:<ul> <li><code>platform</code></li> <li><code>platform_ui</code></li> <li><code>migrate</code></li> <li><code>pending_publisher</code></li> <li><code>notifications</code></li> </ul> </li> <li>Run <code>make db/migrate</code>. This checks the database structure and applies any changes to the database schema.</li> <li>Run <code>./bin/platform</code> command to start the issuer.</li> <li>Run <code>./bin/pending_publisher</code>. This checks that publishing transactions to the blockchain works.</li> <li>Follow the steps for adding an Ethereum private key to the Vault.</li> <li>Follow the steps for creating an identity as your issuer DID.</li> <li>(Optional) To set up the UI with its own API, first copy <code>.env-ui.sample</code> as <code>.env-ui</code>. Please see the configuration section for more details.</li> </ol>"},{"location":"issuer-node/issue-credential-cli/","title":"Issue Credentials via CLI","text":""},{"location":"issuer-node/issue-credential-cli/#issuing-credentials-via-cli","title":"Issuing Credentials via CLI","text":"<p>Once the Issuer Node installation is completed, the following will walk you through issuing credentials via a CLI.</p> <p>Note</p> <p>These steps can be done either via the API UI (http://localhost:3001) or directly in the UI (http://localhost:8088).</p>"},{"location":"issuer-node/issue-credential-cli/#create-identity","title":"Create Identity","text":"<p>Note</p> <p>This is an alternative to the following: Create Issuer ID.</p> <pre><code># NOTE: dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy is a Basic HTTP Authorization as base64(user-issuer:password-issuer) from our .env-issuer file\ncurl --location 'http://localhost:3001/v1/identities' \\\n--header 'Authorization: Basic dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"didMetadata\":{\n        \"method\": \"polygonid\",\n        \"blockchain\":\"polygon\",\n        \"network\": \"mumbai\"\n    }\n}';\n\n# Expected Output:\n#   {\"identifier\":\"did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE\",\"state\":{\"claimsTreeRoot\":\"eb3d346d16f849b3cc2be69bfc58091dfaf6d90574be26bb40222aea67e08505\",\"createdAt\":\"2023-03-22T22:49:02.782896Z\",\"modifiedAt\":\"2023-03-22T22:49:02.782896Z\",\"state\":\"b25cf54e7e648a263658416194c41ef6ae2dec101c50dfb2febc5e96eaa87110\",\"status\":\"confirmed\"}}\n</code></pre>"},{"location":"issuer-node/issue-credential-cli/#optional-view-existing-dids-connections","title":"(Optional) View Existing DIDs (connections)","text":"<p>A connection is a DID that is linked to the issuer when they authenticate via an issued credential.</p> <p>Note</p> <p>You can check all the connections on the Issue Node UI.</p>"},{"location":"issuer-node/issue-credential-cli/#using-a-cli","title":"Using a CLI","text":"<p>This will output all DIDs (i.e. connections) that have been created with the issuer.</p> <pre><code>curl --location --request GET 'http://localhost:3001/v1/identities' \\\n--header 'Authorization: Basic dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"did_metadata\":{\n        \"method\": \"polygonid\",\n        \"blockchain\":\"polygon\",\n        \"network\": \"mumbai\"\n    }\n}';\n\n# Expected Output (Results may vary based on number of DIDs created):\n#   [\"did:polygonid:polygon:mumbai:2qMd3PtcVbzDNQZBiSDctaigbQtYW9KTqrLFoUm4Ur\",\"did:polygonid:polygon:mumbai:2qMeNWv9xSSvWyBpn5tDojzQ8sga4VtrfuAkV65zQa\",\"did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE\",\"did:polygonid:polygon:mumbai:2qLR2qA22RemPeQDsQwdrrMU3SM9CNLnRBhmQtzo5v\",\"did:polygonid:polygon:mumbai:2qHYtws8GQN3RniHLjPf5GuZUZtcD37o1MUgUmw287\"]\n</code></pre>"},{"location":"issuer-node/issue-credential-cli/#creating-credentials","title":"Creating Credentials","text":"<p>This will go through creating a <code>KYCAgeCredential</code> credential based off the following KYC Age Credential Schema</p> <p>Note</p> <p>Learn how to create credentials on the Issuer Node guide.</p>"},{"location":"issuer-node/issue-credential-cli/#using-a-cli_1","title":"Using a CLI","text":"<p>Before creating a credential, the identifier of the service/person is needed. To retrieve this, the <code>identifier</code> can be copied from the Polygon ID app to the clipboard.</p> <p></p> <p>Note</p> <p>The issuer node DID can be retrieved by looking at <code>.env-api</code> for <code>ISSUER_API_UI_ISSUER_DID</code></p> <pre><code>curl --location 'http://localhost:3001/v1/did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE/claims' \\\n--header 'Authorization: Basic dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"credentialSchema\":\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v3.json\",\n    \"type\": \"KYCAgeCredential\",\n    \"credentialSubject\": {\n        \"id\": \"did:polygonid:polygon:mumbai:2qEsg1AeTohAq6Euc3hBaDapfLVfQiWS7DUfvutYEq\",\n        \"birthday\": 19960424,\n        \"documentType\": 2\n    }\n}';\n\n# Expected Output:\n#   {\"id\":\"b1eab5be-dea3-11ed-8f7d-0242ac1e0005\"}\n</code></pre>"},{"location":"issuer-node/issue-credential-cli/#optional-verifying-credentials-creation","title":"(Optional) Verifying Credentials Creation","text":"<p>Note</p> <p>You can always check the created credentials on the Issuer Node UI.</p>"},{"location":"issuer-node/issue-credential-cli/#using-a-cli_2","title":"Using a CLI","text":"<p>Using the previously generated credential ID from Creating Credentials.</p> <pre><code>curl --location --request GET 'http://localhost:3001/v1/did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE/claims/b1eab5be-dea3-11ed-8f7d-0242ac1e0005' \\\n--header 'Authorization: Basic dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy';\n\n# Expected Output:\n#   {\"@context\":[\"https://www.w3.org/2018/credentials/v1\",\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld\",\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\"],\"credentialSchema\":{\"id\":\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v3.json\",\"type\":\"JsonSchemaValidator2018\"},\"credentialStatus\":{\"id\":\"https://unique-forwaring-or-public-url.ngrok-free.app/v1/did%3Apolygonid%3Apolygon%3Amumbai%3A2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahUQ/claims/revocation/status/2512063162\",\"revocationNonce\":2512063162,\"type\":\"SparseMerkleTreeProof\"},\"credentialSubject\":{\"birthday\":19960424,\"documentType\":2,\"id\":\"did:polygonid:polygon:mumbai:2qEsg1AeTohAq6Euc3hBaDapfLVfQiWS7DUfvutYEq\",\"type\":\"KYCAgeCredential\"},\"id\":\"http://localhost:3001/v1/did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE/claims/b1eab5be-dea3-11ed-8f7d-0242ac1e0005\",\"issuanceDate\":\"2023-04-19T11:16:56.433871253Z\",\"issuer\":\"did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE\",\"proof\":[{\"type\":\"BJJSignature2021\",\"issuerData\":{\"id\":\"did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE\",\"state\":{\"claimsTreeRoot\":\"78b7651adb5d063553f7fdc11d279a3e307880aef6dec2b347abf0df53a11d27\",\"value\":\"....\n</code></pre>"},{"location":"issuer-node/issue-credential-cli/#issuing-credential-to-polygon-id-wallet-user","title":"Issuing Credential To Polygon ID Wallet User","text":"<p>This will walk you through the steps of issuing a credential to the Polygon ID wallet app.</p> <p>Note</p> <p>To learn how to issue credentials to a Polygon ID Wallet User, please refer to the Issuer Node Guide.</p>"},{"location":"issuer-node/issue-credential-cli/#using-a-cli_3","title":"Using a CLI","text":"<p>In order to get the credential on the Polygon ID App, the credential QR Code payload is needed.</p> <pre><code>curl --location 'http://localhost:3001/v1/did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE/claims/b1eab5be-dea3-11ed-8f7d-0242ac1e0005/qrcode' \\\n--header 'Authorization: Basic dXNlci1pc3N1ZXI6cGFzc3dvcmQtaXNzdWVy';\n\n# Expected Output:\n#   {\"body\":{\"credentials\":[{\"description\":\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld#KYCAgeCredential\",\"id\":\"b1eab5be-dea3-11ed-8f7d-0242ac1e0005\"}],\"url\":\"http://localhost:3001/v1/agent\"},\"from\":\"did:polygonid:polygon:mumbai:2qPdb2hNczpXhkTDXfrNmmt9fGMzfDHewUnqGLahYE\",\"id\":\"c01b66f1-d10b-4591-9dd6-8a94db1c112a\",\"thid\":\"c01b66f1-d10b-4591-9dd6-8a94db1c112a\",\"to\":\"did:polygonid:polygon:mumbai:2qEsg1AeTohAq6Euc3hBaDapfLVfQiWS7DUfvutYEq\",\"typ\":\"application/iden3comm-plain-json\",\"type\":\"https://iden3-communication.io/credentials/1.0/offer\"}\n</code></pre> <p>Take this JSON data, copy, and paste into https://qr.io.</p> <p></p> <p>With the Polygon ID app, open it up and scan the QR code.</p> <p></p>"},{"location":"issuer-node/issue-credential-cli/#verifying-credential","title":"Verifying Credential","text":"<p>Note</p> <p>The goal is to build your own type of credential and ways to verify it, but this is an example of how things could work.</p> <p>A quick way to validate this KYCAge Claim is to use https://verifier-demo.polygonid.me/.</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"issuer-node/issuer-node-guide/","title":"Issuer Node UI Guide","text":"<p>Info</p> <p>Before you actually act as an Issuer and provide credentials, you need to set up a Polygon ID Issuer Node. You can find instructions to get your Issuer Node up and running here.</p>"},{"location":"issuer-node/issuer-node-guide/#schemas","title":"Schemas","text":"<p>To create a credential, you require a schema that contains semantics of the JSON vocabulary and is used to describe a large number of datasets. The schema contains links to JSON-LD Context and JSON URL. </p> <p>You can create your own schemas and import them to the Issuer Node. Here's how you can do that:</p> <ol> <li> <p>Click on Import Schema:</p> <p></p> </li> <li> <p>Then you provide the schema URL:</p> <p></p> </li> <li> <p>After you pasted the schema URL, you can click on Preview import.</p> <p></p> </li> <li> <p>The preview will show the details of the schema. You can also choose to see the attributes in a formatted way, as a JSON LD context or the JSON schema itself.</p> <p></p> </li> <li> <p>Your new schema will be instantly added to your schema list.</p> <p></p> </li> </ol>"},{"location":"issuer-node/issuer-node-guide/#credentials","title":"Credentials","text":"<p>The Credentials main page shows information about all the credentials that have been granted. Each of one those credentials can be revoked by clicking on the 3 dots at the end of the row.</p> <p>Revocation and Issuer state publication</p> <p>Whenever an Issuer decides to revoke a credential, they have to publish the issuer state to the blockchain. This can be done on the Issuer state. Notice that there will be a Pending actions right next to the sidebar button. </p> <p>The main responsibility of an Issuer is to create and provide credentials to ID holders. Here is how you can do it:</p>"},{"location":"issuer-node/issuer-node-guide/#direct-issuance","title":"Direct Issuance","text":"<p>If you already have a connection with an identifier or you have its DID, you can issue a credential directly to it.</p> <ol> <li> <p>You can start by clicking on the Issue credential button or choosing the Issue action next to one of your Schema types.</p> <p></p> <p>Note</p> <p>The Connections area shows all identifiers who have been granted credentials. Direct issuance can also be done from there, by selecting the identifier you would like to issue a credential for.</p> </li> <li> <p>Either paste an identifier DID or select one from the list:</p> <p></p> </li> <li> <p>Now you will be prompted to choose which Schema Type you would like to create your credential with.     </p> </li> <li> <p>The credential we are trying to issue in this tutorial has one mandatory field: the entryDate. That would represent the day when the person would have joined the DAO.</p> <p></p> </li> <li> <p>Click on Issue credential directly and the credential is sent to the Holder. </p> </li> </ol>"},{"location":"issuer-node/issuer-node-guide/#generating-a-credential-link","title":"Generating a Credential link","text":"<ol> <li> <p>You can start by clicking on the Issue credential button or choosing the Issue action next to one of your Schema types.</p> <p></p> </li> <li> <p>There are some available options for this credential: an expiring date and a maximum number of issuances. </p> <p></p> <p>Note</p> <p>If you clicked on the Issue credential button, you will later be prompted to choose which Schema Type you would like to create your credential with. </p> </li> <li> <p>The credential we are trying to issue in this tutorial has one mandatory field: the entryDate. That would represent the day when the person would have joined the DAO.</p> <p></p> </li> <li> <p>After you click on Create credential link, you will have access to the credential link: </p> <p></p> </li> <li> <p>You can also generate a QR code embedding that previous link, by clicking on View link:</p> <p></p> </li> </ol> <p>What happens on the Holder's side?</p> <p>The holder will just have to log into his Polygon ID wallet, tap Connect, scan the QR code and choose Connect Wallet. After authentication, the holder finally receives their credential.</p> <p></p>"},{"location":"issuer-node/issuer-node-guide/#connections","title":"Connections","text":"<p>This area of the Issuer Node UI shows all the current connections with ID Holders as well as the credentials issued to them. </p> <p>You can also check the details about each of those connections, issue credentials directly or remove them by clicking on the 3 dots next to each connection.</p> <p>The Details page shows some useful information, such as identifier(DID), creation date and issued credentials. Some other available actions are direct issuance, credential revocation and removal.</p>"},{"location":"issuer-node/issuer-node-overview/","title":"Issuer Node Overview","text":""},{"location":"issuer-node/issuer-node-overview/#issuer-node-overview","title":"Issuer Node Overview","text":"<p>The Issuer Node is a self-hosted Node that any implementer can quickly set up and integrate into their application. Once the setup is completed, the Issuer Node exposes all the functionalities necessary to run an issuer such as:</p> <ul> <li>Create, manage, and revoke an identity</li> <li>Issue credentials to an identity</li> <li>Share credentials with the user's wallet using QR Code</li> <li>Publish Identity States on-chain </li> <li>Revoke credentials </li> </ul> <p>The Issuer Node can generate multiple identities for multiple Issuers and manages the states of these identities by updating the state stored on-chain.</p> <p>The Issuer Node provides API endpoints for the integrator's applications.</p>"},{"location":"issuer-node/issuer-node-overview/#issuer-node-components","title":"Issuer Node Components","text":"<p> The Issuer Node comprises the following components and each one of these components can be either dockerized or each one of these can be launched as separate service. </p> <ul> <li> <p>Issuer Application to issue Verifiable Credentials and communicate with users' wallets.</p> </li> <li> <p>Vault: Based on HashiCorp, the Vault is used in the Issuer Node for providing key management services. It helps to secure sensitive data, such as the private key of the issuer, thus protecting them in a secure way. The Vault has been provided with a plugin called <code>vault-plugin-secrets-iden3</code>; this plugin is used to sign the data with Baby Jubjub Keys that are stored in the Vault. </p> </li> <li> <p>Redis: Redis is used for caching the schemas that we use in the Issuer Node. The schemas are downloaded from IPFS and stored on Redis. This way, every time, the Issuer Node issues a Credential, it doesn't need to fetch the schemas from an external source; it can fetch it directly from Redis. This boosts the performance of the application. </p> </li> <li> <p>DB: This container is used as the data source for the Issuer Node. In our implementation of the Issuer Node, we have used Postgres as the database. It is where all the data related to issued credentials are stored. </p> <p>Note: In a testing environment, you can run the Vault, Redis, and Postgres services inside a docker. But for production, you are advised to secure these services first before using them. </p> </li> </ul>"},{"location":"issuer-node/issuer-node-overview/#core-library","title":"Core Library","text":"<ul> <li>Issuer Node</li> </ul>"},{"location":"issuer-node/issuer-node-overview/#support-libraries","title":"Support Libraries","text":"<ul> <li>go Iden3 Core: Go implementation of Iden3 core functionality  </li> <li>go Iden3 Crypto: Go implementation of important cryptographic elements including baby jubjub key, Keccak256, and poseidon </li> <li>go Merkle Tree SQL: Go implementation of Merkle tree based on the library of circuit templates</li> </ul>"},{"location":"issuer-node/issuer-node-api/introduction/","title":"Introduction","text":""},{"location":"issuer-node/issuer-node-api/introduction/#polygon-id-issuer-node-apis","title":"Polygon ID Issuer Node APIs","text":"<p>The Issuer Node APIs provide a user with the following functionalities: </p> <ul> <li>Create and retrieve Identities</li> <li>Create a Verifiable Credential (VC)</li> <li>Retrieve a Verifiable Credential or a list of Verifiable Credentials</li> <li>Generate JSON to create a QR Code and use that to accept credentials in wallet</li> <li>Revoke a Verifiable Credential</li> <li>Retrieve the Revocation Status of a Verifiable Credential</li> <li>Call Agent Endpoint using the Wallet App</li> </ul> <p>These APIs can be tested locally on a Self Hosted Platform or with our Postman Collection. </p> <p>Note: Please note that the API endpoints listed in the testing links above need to be called in sequential order. For example, you need to first create an identity before a Verifiable Credential can be issued by the Issuer Node.</p>"},{"location":"issuer-node/issuer-node-api/agent/apis/","title":"Agent","text":""},{"location":"issuer-node/issuer-node-api/agent/apis/#agent","title":"Agent","text":"<p>The agent endpoint acts as a port to communicate messages between the mobile app and the server. The user, using the agent endpoint, can access the functionality through his/her mobile app. </p> <p>The core feature of  message-based communication initiation in messaging specification is the process of looking up the two main properties of each identity: </p> <ol> <li> <p>An endpoint (web, email, etc) where messages can be delivered to a specific identity. </p> </li> <li> <p>The public key that a specific identity agent is using for communication with another identity.</p> </li> </ol> <p>The JWZ is generated within the user's identity wallet in response to the authentication requested by an Issuer. </p>"},{"location":"issuer-node/issuer-node-api/agent/apis/#agent-endpoint","title":"Agent Endpoint","text":"<p>Function: Endpoint to send a JWZ token from the user's mobile app. </p> <p>How it Works: The user's app sends a JWZ token in the request body. </p> <p>The Issuer Node responds by sending a response message that contains details related to Verifiable Credential and Issuer. It also includes metadata such as:</p> <ul> <li><code>from</code>: from which user DID the message is sent</li> <li><code>to</code>: to which Issuer DID the message is sent</li> <li><code>id</code>: a random UUID generated for a transaction</li> <li><code>threadID</code>: part of the JWZ token</li> <li><code>typ</code>: The way of communication between protocol and mobile </li> <li><code>type</code>: The way of communication between protocol and mobile </li> </ul> <p>A typical response looks like this:</p> <pre><code>{\n    \"body\": {\n        \"credential\": {\n            \"id\": \"https://ce98-2a0c-5a84-3403-bb00-e0d9-c19e-2ab1-2a2b.eu.ngrok.io/issuer/v1/did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA/claims/ec81d686-a6e4-11ed-a1f4-debe37e1cbd5\",\n            \"@context\": [\n                \"https://www.w3.org/2018/credentials/v1\",\n                \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/iden3credential-v2.json-ld\",\n                \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\"\n            ],\n            \"type\": [\n                \"VerifiableCredential\",\n                \"KYCAgeCredential\"\n            ],\n            \"expirationDate\": \"2030-01-01T01:00:00+01:00\",\n            \"issuanceDate\": \"2023-02-07T13:42:46.904238+01:00\",\n            \"credentialSubject\": {\n                \"birthday\": 19960424,\n                \"documentType\": 782222,\n                \"id\": \"did:polygonid:polygon:mumbai:2qG9d1nUyeTVU63vU1gH3jcD6Y8z4ANPSdFdQHPY4t\",\n                \"type\": \"KYCAgeCredential\"\n            },\n            \"credentialStatus\": {\n                \"id\": \"https://ce98-2a0c-5a84-3403-bb00-e0d9-c19e-2ab1-2a2b.eu.ngrok.io/issuer/v1/did%3Apolygonid%3Apolygon%3Amumbai%3A2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA/claims/revocation/status/4144415042\",\n                \"revocationNonce\": 4144415042,\n                \"type\": \"SparseMerkleTreeProof\"\n            },\n            \"issuer\": \"did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA\",\n            \"credentialSchema\": {\n                \"id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v3.json\",\n                \"type\": \"JsonSchemaValidator2018\"\n            },\n            \"proof\": [\n                {\n                    \"type\": \"BJJSignature2021\",\n                    \"issuerData\": {\n                        \"id\": \"did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA\",\n                        \"state\": {\n                            \"claimsTreeRoot\": \"c244e9c4a42a1fb6aace041c08ecdc9532170194dd03ae99ffd5a035a4423f04\",\n                            \"value\": \"f92376a5ec15d599f877504d55a3c703d8e40aebb9e9e60802fc217a86693a02\"\n                        },\n                        \"authCoreClaim\": \"cca3371a6cb1b715004407e325bd993c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f8f439351d6704039b792e9ee4c6dc0a82f514ecb6e49f00350c4d1d4bbce2fe11274a4e0b1f374124cf775503a100922c59c8778c778b8b80614dfd52fad060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n                        \"mtp\": {\n                            \"existence\": true,\n                            \"siblings\": []\n                        },\n                        \"credentialStatus\": {\n                            \"id\": \"https://ce98-2a0c-5a84-3403-bb00-e0d9-c19e-2ab1-2a2b.eu.ngrok.io/issuer/v1/did%3Apolygonid%3Apolygon%3Amumbai%3A2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA/claims/revocation/status/0\",\n                            \"revocationNonce\": 0,\n                            \"type\": \"SparseMerkleTreeProof\"\n                        }\n                    },\n                    \"coreClaim\": \"c9b2370371b7fa8b3dab2a5ba81b68382a0000000000000000000000000000000212511ab3cc09f0f233e2868d41ae6f7bb2ac9d2dd791d75a99072f128c0d00de72a95dd264a4de5df8ce745c1d393c1480248d27e12f6f0f1ea6b5f12a722e000000000000000000000000000000000000000000000000000000000000000042c106f70000000080d8db700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n                    \"signature\": \"78aa6364e769c74557f63ffa6830271b213854ce1f75ad633822fb461fb8e2891ac19621958d27e2ea7997d9f9bcf8e713e97dc98cd3b4faaa71df5b55088303\"\n                }\n            ]\n        }\n    },\n    \"from\": \"did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA\",\n    \"id\": \"558984b4-b074-42a7-b60f-c2b5290d1a32\",\n    \"threadID\": \"4ccb5b86-bf30-47a4-b7e1-e0e2e4edec8b\",\n    \"to\": \"did:polygonid:polygon:mumbai:2qG9d1nUyeTVU63vU1gH3jcD6Y8z4ANPSdFdQHPY4t\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/credentials/1.0/issuance-response\"\n}\n</code></pre> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/","title":"Claim","text":""},{"location":"issuer-node/issuer-node-api/claim/apis/#claim","title":"Claim","text":"<p>The collection of Claim endpoints is used to provide the following set of functionalities:</p> <ul> <li>Create a Verifiable Credential (VC)</li> <li>Retrieve a credential or a set of credentials</li> <li>Generate a JSON to create a QR code </li> <li>Update Identity State</li> <li>Revoke a Verifiable Credential</li> <li>Retrieve Revocation Status</li> </ul> <p>A credential ID is assigned to a Verifiable Credential when it is created by an Issuer. A user can then retrieve a VC via its ID. If a credential is no longer valid or lost, it can be revoked (rendered inactive and cannot be used). </p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#create-claim","title":"Create Claim","text":"<p>Function: Endpoint to create a Verifiable Credential for a user. </p> <p>How it Works: The DID (identifier string retrieved from calling the <code>Create Identity</code> endpoint) is passed as a path variable in the request URL. This is your DID identifier that you use as an issuer of credentials.</p> <p>The following parameters are passed in the body of the request:</p> <ul> <li><code>credentialSchema</code>: It is a template for a Verifiable Credential that guarantees the structure of a credential. This way, an Issuer, a Holder, and a Verifier can reference the data in a known way. Further details on the <code>credentialSchema</code> can be found in the Create Custom Schema section.</li> <li><code>type</code>: the type of the credential schema sent.</li> <li><code>credentialSubject</code>: Contains DID (Decentralized Identifier), i.e. <code>did</code>, of the user and the fields related to the data to be attested. You should have previously obtained this identifier from the user by performing a \"basic auth\" step, this can be done through the Authentication/QRcode step.</li> <li><code>expiration</code>: Date of expiry of the Verifiable Credential. </li> </ul> <p>Note: Depending on the schema a user opts for, the request body may contain some fields of the schema while leaving out the others. For example, in the API reference, we have considered the schema of the type <code>KYCAgeCredential</code> and therefore, included the <code>birthday</code> and <code>documentType</code> fields. </p> <p>The Issuer Node responds by sending a response message that contains the string <code>id</code>, which is the ID of the Verifiable Credential created by the Issuer Node. </p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-claim","title":"Get Claim","text":"<p>Function: Endpoint to retrieve a Verifiable Credential based on its Claim ID (CID). This way, you can retrieve a credential issued by an Issuer based on this credential's ID. </p> <p>How it Works: The DID (the identifier string retrieved from calling the <code>Create Identity</code> endpoint) and the Claim ID, i.e.<code>id</code> (or CID) of the Verifiable Credential (retrieved from calling the <code>Create Claim</code> endpoint) are passed as path variables in the request URL. </p> <p>The endpoint requires to pass the issuer <code>did</code> and the Verifiable Credential <code>CID</code> as path variables in the request URL.</p> <p>The server responds by sending the following data about the Verifiable Credential:</p> <ul> <li> <p><code>Context</code>: URL pointing to the JSON-LD Context of the Verifiable Credential.</p> </li> <li> <p><code>credentialSchema</code>: URL pointing to the credential JSON schema. </p> </li> <li> <p><code>credentialStatus</code>: Shows the URL to fetch the Revocation status of the credential, <code>revocationNonce</code> (zero or any value), <code>type</code> (type of Proof, for example, SparseMerkleTreeProof). </p> </li> <li> <p><code>credentialSubject</code>: Contains details of the subject (to whom the credential is issued) and includes:</p> <ul> <li>Credential Fields (for example, <code>birthday</code> and <code>documentType</code> in the case of KYCAgeCredential)</li> <li><code>id</code>: DID of the Subject</li> <li><code>type</code>: Type of credential for credentialSubject (for example, KYCAgeCredential)</li> </ul> </li> <li> <p><code>id</code>: It is the id of the Verifiable Credential.</p> </li> <li> <p><code>expiration</code>: The date on which the credential shall expire.</p> </li> <li> <p><code>issuer</code>: DID of the Issuer.</p> </li> <li> <p><code>issuanceDate</code>: The date on which the credential was issued by the Issuer.</p> </li> <li> <p><code>proof</code>: The proof that the user creates to prove that s/he is the real owner of the Verifiable Credential issued from the Issuer and that the Verifiable Credential that it holds is valid. It includes:</p> <ul> <li><code>type</code> of proof (for example, BJJSignature2021 or SparseMerkleTreeProof)</li> <li><code>issuerData</code>: It includes the Issuer's <code>id</code> (DID of the Issuer) and its <code>state</code> (value of its claimstreeroot, i.e. root of the claims (credential) tree)</li> <li><code>authclaim</code>: Value of authclaim along with its mtp <code>existence</code> (proof of its existence/non-existence in the Merkle tree) </li> <li><code>coreclaim</code>: Value of coreclaim along with <code>signature</code> (Issuer's signature which verifies that the credential is issued by a valid Issuer). </li> </ul> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-claims","title":"Get Claims","text":"<p>Function: Endpoint to retrieve all the Verifiable Credentials issued by an Issuer. </p> <p>How it Works: The DID (the identifier string retrieved from calling the <code>Create Identity</code> endpoint) is passed as path variables in the request URL. </p> <p>You can retrieve a set of credentials based on different filters or criteria. These criteria can be added as the query-string parameters in the request URL. These filters (and their data types) are listed below:</p> <ul> <li> <p>schemaType String: Type of schema. For example, schema based on Age-based KYC (KYCAgeCredential)</p> </li> <li> <p>schemaHash String: Hash of the schema. For example, c9b2370371b7fa8b3dab2a5ba81b6838</p> </li> <li> <p>subject String: Identifier of the Subject for which credentials are to be retrieved. For example, did:polygonid:polygon:mumbai:2qE1BZ7gcmEoP2KppvFPCZqyzyb5tK9T6Gec5HFANQ</p> </li> <li> <p>revoked Boolean: If the credential is revoked or not. It can be \"true\" or \"false\". </p> </li> <li> <p>self Boolean: Retrieve credentials of the provided Identifier. It can be \"true\" or \"false\". </p> </li> <li> <p>query-field String: Retrieve credentials based on the filters applied to the data of the credential. </p> </li> </ul> <p>Note: The \"subject\" and \"self\" filters cannot be applied together. </p> <p>The Issuer Node responds by sending a response message that contains the Verifiable Credential and all the information related to it. The response consists of information related to authclaim (which authorizes the user that requests for credential) and coreclaim (the actual credential issued by an Issuer to the user. Depending on these two claims, the information related to these two may differ in the response body. Here, we are going to provide an overview of some of these fields:</p> <ul> <li> <p><code>Context</code>: URL pointing to the JSON-LD documents that define how credential schema (here we are using BJJAuthCredential) and claim-schema-vocab (here we are using SparseMerkleTreeProof)are defined. </p> </li> <li> <p><code>credentialSchema</code>: URL pointing to the credential schema of type JSON. It could be a schema for <code>authclaim</code> or <code>coreclaim</code>.</p> </li> <li> <p><code>credentialStatus</code>: Shows credentialStatus <code>id</code> (which is the Revocation status of the credential (presence or absence of the revocation nonce value), <code>revocationNonce</code> (zero or any value), <code>type</code>(type of Proof, for example, SparseMerkleTreeProof). </p> </li> <li> <p><code>credentialSubject</code>: contains details of the subject (to whom the credential is issued) and includes the subject's date of birth, claim id, documentType, and other details.</p> <ul> <li><code>type</code>: Type of credential for credentialSubject (AuthBJJCredential or KYCAgeCredential)</li> </ul> </li> <li> <p><code>id</code>: It is the ID of the Verifiable Credential.</p> </li> <li> <p><code>expiration</code>: The date on which the credential shall expire.</p> </li> <li> <p><code>issuer</code>: DID of the Issuer.</p> </li> <li> <p><code>issuanceDate</code>: The date on which the credential was issued by the Issuer.</p> </li> <li> <p><code>proof</code>: The proof that the user creates to prove that s/he is the real owner of the Verifiable Credential issued from the Issuer and that the Verifiable Credential that it holds is valid. It includes:</p> <ul> <li><code>type</code> of proof (for example, BJJSignature2021 or SparseMerkleTreeProof)</li> <li><code>issuerData</code>: It includes the Issuer's <code>id</code> (DID of the Issuer) and its <code>state</code> (value of its claimstreeroot, i.e. root of the claims (credential) tree)</li> <li><code>authclaim</code>: Value of authclaim along with its mtp <code>existence</code> (proof of its existence/non-existence in the Merkle tree) </li> <li><code>coreclaim</code>: Value of coreclaim along with <code>signature</code> (Issuer's signature which verifies that the credential is issued by a valid Issuer). </li> </ul> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-claim-qr-code","title":"Get Claim QR Code","text":"<p>Note: In order to communicate with the Polygon ID Wallet App, the Issuer Node must be hosted on a public URL.</p> <p>Function: Endpoint to generate a JSON which is then used to generate a QR code on a third-party app. The user can then scan this QR code and accept credentials to his/her wallet.  </p> <p>How it Works: The Issuer DID (identifier string retrieved from calling the <code>Create Identity</code> endpoint) and credential Identifier (or <code>cid</code> retrieved from the <code>Create Claim</code> endpoint) are passed as path variables in the request URL. </p> <p>The Issuer Node responds by sending a response message that contains a JSON which carries the following fields:</p> <p><code>credentials</code> contains the credential ID (<code>cid</code>) and a link to the schema associated with the credential.</p> <p><code>url</code> is the address at which the user's wallet makes a call to the endpoint. </p> <p><code>from</code> is the <code>did</code> of the Issuer.</p> <p><code>to</code> is the <code>did</code> of the user's wallet.</p> <p><code>typ</code> and <code>type</code> indicate the way user's wallet interacts with the Node.</p> <p>This JSON can then be pasted on a third-party app's interface that supports generating QR codes. Once a QR code is generated, the user can scan it via Polygon ID app on mobile and accept a credential to his/her wallet. </p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#revoke-claim","title":"Revoke Claim","text":"<p>Function: Endpoint to revoke a Verifiable Credential </p> <p>How it Works: The Issuer DID (The identifier string retrieved from calling the <code>Create Identity</code> endpoint) and <code>nonce</code> of the VC to be revoked (Revocation Nonce) are passed as a path variable in the request URL. </p> <p>The server responds by showing the Revocation Status of the credential.</p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-revocation-status","title":"Get Revocation Status","text":"<p>Function: Endpoint to retrieve the Revocation Status of the Verifiable Credential.  </p> <p>How it Works: The DID (The identifier string retrieved from calling the <code>Create Identity</code> endpoint) and <code>nonce</code> (Revocation Nonce) are passed as a path variable in the request URL. For the credential to be marked \"revoked\", we need to publish the state first on-chain, and then wait for 5 confirmation blocks. </p> <p>The server responds by sending the following details:</p> <ul> <li><code>issuer</code><ul> <li><code>claimstreeRoot</code>: Root of the Claims Merkle Tree of the Issuer</li> <li><code>state</code>: The Issuer's Identity State </li> </ul> </li> <li><code>mtp</code><ul> <li><code>existence</code>: Existence or Non-existence of the Revocation Nonce on the Revocation Merkle Tree. For retrieving the revocation status from this endpoint, we need to first send a transaction and after that, the state is published on-chain. Once that is done, the existence of the revocation nonce on Merkle Tree changes to \"true\".    </li> </ul> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/identity/apis/","title":"Identity","text":""},{"location":"issuer-node/issuer-node-api/identity/apis/#identity","title":"Identity","text":"<p>The identity endpoint is used to create and retrieve identities for a user/issuer. Polygon ID supports the creation of identities in the form of DIDs (Decentralized Identifiers).</p> <p>Note: A DID is a cryptographically verifiable decentralized identifier. How a DID is verified is specified in its DID method. A DID resolves to a DID document that describes how to interact with the DID subject (The user that holds the identity). The DID document contains public keys that are used to authenticate the DID subject. An example of DID resolution could be a verifier resolving an Issuer's DID to get the public key, which is required to verify the signature on a Verifiable Credential. </p> <p>A DID can be represented as: </p><pre><code>did: did method: did method-specific identifier. \n</code></pre> This is a standard form of expressing a Decentralised Identifier as defined by the W3C DID Core 1.0 Specifications <p>A user can have multiple DIDs. </p>"},{"location":"issuer-node/issuer-node-api/identity/apis/#create-identity","title":"Create Identity","text":"<p>Function: Endpoint to create an Identifier for a user/issuer. </p> <p>How it Works: The request to create an identity is sent to the Issuer Node. <code>didMetaData</code> is passed in the request body. This metadata is required to create Issuer's DID.</p> <p>An example of a <code>didMetaData</code> passed in the request body of the <code>Create Identity</code> endpoint is shown below:</p> <p></p><pre><code>{\n    \"didMetadata\":{\n        \"method\": \"polygonid\",\n        \"blockchain\":\"polygon\",\n        \"network\": \"mumbai\"\n    }\n}\n</code></pre> A few variations of the metadata can be: <pre><code>method:\n    \"polygonid\"\n    \"iden3\"\n\nblockchain:\n    \"polygon\"\n    \"eth\"\n\nnetwork:\n    \"main\"\n    \"mumbai\"\n    \"goerli\"\n    \"unknown\"\n</code></pre> <p>The Issuer Node responds by sending a response message that contains:</p> <ul> <li><code>identifier</code>: Identifier of the Issuer in the standard DID format. For example:</li> </ul> <p><code>did:polygonid:polygon:mumbai:2qNBWSAsyvaGBpqQVHk3E4cgChaN6ogaZnYCQUyoRQ</code> </p> <ul> <li><code>identity state</code>: It is the state of the identity and contains fields that include <code>claimsTreeRoot</code> (Verifiable Credentials are added to the Claims Tree and its root is calculated), <code>state</code> (state of identity), and <code>status</code> (whether the status of the identity state is confirmed or pending. <code>identity state</code> also contains the timestamp when the identity was created (<code>createdAt</code>) or updated(<code>modifiedAt</code>). </li> </ul> <p>For each call to the <code>Create Identity</code>, a random Identifier is created. </p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/identity/apis/#get-identities","title":"Get Identities","text":"<p>Function: Endpoint to retrieve all the identities (identifiers) of a user.</p> <p>How it Works: The request to retrieve an identity is sent to the Issuer Node. <code>didMetaData</code> is passed in the request body. </p> <p>The Issuer Node responds by sending a response message that contains:</p> <ul> <li><code>identifier</code>: Identifier of the Issuer in the standard DID format. For example:</li> </ul> <p><code>did:polygonid:polygon:mumbai:2qNBWSAsyvaGBpqQVHk3E4cgChaN6ogaZnYCQUyoRQ</code></p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/identity/apis/#publish-state-on-chain","title":"Publish State On-Chain","text":"<p>Function: Endpoint to publish the Identity State on-chain. </p> <p>How it Works: The identifier string in the DID format (retrieved from calling the <code>Create Identity</code> endpoint) is passed as a path variable in the request URL. </p> <p>The Issuer Node responds by sending a response message that indicates the published state of the Identity. If there is no state to publish, the Node shows the message as: \"no states to process\". If the state is published, the Node sends the following information:</p> <ul> <li> <p><code>claimsTreeRoot</code>: The root of the Claims Merkle Tree. For example, d9c1e213584c4e7f444bdc42a5cdbd038556d1455a8344e3a1451c346461a41d</p> </li> <li> <p><code>revocationTreeRoot</code>: The root of the Revocation Merkle Tree. For example, 0000000000000000000000000000000000000000000000000000000000000000</p> </li> <li> <p><code>rootOfRoots</code>: The root of the Roots Merkle Tree. For example,9b952dab35ed362f62573c7b1bb0ee1e5dcb32109fafacb24c9b335fbddf4f2e</p> </li> <li> <p><code>state</code>: The published state of the Identity. It is calculated by taking the roots of the Claims Tree, Revocation Tree, and Roots Tree. For example, a state could be: 1d9639360ad6e7fb86b8d2f55abd6201cae521e812496cd6606ce36a5829c316</p> </li> <li> <p><code>txID</code>: Transaction ID of the Published state on-chain. For example, 0xaed59e4195e73ee6c4278be1a5e01ecbdf2ff9565511916200dedda9bb20ff38</p> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"js-sdk/js-sdk-browser-wallet-demo/","title":"Browser Wallet Demo","text":""},{"location":"js-sdk/js-sdk-browser-wallet-demo/#demo-for-polygon-id-js-sdk-browser-wallet-extension","title":"Demo for Polygon ID JS SDK Browser Wallet Extension","text":"<p>Polygon ID has created a sample browser wallet extension based on our JS SDK that lets its user fetch credentials from an Issuer and generate proof for these credentials to be presented to a Verifier. </p> <p>You need to manually install the browser wallet extension on your machine. This wallet works like a common crypto wallet such as MetaMask Wallet but differs in functionality. </p> <pre><code>!!! warning\n    Some of the content on this page is still to be updated. Please note that the \"Polygon Verify\" service mentioned in the screenshots has been eliminated. The screenshots illustrate the general process of how the JS SDK wallet extension works.\n</code></pre>"},{"location":"js-sdk/js-sdk-browser-wallet-demo/#demo-for-js-sdk-browser-extension-wallet","title":"Demo for JS SDK Browser Extension Wallet","text":"<ol> <li> <p>Install the Polygon ID JS SDK browser wallet extension on your machine and open it. </p> </li> <li> <p>When you open the extension for the first time, it prompts you to create a new wallet or import an existing wallet. Click Create a New Wallet. </p> <p></p> </li> <li> <p>This shows the Create Password screen. Enter your password and confirm it. Click Create. </p> <p></p> </li> <li> <p>This displays the Polygon Account window on your browser wallet. </p> <p></p> </li> <li> <p>Open the Polygon Verify website (this is like an Issuer site that issues credentials to its users). Click Sign Up. </p> <p></p> </li> <li> <p>A QR Code is displayed. Click Polygon ID icon to open your browser wallet.</p> <p></p> </li> <li> <p>Your wallet shows the Authorization window. Click Approve. </p> <p></p> <p>This shows auth info and claims list on the Polygon Verify site. </p> <p></p> </li> </ol>"},{"location":"js-sdk/js-sdk-browser-wallet-demo/#steps-to-create-and-fetch-credentials","title":"Steps to Create and Fetch Credentials","text":"<ol> <li> <p>On the website, click Create Claim. </p> <p></p>  2. This displays the screen to create claims. <p></p>  3. Select Schema using which you need to create credentials. Enter Schema URL, type of credential required, date of expiration of the credential, and other information related to the credential. (For example for a KYCAgeCredential, we can enter birthdate and DocumentType). Click Submit.  <p></p>  4. After some moments publishing the credential. it is created successfully.    5. As the credential is now created, the user needs to fetch it to his/her browser wallet. The website displays the QR code. Click the Polygon ID icon to open your browser wallet. On the wallet, click Receive. <p></p>  The credential is now saved on your browser wallet.  <p></p> </li> </ol>"},{"location":"js-sdk/js-sdk-browser-wallet-demo/#steps-to-create-kycagecredential-signature-proof","title":"Steps to Create KYCAgeCredential Signature Proof","text":"<ol> <li> <p>On Polygon Verify website, select the KYCAgeCredential(less than 2000/01/01)- sig type of credential. </p> <p></p> </li> <li> <p>Click Sign In. This shows the QR code for the credential type you selected in the step above. Click the Polygon ID icon to open your browser wallet.</p> <p></p> </li> <li> <p>The browser wallet shows the Proof Request window. Here, you can see the type of credential and proof requested. As you have selected the credential based on signature proof, the Proof Type shown here is of the type credentialAtomicQuerySigV2. Click Continue.</p> <p></p> </li> <li> <p>The website verifies your membership successfully.</p> <p></p> </li> <li> <p>On wallet, click KYCAgeCredential to view its details including birthday, documentType, Issuer (DID of Issuer), Issued On (Date of Issuance), Expiration Date, and Proof types (in this case, it is BJJSignature2021)</p> <p></p> </li> <li> <p>On the Polygon Verify website, click Auth Info to view details of the Auth Request (authorization requested by the user). </p> <p></p>  Scroll down the page to view Auth Response. here, you can see the proof and the public signals (used to generate the proof), and the JWZ token. Copy the JWZ token and paste it on the Polygon ID JWZ Validator site. Click Validate. <p></p> <p></p> <p>Upon validation, the JWZ token is broken down into three parts: Header, Payload, and Auth Proof.  </p> <p></p> <p>Header and Payload: </p> <p>Auth Proof: </p> <p>You can see proof along with other data including from and to fields. The from  field shows the DID that sent the proof request. It must match your wallet's DID. The to represents the Verifier DID to whom the proof request has been sent. </p> </li> <li> <p>Wait for the proof to get published on-chain. After that, on the website, you can view the credential details that show state information such as txId (ID of the transaction done from a wallet to complete publishing of the state on-chain), blockTimestamp (time at which block was created), blockNumber, rootofRoots (Roots tree), claimsTreeRoot (Claims tree), revocationTreeRoot(Revocation tree): </p> <p></p> <p>Credential details: </p> </li> <li> <p>Below the QR code, click the Polygon ID icon to open your browser wallet. On your wallet, click Receive to fetch and save the credential to your wallet. </p> <p></p> <p>Click on your KYCAgeCredential to view its details. You can now see that you have two types of proofs in your wallet: BJJSignature2021 and iden3SparseMerkleTreeProof </p> <p></p> </li> </ol>"},{"location":"js-sdk/js-sdk-browser-wallet-demo/#steps-to-create-kycagecredential-merkle-tree-proof","title":"Steps to Create KYCAgeCredential Merkle Tree Proof","text":"<ol> <li> <p>On the Polygon Verify website, select the KYCAgeCredential(less than 2000/01/01)- mtp type of credential.      </p> </li> <li> <p>Click Sign In. This shows the QR code for the credential type you selected in the step above. Click the Polygon ID icon to open your browser wallet.</p> <p></p> </li> <li> <p>The browser wallet shows the Proof Request window. Here, you can see the type of credential and proof requested. As you have selected the credential based on MTP proof, the Proof Type shown here is credentialAtomicQueryMTPV2. Click Continue.</p> <p></p> </li> <li> <p>The website verifies your membership successfully.     </p> <p></p> </li> <li> <p>On the Polygon Verify website, click Auth Info to view details of the Auth Request (authorization requested by the user). </p> <p>Scroll down the page to view Auth Response. Here, you can see the proof, the public signals (used to generate the proof), and the JWZ token. Copy the JWZ token and paste it on the Polygon ID JWZ Validator site. Click Validate. </p> <p>Upon validation, the JWZ token is broken down into three parts: Header, Payload, and Auth Proof.  </p> <p></p> <p></p> <p>Header and Payload: </p> <p> </p> <p>Auth Proof: </p> <p>You can see proof (CredentialAtomicQueryMTPV2) along with the other data including from and to fields. The from  field shows the DID that sent the proof request. It must match your wallet's DID. The to represents the Verifier DID to whom the proof request has been sent. </p> </li> <li> <p>Wait for the proof to get published on-chain. Post that, on the website, you can view the credential details that show state information such as txId (id of the transaction done from a wallet to complete publishing of the state on-chain), blockTimestamp (time at which block was created), blockNumber, rootofRoots (Roots tree), claimsTreeRoot (Claims tree), revocationTreeRoot(Revocation tree): </p> <p></p> <p>Credential details: </p> </li> <li> <p>Below the QR code, click the Polygon ID icon to open your browser wallet. On your wallet, click Receive to fetch and save the credential to your wallet. </p> <p></p> </li> </ol>"},{"location":"js-sdk/js-sdk-example/","title":"Example","text":""},{"location":"js-sdk/js-sdk-example/#js-sdk-example","title":"JS SDK Example","text":"<p>This tutorial shows the steps to run different modules of the Polygon ID JS SDK with exampling code. After the steps for each module, you will find a sample output which is generated when these modules are run.</p>"},{"location":"js-sdk/js-sdk-example/#steps-to-run-example-code","title":"Steps to Run Example Code","text":"<p>We have created a JS SDK Example repository that you can download and run. Follow these steps:</p> <ol> <li> <p>Download the latest circuits  from the following curl command:</p> <pre><code>curl https://iden3-circuits-bucket.s3.eu-west-1.amazonaws.com/latest.zip --output latest.zip\n</code></pre> <p>where s3 is a bucket that has been created for storing the circuits' data in one of the Amazon Simple Storage Service (Amazon S3) for specific regions across the globe.</p> <p>The <code>latest.zip</code> folder is accessed from the s3 bucket and is the output to the local <code>latest.zip</code> file.  </p> <p>Unzip the <code>latest.zip</code> folder downloaded above to the <code>circuits</code> folder in the repository:</p> <pre><code>unzip latest.zip -d circuits\n</code></pre> </li> <li> <p>To run the scripts, set the values for the following variables:</p> <pre><code>export WALLET_KEY=\"...key in hex format with matic balance\"\nexport RPC_URL=\"...url to polygon mumbai network rpc node\"\nexport RHS_URL=\"..reverse hash service url\"\nexport CONTRACT_ADDRESS=\"..state v2 contract address in the mumbai network\"\nexport CIRCUITS_PATH=\"..path to the circuits folder\"\n</code></pre> </li> <li> <p>Run the npm command. For this, Node.js (which contains the npm package) must be installed on your system.</p> <pre><code>  npm run start\n</code></pre> </li> </ol>"},{"location":"js-sdk/js-sdk-example/#example-identity-creation","title":"Example: Identity Creation","text":"<ol> <li> <p>Initialize <code>DataStorage</code>: To initialize <code>DataStorage</code>, we need a new <code>CredentialStorage</code>, which could be as simple as a Memory Data Storage (<code>InMemoryDataSource</code>). Using Memory Data Storage for new credential storage is not recommended for the production environment. Instead, we could use Browser Data Storage or any other data storage.</p> <pre><code>const dataStorage = {\ncredential: new CredentialStorage(new InMemoryDataSource&lt;W3CCredential&gt;()),\nidentity: new IdentityStorage(\n  new InMemoryDataSource&lt;Identity&gt;(),\n  new InMemoryDataSource&lt;Profile&gt;()\n),\nmt: new InMemoryMerkleTreeStorage(40),\nstates: new EthStateStorage(defaultEthConnectionConfig),\n};\n</code></pre> <p>Note</p> <p>The <code>CredentialStorage</code> accepts the interface of the Data Storage; it does not require Memory or Browser Storage. You can implement your own storage, be it  SQL storage or any other type of storage.</p> <p><code>IdentityStorage</code> stores identities and profiles. <code>mt</code> stores Merkle Trees. <code>states</code> stores Ethereum states of identities.</p> </li> <li> <p>Initialize  <code>CredentialWallet</code> and  <code>IdentityWallet</code>: To initialize Identity Wallet, we need <code>dataStorage</code>, and <code>kms</code> (Key Management System).</p> <pre><code>const memoryKeyStore = new InMemoryPrivateKeyStore();\nconst bjjProvider = new BjjProvider(KmsKeyType.BabyJubJub, memoryKeyStore);\nconst kms = new KMS();\nkms.registerKeyProvider(KmsKeyType.BabyJubJub, bjjProvider);\n\nconst statusRegistry = new CredentialStatusResolverRegistry();\nstatusRegistry.register(\n  CredentialStatusType.SparseMerkleTreeProof,\n  new IssuerResolver()\n);\nstatusRegistry.register(\n  CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n  new RHSResolver(dataStorage.states)\n);\nconst credWallet = new CredentialWallet(dataStorage,statusRegistry);\nconst wallet = new IdentityWallet(kms, dataStorage, credWallet);\n</code></pre> <p>For <code>kms</code>, we need to define a <code>provider</code> that works with keys. For example, we can provide a Baby Jubjub Provider (<code>BJJProvider</code>) or an Ethereum Key Provider, or a Register Key Provider(<code>registerKeyProvider</code>), to name a few. For each Provider, we need to pass the storage: <code>AbstractPrivateKeyStore</code>. This storage allows you to create customized encrypted storage. For demo purposes, we have used <code>memoryKeyStore</code>. So in a nutshell, we create storage(<code>memoryKeyStore</code>), pass it to the Provider(<code>BJJProvider</code>), and register this Provider in Key Management System(<code>registerKeyProvider</code>).</p> </li> <li> <p>After initialization is complete, to create identity, we need to pass some options, which are accepted by the <code>IdentityCreationOptions</code> interface. The options are as follows:</p> </li> </ol> <pre><code>export interface IdentityCreationOptions {\n  method?: DidMethod;\n  blockchain?: Blockchain;\n  networkId?: NetworkId;\n  revocationOpts: {\n    id: string;\n    type: CredentialStatusType;\n    nonce?: number;\n  };\n  seed?: Uint8Array;\n}\n</code></pre> <p>For example:</p> <pre><code>const seedPhrase: Uint8Array = byteEncoder.encode('seedseedseedseedseedseedseedseed');\n\nconst { did, credential } = await wallet.createIdentity({\n  method: DidMethod.Iden3,\n  blockchain: Blockchain.Polygon,\n  networkId: NetworkId.Mumbai,\n  seed: seedPhrase,\n  revocationOpts: {\n    type: CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n    id: 'https://rhs-staging.polygonid.me'\n  }\n});\n    ```\n    ```\n  - If we do not use `rhsUrl` within createIdentity() method, we get a `credentialStatus` with a URL as `id`, which contains an API to fetch the revocation status. Also, in this case, the `type` of the `credentialStatus` is `SparseMerkleTreeProof`.\n</code></pre> <ul> <li>If we do not use <code>rhsUrl</code> within createIdentity() method, we get a <code>credentialStatus</code> with a URL as <code>id</code>, which contains an API to fetch the revocation status. Also, in this case, the <code>type</code> of the <code>credentialStatus</code> is <code>SparseMerkleTreeProof</code>.</li> </ul> <p>Note</p> <p><code>revocationOpts</code> should provide info on how to fetch the status of a credential. If we use <code>CredentialStatusType.Iden3ReverseSparseMerkleTreeProof</code> within createIdentity() method, we get a <code>credentialStatus</code> with a Reverse Hash Service URL (<code>rhsUrl</code>) as <code>id</code>, which, upon running on a browser, shows a response that contains information about the identity state. If we use <code>CredentialStatusType.Iden3SparseMerkleTreeProof</code> within createIdentity() method, we get a <code>credentialStatus</code> with a URL as <code>id</code>, which contains an API to fetch the revocation status.</p>"},{"location":"js-sdk/js-sdk-example/#example-issue-credential","title":"Example: Issue Credential","text":""},{"location":"js-sdk/js-sdk-example/#initialize-all-storage-types","title":"Initialize all storage types","text":"<pre><code>const dataStorage = {\n  credential: new CredentialStorage(new InMemoryDataSource&lt;W3CCredential&gt;()),\n  identity: new IdentityStorage(\n    new InMemoryDataSource&lt;Identity&gt;(),\n    new InMemoryDataSource&lt;Profile&gt;()\n  ),\n  mt: new InMemoryMerkleTreeStorage(40),\n  states: new EthStateStorage(defaultEthConnectionConfig),\n};\nconst memoryKeyStore = new InMemoryPrivateKeyStore();\nconst bjjProvider = new BjjProvider(KmsKeyType.BabyJubJub, memoryKeyStore);\nconst kms = new KMS();\nkms.registerKeyProvider(KmsKeyType.BabyJubJub, bjjProvider);\nconst credWallet = new CredentialWallet(dataStorage);\nconst statusRegistry = new CredentialStatusResolverRegistry();\nstatusRegistry.register(\n  CredentialStatusType.SparseMerkleTreeProof,\n  new IssuerResolver()\n);\nstatusRegistry.register(\n  CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n  new RHSResolver(dataStorage.states)\n);\nstatusRegistry.register(\n  CredentialStatusType.Iden3OnchainSparseMerkleTreeProof2023,\n  new OnChainResolver([defaultEthConnectionConfig])\n);\n resolvers.register(\n CredentialStatusType.Iden3commRevocationStatusV1,\n new AgentResolver()\n );\n\nconst credWallet = new CredentialWallet(dataStorage,statusRegistry);\nconst wallet = new IdentityWallet(kms, dataStorage, credWallet);\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#create-issuers-identity","title":"Create Issuer's Identity","text":"<pre><code>const seedPhraseIssuer: Uint8Array = byteEncoder.encode('seedseedseedseedseedseedseedseed');\nconst { did: issuerDID, credential: issuerAuthCredential } = await wallet.createIdentity({\n  method: DidMethod.Iden3,\n  blockchain: Blockchain.Polygon,\n  networkId: NetworkId.Mumbai,\n  seed: seedPhraseIssuer,\n  revocationOpts: {\n    type: CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n    id: 'https://rhs-staging.polygonid.me'\n  }\n});\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#create-users-identity","title":"Create User's Identity","text":"<pre><code>const seedPhraseUser: Uint8Array = byteEncoder.encode('userseedseedseedseedseedseeduser');   \nconst { did: userDID, credential: authBJJCredentialUser } = await identityWallet.createIdentity({\n  method: DidMethod.Iden3,\n  blockchain: Blockchain.Polygon,\n  networkId: NetworkId.Mumbai,\n  seed: seedPhraseUser,\n  revocationOpts: {\n    type: CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n    id: 'https://rhs-staging.polygonid.me'\n  }\n});\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#create-credential-request-credentialrequest-and-issue-credential-issuecredential","title":"Create Credential Request (<code>credentialRequest</code>) and  Issue Credential (<code>issueCredential</code>):","text":"<pre><code>const claimReq: CredentialRequest = {\n  credentialSchema:\n    'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v2.json',\n  type: 'KYCAgeCredential',\n  credentialSubject: {\n    id: userDID.toString(),\n    birthday: 19960424,\n    documentType: 99\n  },\n  expiration: 12345678888,\n  revocationOpts: {\n    type: CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n    id: 'https://rhs-staging.polygonid.me'\n  }\n};\nconst issuerCred = await wallet.issueCredential(issuerDID, claimReq);\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#output-of-run-command","title":"Output of Run Command","text":"<pre><code>{\n  \"id\": \"urn:ad777d04-15e9-42ad-bc31-f8acd7191439\",\n  \"@context\": [\n    \"https://www.w3.org/2018/credentials/v1\",\n    \"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld\",\n    \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\"\n  ],\n  \"type\": [\n    \"VerifiableCredential\",\n    \"KYCAgeCredential\"\n  ],\n  \"expirationDate\": \"2361-03-21T19:14:48.000Z\",\n  \"issuanceDate\": \"2023-04-26T18:54:26.210Z\",\n  \"credentialSubject\": {\n    \"id\": \"did:iden3:polygon:mumbai:wzwAyDLHL6Nhtj3TnFfUnP7osASXb9hS8BTfa2zeo\",\n    \"birthday\": 19960424,\n    \"documentType\": 99,\n    \"type\": \"KYCAgeCredential\"\n  },\n  \"issuer\": \"did:iden3:polygon:mumbai:wzokvZ6kMoocKJuSbftdZxTD6qvayGpJb3m4FVXth\",\n  \"credentialSchema\": {\n    \"id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v2.json\",\n    \"type\": \"JsonSchemaValidator2018\"\n  },\n  \"credentialStatus\": {\n    \"id\": \"https://rhs-staging.polygonid.me\",\n    \"revocationNonce\": 4303,\n    \"type\": \"Iden3ReverseSparseMerkleTreeProof\"\n  },\n  \"proof\": [\n    {\n      \"type\": \"BJJSignature2021\",\n      \"issuerData\": {\n        \"id\": \"did:iden3:polygon:mumbai:wzokvZ6kMoocKJuSbftdZxTD6qvayGpJb3m4FVXth\",\n        \"state\": {\n          \"rootOfRoots\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n          \"revocationTreeRoot\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n          \"claimsTreeRoot\": \"6091193ec58a6c020183c2d889a92c32410f31812595f228d67a2bf37e04a729\",\n          \"value\": \"ed17a07e8b78ab979507829fa4d37e663ca5906714d506dec8a174d949c5eb09\"\n        },\n        \"authCoreClaim\": \"cca3371a6cb1b715004407e325bd993c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bd045c3101b2a0bcd60106ff21a680d86af3dbbdec406764f93ab82849410e1c27eb6114eeff7eb030b34d1db28b46d61cb6d7efbec190a0b1c1664664ced80f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        \"mtp\": {\n          \"existence\": true,\n          \"siblings\": []\n        },\n        \"credentialStatus\": {\n          \"id\": \"https://rhs-staging.polygonid.me\",\n          \"revocationNonce\": 0,\n          \"type\": \"Iden3ReverseSparseMerkleTreeProof\"\n        }\n      },\n      \"coreClaim\": \"c9b2370371b7fa8b3dab2a5ba81b68380a00000000000000000000000000000001127b7c7c774b5b5f3bc93a653ccdfbb52d748efb2062f00be85c3117910c0068923001000000000000000000000000000000000000000000000000000000006300000000000000000000000000000000000000000000000000000000000000cf10000000000000281cdcdf0200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n      \"signature\": \"ede3a863f234a29a0e2bb80746c37f4f1cfbe2cb0d1c0668d44b6a69ea7b1b110008effb865ffde590ccaf52a16c7188eaa79a52dcf2ab2baa5145e618526b05\"\n    }\n  ]\n}\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#example-generate-proof","title":"Example: Generate Proof","text":"<ol> <li> <p>Initialize all storages including <code>dataStorage</code>, <code>identityWallet</code>, <code>credentialWallet</code>, <code>circuitStorage</code>, and <code>stateStorage</code>.</p> <p></p><pre><code>const proofService: IProofService = new ProofService(idWallet, credentialWallet, circuitStorage, stateStorage,{ ipfsNodeURL: \"https://ipfs.io\" });\n</code></pre>   Ipfs node option is mandatory if your are going to support schemas with <code>ipfs://</code> prefix </li> <li> <p>Create Issuer's Identity</p> </li> <li> <p>Create User's Identity</p> </li> <li> <p>Create Credential Request (<code>credentialRequest</code>):</p> <pre><code>const claimReq: CredentialRequest = {\n  credentialSchema:\n    'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v2.json',\n  type: 'KYCAgeCredential',\n  credentialSubject: {\n    id: userDID.toString(),\n    birthday: 19960424,\n    documentType: 99\n  },\n  expiration: 1693526400,\n  revocationOpts: {\n    type: CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n    id: rhsUrl\n  }\n};\n</code></pre> </li> <li> <p>Issue Credential (<code>issueCredential</code>):</p> <pre><code>const issuerCred = await idWallet.issueCredential(issuerDID, claimReq);\n</code></pre> </li> <li> <p>Save Credential(<code>saveCredential</code>):</p> <pre><code>await credWallet.save(issuerCred);\n</code></pre> </li> <li> <p>Add Credentials to Merkle Tree (<code>addCredentialsToMerkleTree</code>) AtomicQueryMTPV2 circuit only :</p> <pre><code>const res = await identityWallet.addCredentialsToMerkleTree(\n[credential],\nissuerDID\n);\n</code></pre> </li> <li> <p>Publish state to Reverse Hash Service(<code>publishStateToRHS</code>) and then to blockchain AtomicQueryMTPV2 circuit only.</p> <pre><code>await identityWallet.publishStateToRHS(issuerDID, rhsUrl);\n</code></pre> <pre><code>const ethSigner = new ethers.Wallet(\nwalletKey,\n(dataStorage.states as EthStateStorage).provider\n);\n</code></pre> </li> <li> <p>Transit State(<code>transitState</code>) AtomicQueryMTPV2 circuit only:</p> <pre><code>const txId = await proofService.transitState(\nissuerDID,\nres.oldTreeState,\ntrue,\ndataStorage.states,\nethSigner\n);\n</code></pre> <p>The transaction ID(<code>txId</code>) is sent to the network.</p> <pre><code>console.log(txId);\n</code></pre> </li> <li> <p>Generate Proof for <code>ZeroKnowledgeProofRequest</code>. It uses the AtomicQuerySignV2 as the <code>CircuitId</code>.</p> </li> <li> <p>Processe Proof Request:</p> </li> </ol> <pre><code>const proofReq: ZeroKnowledgeProofRequest = {\n  id: 1,\n  circuitId: CircuitId.AtomicQueryMTPV2,\n  optional: false,\n  query: {\n    allowedIssuers: ['*'],\n    type: claimReq.type,\n    context:\n      'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld',\n    credentialSubject: {\n      documentType: {\n        $eq: 99\n      }\n    }\n  }\n};\n</code></pre> <ul> <li>Generate Signature Proof</li> </ul> <pre><code>const { proof, vp } = await proofService.generateProof(proofReq, userDID);\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#output-of-run-command_1","title":"Output of Run Command","text":"<pre><code>{\n  \"id\": 1,\n  \"circuitId\": \"credentialAtomicQueryMTPV2\",\n  \"proof\": {\n    \"pi_a\": [\n      \"16903932334113972519620805189645165148033763067456532043354702748765998282694\",\n      \"14387051041597563972727770449725265194885403144389811266303574540189693314411\",\n      \"1\"\n    ],\n    \"pi_b\": [\n      [\n        \"20868744201672807105014844766210388217012962602503565070866599032913314573906\",\n        \"3442846801677856242390734660759775202706413077249960437242009573082897426768\"\n      ],\n      [\n        \"14789189402469891892456734204272864393275089998933018165654790589080248398029\",\n        \"18266210435012639289361922267811624205740064923904412505788791153792745549864\"\n      ],\n      [\n        \"1\",\n        \"0\"\n      ]\n    ],\n    \"pi_c\": [\n      \"10584826769880435007204063174646630112221834067523356507551322322080614020116\",\n      \"15098609038306685045480544545659718185382866226369358624875087099910401452336\",\n      \"1\"\n    ],\n    \"protocol\": \"groth16\",\n    \"curve\": \"bn128\"\n  },\n  \"pub_signals\": [\n    \"1\",\n    \"21568225469889458305914841490175280093555015071329787375641431262509208065\",\n    \"1\",\n    \"19898531390599208021876718705689344940605246460654065917270282371355906561\",\n    \"11294568480342416193654942432097549342373955797199827794411652699521935875647\",\n    \"1\",\n    \"15316103435703269893947162180693935798669021972402205481551466808302934202991\",\n    \"1682538797\",\n    \"74977327600848231385663280181476307657\",\n    \"0\",\n    \"17040667407194471738958340146498954457187839778402591036538781364266841966\",\n    \"2\",\n    \"1\",\n    \"99\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\",\n    \"0\"\n  ]\n}\n</code></pre>"},{"location":"js-sdk/js-sdk-example/#example-verify-proof","title":"Example: Verify Proof","text":"<ol> <li> <p>Once the proof is generated, Verifier can verify the proof (Signature or MTP).</p> </li> <li> <p>Verify Proof:</p> </li> </ol> <pre><code>const sigProofOk = await proofService.verifyProof(\n  proof,\n  CircuitId.AtomicQuerySigV2 // or CircuitId.AtomicQueryMTPV2\n);\n</code></pre>"},{"location":"js-sdk/js-sdk-overview/","title":"Overview","text":""},{"location":"js-sdk/js-sdk-overview/#js-sdk-overview","title":"JS SDK Overview","text":"<p>The Polygon ID JS SDK is a Software Development Kit created in JavaScript. Based on the Iden3 core protocol libraries, it is used for interacting with REST APIs and developing browser-based applications.</p> <p>The Polygon ID JS SDK allows developers to create applications like mobile or web wallets, browser extensions, and issuer nodes. Using this SDK developers can start creating and issuing verifiable credentials, and generate zero knowledge proofs based on our Iden3 protocol. Individuals and organizations can use this SDK for their existing applications.</p> <p>Note</p> <p>With JS SDK, you can build custom applications/modules by providing your implementation of our core interfaces. The functionalities that we provide in these tutorials can be extended as per your requirements. For example, JS SDK does not provide a codebase for database storage but you can implement that by extending SDK's functionality.</p>"},{"location":"js-sdk/js-sdk-overview/#why-js-sdk","title":"Why JS SDK?","text":"<p>The Polygon ID JS SDK has been developed to provide the following functionalities for a user's browser-based wallet:</p> <ul> <li>Create and manage Identity wallet</li> <li>Issue and manage credentials</li> <li>Generate zero-knowledge proofs after credential issuance</li> <li>Publish the updated state of the Issuer once a credential is added to the claims Merkle tree.</li> <li>Handle authorization requests</li> </ul>"},{"location":"js-sdk/js-sdk-overview/#components-of-js-sdk","title":"Components of JS SDK","text":"<p>The following components form the inherent part of the JS SDK:</p> <ul> <li>Identity Wallet</li> <li>Credential Wallet</li> <li>Iden3comm (Authentication Handler/Fetch Handler)</li> <li>Proof Generation</li> </ul> <p>In the upcoming tutorials, we shall read more about the implementation of these components in JS SDK. To know what each of these components stands for, go through the following links:</p> <ul> <li> <p>Identity Wallet</p> </li> <li> <p>Credential Wallet</p> </li> <li> <p>Iden3comm</p> </li> <li> <p>Proof</p> </li> </ul>"},{"location":"js-sdk/js-sdk-overview/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Node.js must be installed on your system. Version 16.14 or above is required for Polygon ID JS SDK.</p> <p>Note</p> <p>While installing Node.js, make sure that you select all the checkboxes related to the dependencies.</p> </li> <li> <p>A browser where you can install and manage your browser wallet.</p> </li> </ul>"},{"location":"js-sdk/js-sdk-overview/#dependencies","title":"Dependencies","text":"<p>You can install project dependencies using either of the following ways:</p> <ul> <li>Using npm:</li> </ul> <pre><code>npm install @0xpolygonid/js-sdk\n</code></pre> <ul> <li>For browser-based applications, you can use the following script tag, adding import to your index.html file after <code>npm run build</code>:</li> </ul> <pre><code>&lt;script src=\"./dist/umd/index.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    const {\n    LocalStoragePrivateKeyStore,\n    IdentityStorage,\n    MerkleTreeLocalStorage,\n    CredentialStorage,\n    W3CCredential,\n    BrowserDataSource,\n    BjjProvider,\n    KmsKeyType,\n    IdentityWallet,\n    CredentialWallet,\n    KMS,\n    core,\n    CredentialStatusType\n} = PolygonIdSdk;\n&lt;/script&gt;\n</code></pre>"},{"location":"js-sdk/js-sdk-overview/#core-libraries","title":"Core Libraries","text":"<p>JS SDK is a fully-functional wrapper on top of our Iden3 core libraries. The following set of core Iden3 libraries has been used to implement Polygon ID JS SDK:</p> <ul> <li> <p>Iden3 JS Crypto: Implementation of the Elliptic Curve for Baby Jubjub Key, Poseidon hash and other cryptographic elements.</p> </li> <li> <p>JS Iden3 Core: JavaScript implementation of the Iden3 core functionalities including Identity creation.</p> </li> <li> <p>JS JSON-LD Merklization: A library that merkelizes JSON-LD documents in JavaScript. Merklization is a process that creates a Merkle tree of a JSON-LD document so that it can be verified for its data integrity and authenticity. It is a library that lets you work with Verifiable Credentials. A JSON-LD is a schema document that represents data fields related to a Verifiable Credential in a pre-determined format.</p> </li> <li> <p>JS JWZ: JavaScript implementation of JSON Web Zero Knowledge and lets you create JWZ tokens.</p> </li> <li> <p>JS Merkle TreeJavaScript implementation for creating a Sparse Merkle Tree (SMT). It carries code implementation for the browser, local storage, and memory.</p> </li> </ul> <p>Info</p> <p>Follow the links below to know more about W3C standards for DID (Decentralised Identifier) and Verifiable Credentials:</p> <ul> <li>DID</li> <li>Verifiable Credentials</li> </ul>"},{"location":"js-sdk/js-sdk-overview/#what-can-be-built-upon-js-sdk","title":"What Can Be Built Upon JS SDK?","text":"<p>On the Polygon ID JS SDK, you can build the following functionalities:</p> <ul> <li>An Issuer on a Merkle Tree</li> <li>A Verifier that can verify zero-knowledge proofs generated by a user's identity wallet</li> <li>An Identity Wallet based on the Iden3 core protocol</li> <li>The JS SDK also provides a revocation feature for credentials and proof generation</li> </ul> <p></p> <p>Note</p> <p>As our JS SDK is still in the public beta stage, you might find a few functionalities missing or not fully updated.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/","title":"Credential Wallet","text":""},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#credential-wallet","title":"Credential Wallet","text":"<p>A Credential Wallet holds the credentials issued by the Issuer. The Credential Wallet is implemented with a Credential Interface that lets you interact with credential storage.</p> <p>The methods described below let you create and manage a credential wallet:</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#get-list-of-credentials-with-list-method","title":"Get List of Credentials with list() method","text":"<p>This method retrieves a set of Verifiable Credentials in the W3C format:</p> <pre><code>list(): Promise&lt;W3CCredential[]&gt;;\n</code></pre> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#save-credentials-with-save-method","title":"Save Credentials with save() method","text":"<p>This method saves the W3C Credentials to the database using upsert.</p> <pre><code>save(credential: W3CCredential): Promise&lt;void&gt;;\n</code></pre> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#save-all-credentials-with-saveall-method","title":"Save All Credentials with saveAll() method","text":"<p>This method saves a batch of W3C Credentials to the database using upsert.</p> <pre><code>saveAll(credentials: W3CCredential[]): Promise&lt;void&gt;;\n</code></pre> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#remove-credential-with-remove-method","title":"Remove Credential with remove() method","text":"<p>This method removes a W3C credential from data storage.</p> <pre><code>remove(id: string): Promise&lt;void&gt;;\n</code></pre> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#find-credentials-with-query-with-findbyquery-method","title":"Find Credentials with Query with findByQuery() method","text":"<p>This method lets you find credentials using Iden3 protocol's query language.</p> <pre><code>findByQuery(query: ProofQuery): Promise&lt;W3CCredential[]&gt;;\n</code></pre> <p>where <code>ProofQuery</code> can contain parameters including: <code>allowedIssuers</code> (Issuers that are allowed to issue a credential),</p> <p><code>claimId</code>(ID of the credential issued), </p> <p><code>credentialSubjectId</code>(ID of the subject of the credential to whom a credential is issued), </p> <p><code>type</code> (type of credential issued), </p> <p><code>schema</code>(json schema used to create a credential), </p> <p><code>credentialSubject</code>(subject of the credential to whom a credential is issued). </p> <p>This credential is then used to create a proof.</p> <pre><code>export interface ProofQuery {\n  allowedIssuers?: string[];\n  credentialSubject?: { [key: string]: unknown };\n  schema?: string; // string url\n  claimId?: string;\n  credentialSubjectId?: string;\n  context?: string;\n  type?: string;\n}\n</code></pre> <p>Read more on Query Langauge here.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#retrieve-auth-bjj-credential-with-getauthbjjcredential-method","title":"Retrieve Auth BJJ Credential with getAuthBJJCredential() method","text":"<p>This method allows you to retrieve a credential of Auth BJJ type for a specific user so that it can be used for signing.</p> <pre><code> getAuthBJJCredential(did: DID): Promise&lt;W3CCredential&gt;;\n</code></pre> <p>where <code>did</code> is the DID of the issuer that has issued the credential</p> <p>This method returns a Verifiable Credential of the type Auth BJJ.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#get-revocation-status-for-a-credential-with-getrevocationstatusfromcredential-method","title":"Get Revocation Status for a Credential with getRevocationStatusFromCredential() method","text":"<p>This method retrieves or builds revocation status for a given credential.</p> <pre><code>getRevocationStatusFromCredential(cred: W3CCredential): Promise&lt;RevocationStatus&gt;;\n</code></pre> <p>where <code>cred</code> is the Credential for which revocation status is to be retrieved.</p> <p>The method returns a revocation status of the credential (a credential is revoked or not). The credential status could be either the SparseMerkleTreeProof or Iden3ReverseSparseMerkleTreeProof (if Reverse Hash Service is used) type.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#get-revocation-status-depending-on-type-of-credential-status-with-getrevocationstatus-method","title":"Get Revocation Status Depending on Type of Credential Status with getRevocationStatus() method","text":"<p>This method retrieves revocation status for a given credential depending on the type of its credential status.</p> <p></p><pre><code> /**\n   * \n   *\n   * @param {(CredentialStatus )} credStatus - credentialStatus field of the Verifiable Credential.\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions - options to resolve credential status\n   * @returns `Promise&lt;RevocationStatus&gt;`\n   */\n  getRevocationStatus(\n    credStatus: CredentialStatus,\n    credentialStatusResolveOptions?: CredentialStatusResolveOptions\n  ): Promise&lt;RevocationStatus&gt;;\n</code></pre> where <code>credStatus</code> is the credential status type: with or without Reverse Hash Service / Agent / Onchain. <code>credentialStatusResolveOptions</code> are    <code>issuerDID</code> is the DID of the Issuer.   <code>userDID</code> is the DID of the user who retrieves status.   <code>issuerData</code> is the metadata related to an Issuer. This metadata is contained in either the Signature Proof (BJJ Signature Proof) or Iden3SparseMerkleTreeProof (Merkle Tree Proof). <p>The method returns the revocation status of the credential (a credential is revoked or not).</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/credential/credential-wallet/#create-a-credential-using-createcredential-method","title":"Create a Credential using createCredential() method","text":"<p>This method creates a Verifiable Credential of W3C format.</p> <pre><code>  createCredential(issuer: DID, request: CredentialRequest, schema: JSONSchema): W3CCredential;\n</code></pre> <p>where <code>Issuer</code> is the DID of the Issuer. <code>request</code> is the specification for the credential creation parameters. <code>schema</code> is the JSON schema used for creating a credential.</p> <p>The method returns a Verifiable Credential in the W3C format.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/","title":"Iden3comm","text":""},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/#iden3comm","title":"Iden3Comm","text":"<p>Iden3comm is the implementation of the messages that exist in the Iden3protocol. It deals with different protocol message types; a few messages supported by the protocol are related to authentication, credential, proof, and revocation.</p>"},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/#packers","title":"Packers","text":"<p>Iden3comm supports packers that receive some data as payload and create an envelope for different types of messages.</p> <p>The Iden3 protocol supports packers for messages of 2 media types: plain messages and zero-knowledge proof (ZKP) messages. These packers let you generate a token.</p>"},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/#zkp-packer","title":"ZKP Packer","text":"<p>For the messages of the type ZKP, the packer receives payload (a serialized message) and ZKP parameters (the sender's DID and profile nonce) as input parameters and generates a JSON Web Zero-knowledge (JWZ) Token.</p> <pre><code> async pack(payload: Uint8Array, params: ZKPPackerParams): Promise&lt;Uint8Array&gt; {\n    const provingMethod = await getProvingMethod(params.provingMethodAlg);\n    const { provingKey, wasm, dataPreparer } = this.provingParamsMap.get(\n      params.provingMethodAlg.toString()\n    );\n\n    const token = new Token(\n      provingMethod,\n      byteDecoder.decode(payload),\n      (hash: Uint8Array, circuitID: CircuitId) =&gt; {\n        return dataPreparer.prepare(hash, params.senderDID, circuitID);\n      }\n    );\n    token.setHeader(Header.Type, MediaType.ZKPMessage);\n    const tokenStr = await token.prove(provingKey, wasm);\n    return byteEncoder.encode(tokenStr);\n  }\n</code></pre>"},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/#handler","title":"Handler","text":"<p>In Iden3, a handler manages the packers described above. There are two types of handlers that the protocol supports: Authentication and Fetch Handlers.</p>"},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/#authentication-handler","title":"Authentication Handler","text":"<p>The following steps show how the Authorization Handler works:</p> <ol> <li> <p>Before the token generation, the handler can unpack the authorization message, so the user can choose the DID to log in with. (it can be private profile or public identity)</p> <pre><code>parseAuthorizationRequest(request: Uint8Array): Promise&lt;AuthorizationRequestMessage&gt;;\n</code></pre> <p>Click here for the API Reference.</p> </li> <li> <p>Then, it handles authorization request protocol messages and generates a token.</p> <pre><code>handleAuthorizationRequest(\n    did: DID,\n    request: Uint8Array,\n    opts?: AuthHandlerOptions\n  ): Promise&lt;{\n    token: string;\n    authRequest: AuthorizationRequestMessage;\n    authResponse: AuthorizationResponseMessage;\n  }\n</code></pre> </li> </ol> <p>It gets the payload and an identity (that can handle that request) as the input parameters, and returns a token, authorization request, and authorization response.  </p> <p>Click here for the API Reference.</p> <p>Note</p> <p>When a user logs into a Verifier, it does not have to share its identity. Instead, it can share with it the profile as the user does not receive a credential on his/her identifier but on his/her profile. Sharing one's profile instead of his/her identity prevents the possible identity tracking by a Verifier. </p>"},{"location":"js-sdk/js-sdk-components/iden3comm/iden3comm/#fetch-handler","title":"Fetch Handler","text":"<p>The Fetch Handler handles the Credential Offer message and returns the fetched credential.</p> <pre><code>handleCredentialOffer(\n    offer: Uint8Array,\n    opts?: FetchHandlerOptions\n  ): Promise&lt;W3CCredential[]&gt;\n</code></pre> <p>The offer should just be passed to the function. The DID that is supposed to fetch the credential will be determined from the offer message itself. </p> <p><code>offer</code> is the offer message that the Fetch handler receives.</p> <p>The handler returns a Verifiable Credential in the W3C format.</p> <p>Read more about iden3comm here.</p> <p>Click here for the API Reference.</p> <p>if you want to work with JWS instead of JWZ technology during the authorization or credential fetching you need to pass parameters to these functions.</p> <p></p><pre><code>let params = {\n  mediaType: MediaType;\n  packerOptions?: JWSPackerParams;\n}\n</code></pre> where <code>mediaType</code> is the media type of iden3comm protocol and <code>packerOptions</code> are JWS required parameters."},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/","title":"Identity Wallet","text":""},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#identity-wallet","title":"Identity Wallet","text":"<p>An identity wallet holds the identity of the user and carries the following components:</p> <ul> <li> <p>Key Management Store (kms): it allows the user to sign data using keys and is the storage that is allocated to these keys.  It\u2019s an abstraction that allows to communicate with different kinds of key storage.</p> </li> <li> <p>Data Storage Interface: it is an interface that allows you to communicate with Credential storage, Identity storage, Merkle tree storage, and State interfaces. This interface lets you create an identity for the user.</p> </li> <li> <p>Credential Wallet: it contains business logic on the top of the Credential storage. An Identity Wallet uses a Credential Wallet for mapping the credentials issued to an Identity.</p> </li> </ul> <p>The methods described below let you create and manage an identity wallet.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#create-an-identity-using-createidentity","title":"Create an Identity using createIdentity()","text":"<p>This method creates an Auth Baby Jub Jub Credential (for signing on behalf of an identity) and an Identifier for an Identity. The Baby Jub Jub Key is the elliptic curve implementation used in Iden3.</p> <p>Firstly, to create an Identity, the three Merkle trees (Claims tree, Revocation tree, and Roots of Root tree) are created. Auth BJJ key is then added to the Claims tree. The hash of these three trees creates a root that is used to create an Identity State. The first state created is called the Genesis State and it is from this Genesis State that a unique Identifier (in the DID format) is generated.</p> <p>The root of the three trees is used to create a Merkle Tree Proof (MTP)  which verifies the existence of a credential on the Merkle tree.</p> <pre><code>createIdentity(opts: IdentityCreationOptions): Promise&lt;{ did: DID; credential: W3CCredential }&gt;;\n</code></pre> <p><code>IdentityCreationOptions</code> lets you select the following options for creating an Identity:</p> <pre><code>interface IdentityCreationOptions {\n  method?: DidMethod;\n  blockchain?: Blockchain;\n  networkId?: NetworkId;\n  revocationOpts: {\n    id: string;\n    type: CredentialStatusType;\n    nonce?: number;\n  };\n  seed?: Uint8Array;\n}\n</code></pre> <p>where <code>method</code> is the type of <code>did</code> method used to create an identity.</p> <p><code>seed</code> is a random/non-random number used to generate the BJJ key-pair.</p> <p><code>revocationOpts</code> contains the way how the status of the Auth BJJ credential can be fetched.</p> <p>The <code>createIdentity</code> method returns a <code>did</code> (Decentralised Identifier) in the DID format and a credential based on the W3C standard for a Verifiable Credential.  </p> <p>Note</p> <p>It is worth noting that <code>did</code> is a Decentralized Identifier associated with an identity and enables verifiable identities. A <code>did</code> could be a person, thing, organization, or even an abstract entity. The controller of the <code>did</code> can prove that it is the real owner of the identity without the need of seeking permissions/approvals from any centralized authority.</p> <p>A <code>did</code> is expressed in the following format, as per w3.org standards:</p> <p>did: did method: did method-specific identifier</p> <p>Info</p> <p>To know more on Iden3 core elements (Baby Jub Jub Key, Credentials, and Identifiers, read Iden3 tutorials here.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#create-profiles-using-createprofile","title":"Create Profiles using createProfile()","text":"<p>This method creates profiles based on the genesis identifier. To keep the user's identity hidden from a Verifier, we can generate different profiles from his/her existing identifier. So, a user has the option to select a particular profile for a particular Verifier so that his real identity is not revealed.</p> <pre><code>createProfile(did: DID, nonce: number, verifier: string): Promise&lt;DID&gt;;\n</code></pre> <p>where <code>did</code> is the DID from which a profile is generated.</p> <p><code>nonce</code> is a unique integer used to generate a profile.</p> <p><code>verifier</code> is the verifier identity/alias in the string format.</p> <p>This method returns a profile ID.</p> <p>Click here for the API Reference.</p> <p>another methods to work with profiles: </p><pre><code>  /**\n   *\n   * gets profile identity by genesis identifiers\n   *\n   * @param {string} did - genesis identifier from which profile has been derived\n   * @returns `{Promise&lt;Profile[]&gt;}`\n   */\n  async getProfilesByDID(did: DID): Promise&lt;Profile[]&gt; {\n    return this._storage.identity.getProfilesByGenesisIdentifier(did.string());\n  }\n\n  /**\n   *\n   * gets profile identity by verier\n   *\n   * @param {string} verifier - verifier for which profile has been created\n   * @returns `{Promise&lt;Profile[]&gt;}`\n   */\n  async getProfileByVerifier(verifier: string): Promise&lt;Profile | undefined&gt; {\n    return this._storage.identity.getProfileByVerifier(verifier);\n  }\n</code></pre>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#generate-key-using-generatekey-method","title":"Generate Key using generateKey() method","text":"<p>This method creates a new Baby Jubjub or ECDSA type of key.</p> <pre><code> generateKey(keyType: KmsKeyType): Promise&lt;KmsKeyId&gt;;\n</code></pre> <p>where <code>keyType</code> is the type of key supported by the Key Management System.</p> <p>This method returns a <code>Promise&lt;KmsKeyId&gt;</code> which generates the key of the type mentioned in <code>keyType</code> parameter.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#issue-credentials-using-issuecredential-method","title":"Issue Credentials using issueCredential() method","text":"<p>This method lets an Issuer grant a credential to a user as requested by the user.</p> <pre><code>  issueCredential(issuerDID: DID, req: CredentialRequest,opts?:options): Promise&lt;W3CCredential&gt;;\n</code></pre> <p>where <code>issuerDID</code> is the identifier of the Issuer in the <code>did</code> format we described earlier. <code>opts</code> are option merklization options. If you use IPFS schemas you must pass IPFS node or gateway url. This method returns a core claim which is then added to the Merkle tree and this claim is then transformed into a Verifiable Credential based on the W3C standards and issued to the user. The core claim is signed by the Issuer and a BabyJubjub Signature Proof is also added to the credential.  </p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#create-a-tree-model-using-getdidtreemodel-method","title":"Create a Tree Model using getDIDTreeModel() method","text":"<p>This method creates a tree model for a <code>did</code>; the model consists of a Claims tree, a Revocation tree, a Roots of Root tree, and the identity hash of the state created from these trees.</p> <pre><code>getDIDTreeModel(did: DID): Promise&lt;TreesModel&gt;;\n</code></pre> <p>This method returns a <code>Promise&lt;TreesModel&gt;</code> which returns the three Merkle trees from the database storage.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#generate-merkle-tree-proof-using-generatecredentialmtp-method","title":"Generate Merkle Tree proof using generateCredentialMtp() Method","text":"<p>This method generates Merkle Tree Proof (MTP) for the inclusion or non-inclusion of a credential in the Claims tree by following the path from the leaf to the root in the given Merkle tree storage. </p> <p>Info</p> <p>To know more about the credential's inclusion in a Merkle tree, read our Iden3 core specification tutorials here.</p> <pre><code>  generateCredentialMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise&lt;MerkleTreeProofWithTreeState&gt;;\n</code></pre> <p>where <code>did</code> is the DID of the Issuer that issued the credential to the user. </p> <p><code>credential</code> is the Verifiable Credential (in the W3C format) used to generate the MTP.</p> <p><code>TreeState</code> is the tree's state used to generate the MTP. If we do not pass the <code>TreeState</code> parameter, the method considers the latest state of the Identity for creating MTP.</p> <p>This method returns <code>MerkletTreeProof</code> along with the <code>TreeState</code> for which the proof is generated.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#generate-non-revocation-merkle-tree-proof-using-generatenonrevocationmtp-method","title":"Generate Non-Revocation Merkle Tree Proof using generateNonRevocationMtp() method","text":"<p>This method generates Merkle Tree Proof for the inclusion or non-inclusion of the revocation nonce of a credential in the Revocation Tree.</p> <pre><code>  generateNonRevocationMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise&lt;MerkleTreeProofWithTreeState&gt;;\n</code></pre> <p>where <code>did</code> is the DID of the Issuer that issues the credential.</p> <p><code>credential</code> is the Verifiable Credential (in the W3C format) used to generate the Non-Revocation Merkle Tree Proof. <code>TreeState</code> is the tree's state used to generate the Non-Revocation MTP. If we do not pass the <code>TreeState</code> parameter, the method considers the latest state of the Identity for creating MTP.</p> <p>This method returns <code>MerkletTreeProof</code> along with the <code>TreeState</code> for which proof is generated.</p> <p>Note</p> <p>To know more about the Revocation of a credential, read here.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#sign-credential-using-sign-method","title":"Sign Credential Using Sign() Method","text":"<p>This method signs a payload of an arbitrary size with an Auth BJJ Credential, which contains a public key and a reference to the Key Management Store (where we store and fetch a private key for the credential).</p> <pre><code>sign(payload: Uint8Array, credential: W3CCredential): Promise&lt;Signature&gt;;\n</code></pre> <p>where <code>payload</code> is any arbitrary string or an unsigned integer array.</p> <p><code>credential</code> is Auth BJJ Credential in the W3C format.</p> <p>This method returns the signature object.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#sign-a-challenge-using-signchallenge-method","title":"Sign a Challenge using signChallenge() method","text":"<p>This method signs a big integer with the Auth BJJ Credential, which identifies a key for signing.</p> <pre><code>signChallenge(payload: bigint, credential: W3CCredential): Promise&lt;Signature&gt;;\n</code></pre> <p>where <code>payload</code> is a big number (bigint). A big number is used in cryptography to prevent anyone from figuring them out.  </p> <p><code>credential</code> is Auth BJJ Credential in the W3C format.</p> <p>This method returns the signature object.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#revoke-credential-using-revokecredential-method","title":"Revoke Credential using revokeCredential() method","text":"<p>This method generates a Revocation Nonce for a credential that we need to revoke (or render invalid due to its expiry, loss, or any other reason).</p> <pre><code>revokeCredential(issuerDID: DID, credential: W3CCredential): Promise&lt;number&gt;;\n</code></pre> <p>where <code>issuerDID</code> is Issuer's identifier. <code>credential</code> is the W3C Credential that needs to be revoked.</p> <p>This method returns the Revocation Nonce of the credential.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#generate-iden3-sparse-merkle-tree-proof-using-generateiden3sparsemerkletreeproof-method","title":"Generate Iden3 Sparse Merkle Tree Proof using generateIden3SparseMerkleTreeProof() Method","text":"<p>This method generates the Iden3 SparseMerkleTree (SMTP) proof that an Issuer state of a specific credential is included in the Merkle Tree or not.</p> <p>With the IssueCredential() method, a Credential is generated along with the Signature Proof. This credential is then added to the Claims Merkle tree and therefore, the state of the tree is changed. For this, another proof called SMTP is required. This proof generates the changed state of the tree by taking Issuer DID, transaction data, and the list of credentials that are part of the changed state as the input parameters.  The JS SDK updates the credential with this SMT Proof, which is included in the state, the transaction data, and the Issuer.</p> <pre><code>generateIden3SparseMerkleTreeProof(\n    issuerDID: DID,\n    credentials: W3CCredential[],\n    txId: string,\n    blockNumber?: number,\n    blockTimestamp?: number\n  ): Promise&lt;W3CCredential[]&gt;;\n</code></pre> <p>where <code>issuerDID</code> is Issuer's identifier.</p> <p><code>credentials</code> is the list of Verifiable Credentials required to generate the proof.</p> <p><code>txId</code> is a hash of the transaction for which the state transition is done.</p> <p><code>blockNumber</code> is the number of the block in which the state transition has been done.</p> <p><code>blockTimestamp</code> is the timestamp of the block at which the state transition has been done.</p> <p>This method returns a list of credentials along with a Sparse Merkle Tree Proof.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#publish-state-to-reverse-hash-service-with-publishstatetorhs-method","title":"Publish State to Reverse Hash Service with publishStateToRHS() Method","text":"<p>If we are using a browser, we need to fetch the revocation status via rhsURL (Reverse Hash Service URL) by pushing the state update to this URL.</p> <p>The <code>publishStateRHS</code> method publishes the updated state of the tree to the Reverse Hash Service.</p> <pre><code>publishStateToRHS(issuerDID: DID, rhsURL: string, revokedNonces?: number[]): Promise&lt;void&gt;;\n</code></pre> <p>where <code>issuerDID</code> is the <code>did</code> of the Issuer.</p> <p><code>rhsURL</code> is the REverse Hash Service URL.</p> <p><code>revokedNonces</code> are the nonces of the revoked credentials.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/identity/identity-wallet/#get-core-claim-representation-with-getcoreclaimfromcredential-method","title":"Get Core Claim Representation with getCoreClaimFromCredential() Method","text":"<p>This method extracts the core claim from either the Signature proof or the Merkle Tree Proof. If we have both types of proofs for the credential, this method extracts the core representation from the Merkle Tree Proof.</p> <pre><code>getCoreClaimFromCredential(credential: W3CCredential): Promise&lt;Claim&gt;;\n</code></pre> <p>where <code>credential</code> is the Verifiable Credential in the W3C format that is used to extract the core representation of the claim.</p> <p>The method returns the core claim representation of the credential.</p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/proof/proof/","title":"Proof","text":""},{"location":"js-sdk/js-sdk-components/proof/proof/#proof","title":"Proof","text":"<p>The Proof interface of the JS SDK performs the following functionalities:</p> <ul> <li>Verifies the zero-knowledge proof for circuit IDs provided.</li> <li>Generates proof in response to the protocol proof request.</li> <li>Generates authentication inputs.</li> <li>Performs state verification.</li> <li>Performs transit state on the latest state to generate state transition proof and publish state to the blockchain. </li> </ul>"},{"location":"js-sdk/js-sdk-components/proof/proof/#verify-zero-knowledge-proof-using-verifyproof-method","title":"Verify Zero-Knowledge Proof using verifyProof() method","text":"<p>This method performs verification of the zero-knowledge proof for a given circuit ID. </p> <p></p><pre><code>verifyProof(zkp: ZKProof, circuitName: CircuitId): Promise&lt;boolean&gt;;\n</code></pre> where <code>zkp</code> is the zero-knowledge proof generated by the user's wallet. <code>circuitId</code> is the ID of the circuit used for generating proof.  <p>The method returns the result of verification in the boolean format.  </p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/proof/proof/#generate-zero-knowledge-proof-using-generateproof-method","title":"Generate Zero-knowledge Proof using generateProof() method","text":"<p>This method generates the zero-knowledge proof for the given ZKP request, identity, and credential.  </p> <p></p><pre><code>generateProof(\n    proofReq: ZeroKnowledgeProofRequest,\n    identifier: DID,\n    opts?: ProofGenerationOptions\n  ): Promise&lt;ZeroKnowledgeProofResponse&gt;\n</code></pre> where <code>proofReq</code> is the ZKP request for the proof generation. <code>identifier</code> is the DID of the user's wallet for which the proof is requested.  <code>opts</code> are the options selected for the proof generation. These are some of the possible options: <pre><code>interface ProofGenerationOptions {\n  skipRevocation: boolean;\n  challenge?: bigint;\n  credential?: W3CCredential;\n}\n</code></pre> <p>The method returns a Zero-knowledge Proof along with the credential used for proof generation. </p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/proof/proof/#generate-authentication-inputs-using-generateauthv2inputs-method","title":"Generate Authentication Inputs using GenerateAuthV2Inputs() Method","text":"<p>This method generates authentication inputs for a given circuit, DID, profile nonce, and a payload (such as the hash of a token). It is used as a protocol in the package manager of a JWZ token. These inputs are used to generate a Zero-knowledge Proof for an authentication circuit. </p> <pre><code>generateAuthV2Inputs(\n    hash: Uint8Array,\n    did: DID,\n    circuitId: CircuitId\n  ): Promise&lt;Uint8Array&gt;; \n</code></pre> <p>where <code>hash</code> is the payload token that the JS SDK signs. <code>did</code> is the DID of the Identity that generates the proof. <code>circuitId</code> is the ID of the circuit used for authentication. </p> <p>This method returns an array of inputs for the authentication circuit. </p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/proof/proof/#verify-state-using-verifystate-method","title":"Verify State using verifyState() Method","text":"<p>This method is the state verification function that uses circuit ID and public signals to verify the state. These public signals are part of the Zero-knowledge Proof and contain an Identity State. To verify this state, you need to call this function. </p> <pre><code> verifyState(circuitId: string, pubSignals: Array&lt;string&gt;): Promise&lt;boolean&gt;;\n</code></pre> <p>where <code>circuitId</code> is the ID of the circuit used for authentication.  <code>pubSignals</code> are the public signals created during the proof generation process. </p> <p>This method returns the state of verification in the boolean format. </p> <p>Click here for the API Reference.</p>"},{"location":"js-sdk/js-sdk-components/proof/proof/#generate-state-transition-proof-using-transitstate-method","title":"Generate State Transition Proof using transitState() Method","text":"<p>This method generates a state transition proof and publishes the identity's state to the blockchain. The state transition is always performed on the latest state of the identity.</p> <pre><code>transitState(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldStateGenesis: boolean,\n    stateStorage: IStateStorage,\n    ethSigner: Signer\n  ): Promise&lt;string&gt;;\n</code></pre> <p>where <code>did</code> is the DID of the Identity for which the state transition is to be performed.  <code>oldTreeState</code> is the previous state of the identity. <code>isOldStateGenesis</code> determines if the state transition has been done from the Genesis state of the identity or not.  <code>stateStorage</code> defines the storage of the identity states. Currently, only Ethereum-based storage is supported.  <code>ethSigner</code> is the signer for transactions. </p> <p>The method returns the transaction hash. For a state transition to happen, a transaction needs to be done from an Ethereum Wallet. </p> <p>To know more about circuits, read here. </p> <p>To know more about state transition, read here.</p> <p>Click here for the API Reference.</p>"},{"location":"push-service/guide/","title":"Guide","text":""},{"location":"push-service/guide/#guide","title":"Guide","text":"<p>Currently, to be able to implement push notification flow for certain app, this app must be registered in the push gateway config.  This can result as a centralization point for developers who wants to use such feature and some expenses and efforts on support of current gateway.</p> <p>For Polygon ID wallet this push service is used: http://push.polygonid.me. </p> <p>Current notification flow: </p> <p></p> <ol> <li>User creates a device push token. After the scanning the authorization request user must prepare an authorization response according to the current rules, but with an addition - inclusion of did document.  DID document contains user  DID  and service to send push notification. User encrypts device push token with  Push Gateway public encryption key and embeds to DID document.</li> <li>Verifier sending a message to  Push Gateway with information from the user did document.</li> <li>Push Gateway decrypts push token stores messages, and sends push notification to the wallet. </li> <li>Wallet gets message with message ID and PPG URL. The application fetches notifications from the service, handles protocol messages, and asks the user if he wants to perform a needed action, e.g. fetch credential.</li> </ol> <p>Glossary: </p> <ul> <li>wallet - mobile application published by the Polygon.</li> <li>verifier - backend for polygon verify application that verifies user documents.</li> <li>Push Gateway (PG) - service to deliver push notifications to the wallet app.</li> <li>Push notification - notification that contains a link to protocol message or protocol message itself that is delivered through the notification provider.</li> </ul>"},{"location":"push-service/guide/#how-to-run-a-server","title":"How to run a server","text":"<ol> <li>Go to the link  and follow the instructions to run your own push notification service.<ol> <li>For a Push Gateway service  sygnal is used. Sygnal can send notifications to Android and Apple devices. For Android devices, sygnal has integration with FCM for Apple devices sygnal has APNS integration. Also, we can add any other provider like SNS for this we must implement the next flow.</li> <li>Default algorithm for encryption is <code>RSA-OAEP-512</code></li> </ol> </li> <li>Register your application on Firebase provider and update config.</li> <li>Get public key of notification service for further encryption actions</li> </ol>"},{"location":"push-service/guide/#how-to-send-an-authorizationresponse-from-mobile-with-push-information","title":"How to send an AuthorizationResponse from mobile with push information","text":"<ol> <li>Create a simple did document </li> </ol> <pre><code>{\n  \"@context\": [\n    \"https://www.w3.org/ns/did/v1\"\n  ],\n  \"id\": \"did:polygonid:polygon:mumbai:2qDj9EDytmvtQP1or3FxykXGEaqSA1ss479MYHDMJc\"\n}\n</code></pre> <p>You can add information about keys / authentication info optionally. Follow this specification </p> <ol> <li>Create encrypted device information.  Device information must be a valid JSON and encrypted with the public key of  Push Gateway.  Apply base64 encoding to encrypted byte array. An encryption key must be used from notification service.</li> </ol> <pre><code>{\n  \"app_id\": \"...\",\n  \"pushkey\": \"push key\",\n}\n</code></pre> <ol> <li> <p>Add push service for did document to service section</p> <pre><code>{\n  \"@context\": [\n    \"https://www.w3.org/ns/did/v1\",\n    \"https://schema.iden3.io/core/jsonld/auth.jsonld\"\n  ],\n  \"id\": \"did:polygonid:polygon:mumbai:2qDj9EDytmvtQP1or3FxykXGEaqSA1ss479MYHDMJc\",\n  \"service\": {\n    \"id\": \"did:polygonid:polygon:mumbai:2qDj9EDytmvtQP1or3FxykXGEaqSA1ss479MYHDMJc#push\",\n    \"type\": \"push-notification\",\n    \"serviceEndpoint\": \"https://push.polygonid.me\",\n    \"metadata\": {\n      \"devices\": [\n        {\n          \"ciphertext\": \"sIyhw8MsRzFTMXnPvvPnjpj38vVHK9z7w/DvHzX+i/68hSjWfSDjXUA49KopWexyoVsAhenS+AS7+JkatJ3+OTlNxUD+lFrAIJUE51qBiM7l7mmkAuryybUQmOgWJCbuUU2nsWFKzIvk2ZTxcMh5EoUxYV2/0HaTmYYTDkzCKQr/oVePlHbiKwG6XjjMCuNaooSAO7UlLduEZY9CjCWBahiJ7LPHq5+SMCSpA9DdxlYe5IDY7ZT0Yg8fmEAq5+ZGvPVDzk1SdXvZNtG/2yygb3ILrSHXN81ztJRPdsEjzctqWwIhP1zEncSMnNEY4vtxEc1red4PuNT6QX0EoP/aX4LdSGIgfM3KB6yjqKBOqgIGoTFih0h/YzcC42lv4oJw0t5obX+32FM8pzQBUoXMvV0F9WpNgDcN04F3/Su9GGRLFNLXApCtj2Mh4H0qnkjMzRMO42RTd3258HYH7U8xK48hpO0Wolt+rn3jrk/JXrVQqO/9EnhCu/PJL1+AoeVtTYL0zp57OWnIAXbW98MGg0pm0MpYwH51hmHx0YLH+4Fkqj30ydcZQhV3xtAVgvKfxQOwwNz2WhIefm+fwYLVAQB4SjUMOrRQYAos7PWgoc21I0QFu52dIA4IvYYBws2Vjb1LvssdFnrd4kUYbC7THdlWONfunbp9xgofzXTrj2g=\",\n          \"alg\": \"RSA-OAEP-512\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> </li> <li> <p>Include did document as a <code>did_doc</code> field in the authorization response message https://iden3-communication.io/authorization/1.0/response/</p> </li> <li>Notification message format that is expected to be sent to mobile. Url field is a valid URL to fetch a message. Fetch request must be  a HTTP GET request with no authorization required. The message is available for 24 hours on Push gateway or deleted after the fetch request.</li> </ol> <pre><code>{\n  \"id\": \"...\",\n  \"url\": \"...\"\n}\n</code></pre>"},{"location":"push-service/guide/#how-to-send-a-push-from-verifier","title":"How to send a push from verifier","text":"<ol> <li>Parse a did document from authorization response</li> <li> <p>Proxy device info to push service using  serviceEndpoint using following format</p> <ol> <li>Message is protocol message that is meant to be delivered to users</li> <li>Devices is an object from push notification service from user did document</li> </ol> <pre><code>{\n  \"message\": \"JSON stringlied message\",\n  \"metadata\": {\n    \"devices\": [\n      {\n        \"ciphertext\": \"...\",\n        \"alg\": \"...\"\n      }\n    ]\n  }\n}\n</code></pre> </li> </ol>"},{"location":"verifier/demo-verifier/","title":"Quick Start - Demo Verifier","text":""},{"location":"verifier/demo-verifier/#demo-verifier","title":"Demo Verifier","text":"<p>The Demo Verifier is a playground that allows you to create query based on a specific credential, generate QR based on that query and let the user scan the QR code to generate a zero-knowledge proof that the query is satisfied.</p>"},{"location":"verifier/demo-verifier/#prerequisites","title":"Prerequisites","text":"<p>Download the Polygon ID Wallet App and create an Identity.</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> <li>Have the queried credential inside your wallet. For the tutorial, we are using the <code>ProofOfDaoLongevity</code> that can be created via the Demo Issuer.</li> </ul>"},{"location":"verifier/demo-verifier/#quick-start","title":"Quick Start","text":"<ol> <li> <p>On the Demo Verifier website click on the drop-down menu and then Custom</p> <p></p> <p>Click on Sign In.</p> </li> <li> <p>Create the query via the editor.</p> <p>The editor allows you to design the query that the user will have to satisfy. The query is created by selecting the credential type and the attribute that you want to query. More info on how to design a query are described via the ZK Query Language.</p> <p>In this example, we are querying the date of entry of the user inside a DAO. In particular, we want to make sure that the user joined the DAO before a specific date. This query is based on the <code>ProofOfDaoLongevity</code> credential type described by this JSON-LD Context.</p> <p></p> <p>Then click Submit.</p> </li> <li> <p>The query is then converted into a QR code that can be scanned by the user.</p> <p></p> <p>Once scanning the QR code with the Polygon ID app, the user will be prompted to generate a zero-knowledge proof that attests that the query is satisfied without revealing any further information about the credential. For example, the actual date of entry of the user inside the DAO is not revealed to the verifier.</p> </li> </ol>"},{"location":"verifier/features/","title":"Features","text":""},{"location":"verifier/features/#selective-disclosure","title":"Selective Disclosure","text":"<p>There are two types of proof requests: private proof and selective disclosure. In private proof requests, the credential attribute values are not disclosed, and the response is true/false of the requested value.  In selective disclosure requests, the verifier asks for one attribute value from the credential to be disclosed.</p> <p>The selective disclosure has almost the same technical flow as the proof request, the only difference is that the query in the QR code from the proof request of the verifier contains a different format. The SDK just calls the authenticate method from <code>iden3comm.dart</code> with the <code>iden3MessageEntity</code> as a parameter.</p> <p>Info</p> <p>Check a query sample here.</p>"},{"location":"verifier/query-builder/","title":"Query Builder","text":"<p>There is an interactive way of creating verification queries by utilizing an intuitive form with all the fields a comprehensive query must have. In Polygon ID, this useful feature is called Query Builder.</p> <p>Verifiers can create a set of rules that users need to meet to prove their identity using their existing credentials. These rules could range from being a member of a specific organization to being at a certain age. Polygon ID makes it easy and secure for users to prove their identity by using these rules for authentication purposes.</p> <p>Currently, the only way to create a verification QR code - a way for users to scan and verify their credentials - is by using Request and Verification APIs.</p> <p>By providing a standardized interface for query creation, a user interface can help ensure that queries are created in a consistent, uniform and error-free way across different users and organizations. Also, rather than requiring users to have knowledge of the query language, a user interface can provide a more intuitive and user-friendly way to create queries. </p> <p></p> <p>The Query Builder contains the following fields:</p> <ul> <li>Proof type: credential issuance methods. SIG for Credentials with Baby JubJub(BJJ) Key Signatures and MTP for credentials with Merkle Tree Proof.</li> <li>URL to JSON-LD Context: this should be the address where the JSON-LD Context is stored, containing schema data.</li> <li>Schema Type: this is the field used to select the schema which the query is about, for credentials that have more than one schema type.</li> <li>Issuer DID: refers to the identification of the issuer that generated the credential. Use <code>*</code> to consider any issuers. We currently support only one value, which means that you can either choose one particular Issuer DID or use <code>*</code> to accept any.</li> <li>Attribute field: this is the attribute the query is based on. Each query supports only one attribute.</li> <li>Query type: the two options of queries that are available, a Condition or Selective disclosure. Condition depends on a value and an operator; that would be the case of a query requesting a user to be older than 21 years old. Selective Disclosure is the feature used to ask the ID holder for a specific piece of their data.</li> <li>Operator: this is the relation between the attribute and the value.</li> <li>Value: this is the value the operator refers to.</li> <li>Skip Revocation Check: will skip the check to see if a credential was revoked or not.</li> </ul> <p>You can see here how these fields should be filled for a verifier who needs to check whether the credential holder is older than 21 years old:</p> <p></p> <p>The Query Builder outcome should look like this: </p> <p></p> <p>Then, one can copy and paste the snippet on the verifier API <code>GetAuthRequest()</code> function. </p> <p>Info</p> <p>The idea behind the Query Builder is to facilitate the query elaboration process by generating the whole section relative to \"Request for specific proof\" of the auth request endpoint code, as it can be seen on the Run a Verifier tutorial, more specifically on point 3.</p>"},{"location":"verifier/verifier-overview/","title":"Overview","text":""},{"location":"verifier/verifier-overview/#verifier","title":"Verifier","text":"<p>A Verifier is any web2 or web3 platform that wants to authenticate users based on their Credentials.</p> <p>Verifiers can set up queries based on users\u2019 existing Credentials collected from a broad set of Issuers. A Query encapsulates the criteria that a user must match to authenticate, such as \u201cmust be a member of XYZ DAO\u201d or \u201cmust be over 18 years old\u201d. Polygon ID provides a seamless, customized and privacy-based authentication experience to users.</p> <p>The request of the Verifier is designed using our fully expressive zk Query Language and encapsulated into a QR code (or via deeplinking) to be shown to the user. The user scans the QR code with its Wallet to prompt the proof generation. </p> <p>The verification process doesn\u2019t involve any interaction between the Verifier and the Issuer of the requested credential. As part of the Query, the Verifier includes the identifiers of the trusted issuers. For example, a Verifier should add XYZ DAO as the only trusted Issuer when verifying that an individual is a member of XYZ DAO. XYZ DAO doesn\u2019t need to accept nor interact with the Verifier.</p> <p>At the end of the process the verifier gets a cryptographic proof that the user satisfies the query, while the user shares just the minimum possible amount of data required for the interaction.</p>"},{"location":"verifier/verifier-overview/#verifier-sdk","title":"Verifier SDK","text":"<p>The Verifier SDK is a set of tools that allow any application to verify user information based on their credentials. The SDK provides a fully customizable and privacy-based authentication experience to users.  The process of verifying user information based on their credentials can happen on-chain via a smart contract or off-chain. Both processes involve the same level of user privacy and the same degree of query customization. The proof generated on mobile is the same for both cases; the only difference is in the verification process. The on-chain verification happens programmatically inside a smart contract. The off-chain verification happens inside a script that needs to be set up by the Verifier application (either on a server or on the client side):</p> <ul> <li>Verifier SDK - Off-chain Verification provides all the elements to create a customized Query, set up a verifier and generate a QR code (or deeplink) on the client side to request proof from the user.</li> <li>Verifier SDK - On-chain Verification allows Dapps to verify users' credentials inside a Smart Contract using zero-knowledge proof cryptography. </li> </ul>"},{"location":"verifier/verifier-overview/#quick-start","title":"Quick Start","text":"<p>You can quickly try out the Verification experience by following the steps below: </p> <ul> <li>Download the Polygon ID Wallet App and create an Identity. <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul> </li> <li>Fetch a credential from the Demo Issuer</li> <li>Verify it on the Demo Verifier</li> </ul>"},{"location":"verifier/on-chain-verification/overview/","title":"Implement ERC20 zk airdrop in 20 minutes","text":""},{"location":"verifier/on-chain-verification/overview/#on-chain-zk-verification","title":"On-chain ZK Verification","text":"<p>The on-chain verification workflow allows Dapps to verify users' credentials inside a Smart Contract. Zero-Knowledge Proof cryptography enables this verification to happen in a private manner, namely without revealing any personal information of the user (prover).</p> <p>This flow is especially needed when further on-chain logic wants to be implemented on successful verification such as:</p> <ul> <li>Distribute a token-airdrop only to human-verified accounts</li> <li>Allow voting only to account members of your DAO </li> <li>Block airdrops to users that belong to a specific country</li> <li>Allow trading only to accounts that passed the KYC verification</li> </ul>"},{"location":"verifier/on-chain-verification/overview/#on-chain-verification-flow","title":"On-chain verification flow","text":"On-chain verification workflow  <p>At its core, every on-chain interaction between a Verifier and a user's Wallet follows this workflow:</p> <ul> <li>After having deployed a Verifier Smart Contract, the Verifier designs a Request for the users. This has to be recorded on-chain inside the Verifier Smart Contract. </li> <li>The Request is delivered to the user within a QR code (or via deep-linking; it is up to the implementer).</li> <li>The user scans the QR code using his/her mobile ID wallet and parses the request</li> <li>The user fetches the revocation status of the requested credential from the Issuer of that credential.</li> <li>The user generates a zk proof on mobile according to the request of the website starting from the credentials held in his/her wallet. This also contains the zk proof that the credential is not revoked.</li> <li>The user sends the zk proof to the Verifier Smart Contract.</li> <li>The Verifier Smart Contract verifies the zk Proof.</li> <li>The Verifier Smart Contract checks that the State of the Issuer of the credential and the State of the user are still valid and have not been revoked.</li> <li>If the verification is successful, the Verifier executes the logic defined in the Smart Contract.</li> </ul> <p>Note that an active action from the Verifier is only required at step 1. All the rest of the interaction is between the user and the Smart Contract. All the verification logic is executed programmatically inside the Smart Contract.</p>"},{"location":"verifier/on-chain-verification/overview/#implement-erc20-zk-airdrop-in-20-minutes","title":"Implement ERC20 ZK Airdrop in 20 Minutes","text":"<p>In this tutorial, we will create an ERC20 zk Airdrop Contract. The chosen query criteria is to be born before <code>01/01/2002</code>. Users that are able to prove that were born before that date will be able to get the airdrop. Otherwise, they will not. The proof submitted to the Smart Contract will not reveal any information about the specific date of birth of the user. That is the magic of zero-knowledge! </p> <p>To set up a different query check out the ZK Query Language section</p> <p>This tutorial is based on the verification of a Credential of Type <code>KYCAgeCredential</code> with an attribute <code>birthday</code> with a Schema URL <code>https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld</code>.</p> <p>The prerequisite is that users have the Polygon ID Wallet app installed and self-issued a Credential of type <code>KYC Age Credential Merklized</code> using our Demo Issuer </p> <p>Note: The full executable code related to this tutorial can be cloned from this repository.</p>"},{"location":"verifier/on-chain-verification/overview/#design-the-erc20-zk-airdrop-verifier-contract","title":"Design the ERC20 zk Airdrop Verifier Contract","text":"<p>Let us jump into the code by writing the <code>ERC20Verifier</code> contract. </p> <p>The ERC20Verifier is an ERC20 standard contract on steroids. The extra functionality is given by the zero-knowledge proof verification. All the functions dedicated to the zk verification are contained inside the  ZKPVerifier Contract and inherited within the ERC20Verifier. For example, users will submit their proof to claim the airdrop by calling <code>submitZKPResponse</code>.</p> <p>The ERC20Verifier contract must define at least a single <code>TRANSFER_REQUEST_ID</code>. This is the Identifier of the request that the contract is posing to the user.</p> <p>In this specific case the request is: \"to be born before 01/01/2002\". Note that this hasn't been added yet to the Smart Contract. It will be added in a few minutes!</p> <pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./lib/GenesisUtils.sol\";\nimport \"./interfaces/ICircuitValidator.sol\";\nimport \"./verifiers/ZKPVerifier.sol\";\n\ncontract ERC20Verifier is ERC20, ZKPVerifier {\n\n    uint64 public constant TRANSFER_REQUEST_ID = 1;\n    // define the amount of token to be airdropped per user\n    uint256 public TOKEN_AMOUNT_FOR_AIRDROP_PER_ID = 5 * 10**uint(decimals());\n\n\n    constructor(string memory name_, string memory symbol_)\n        ERC20(name_, symbol_)\n    {}    \n\n}\n</code></pre> <p>The ZKPVerifier Contract provides 2 hooks: </p> <p><code>_beforeProofSubmit</code> and <code>afterProofSubmit</code>. These hooks are called before and after any proof gets submitted and can be used to create personalized logic inside your Smart Contract.</p> <p>In this specific case, it must be checked that the sender of the proof matches the address contained in the proof challenge. This requirement is necessary to prevent proof front-running. This condition is added inside <code>_beforeProofSubmit</code>.</p> <p>The airdrop logic must be added inside <code>_afterProofSubmit</code>. The contract must execute the airdrop once the proof is correctly verified.</p> <pre><code>contract ERC20Verifier is ERC20, ZKPVerifier {\n    uint64 public constant TRANSFER_REQUEST_ID = 1;\n\n    mapping(uint256 =&gt; address) public idToAddress;\n    mapping(address =&gt; uint256) public addressToId;\n\n    uint256 public TOKEN_AMOUNT_FOR_AIRDROP_PER_ID = 5 * 10**uint(decimals());\n\n    constructor(string memory name_, string memory symbol_)\n        ERC20(name_, symbol_)\n    {}\n\n    function _beforeProofSubmit(\n        uint64, /* requestId */\n        uint256[] memory inputs,\n        ICircuitValidator validator\n    ) internal view override {\n        // check that the challenge input of the proof is equal to the msg.sender \n        address addr = GenesisUtils.int256ToAddress(\n            inputs[validator.getChallengeInputIndex()]\n        );\n        require(\n            _msgSender() == addr,\n            \"address in the proof is not a sender address\"\n        );\n    }\n\n    function _afterProofSubmit(\n        uint64 requestId,\n        uint256[] memory inputs,\n        ICircuitValidator validator\n    ) internal override {\n        require(\n            requestId == TRANSFER_REQUEST_ID &amp;&amp; addressToId[_msgSender()] == 0,\n            \"proof can not be submitted more than once\"\n        );\n\n        uint256 id = inputs[validator.getChallengeInputIndex()];\n        // execute the airdrop\n        if (idToAddress[id] == address(0)) {\n            super._mint(_msgSender(), TOKEN_AMOUNT_FOR_AIRDROP_PER_ID);\n            addressToId[_msgSender()] = id;\n            idToAddress[id] = _msgSender();\n        }\n    }\n}\n</code></pre> <p>Finally, we can add a further element of security inside the Smart Contract: prevent any type of token transfer (even after the airdrop) unless users passed the proof verification. This last condition is added by overriding the ERC20 <code>_beforeTokenTransfer</code> function and checking that the receiver address <code>to</code> of the transfer is included inside the  <code>proofs</code> mapping. </p> <pre><code>contract ERC20Verifier is ERC20, ZKPVerifier {\n    uint64 public constant TRANSFER_REQUEST_ID = 1;\n\n    mapping(uint256 =&gt; address) public idToAddress;\n    mapping(address =&gt; uint256) public addressToId;\n\n    uint256 public TOKEN_AMOUNT_FOR_AIRDROP_PER_ID = 5 * 10**uint(decimals());\n\n    constructor(string memory name_, string memory symbol_)\n        ERC20(name_, symbol_)\n    {}\n\n    function _beforeProofSubmit(\n        uint64, /* requestId */\n        uint256[] memory inputs,\n        ICircuitValidator validator\n    ) internal view override {\n       ...\n    }\n\n    function _afterProofSubmit(\n        uint64 requestId,\n        uint256[] memory inputs,\n        ICircuitValidator validator\n    ) internal override {\n        ...\n    }\n\n    function _beforeTokenTransfer(\n        address, /* from */\n        address to,\n        uint256 /* amount */\n    ) internal view override {\n        require(\n            proofs[to][TRANSFER_REQUEST_ID] == true,\n            \"only identities who provided proof are allowed to receive tokens\"\n        );\n    }\n}\n</code></pre> <p>The contract is now fully written!</p>"},{"location":"verifier/on-chain-verification/overview/#deploy-the-contract","title":"Deploy the Contract","text":"<p>Execute this Hardhat script to deploy the contract</p> <pre><code>async function main() {\n  const verifierContract = \"ERC20Verifier\";\n  const verifierName = \"ERC20zkAirdrop\";\n  const verifierSymbol = \"zkERC20\";\n\n\n  const spongePoseidonLib = \"0x12d8C87A61dAa6DD31d8196187cFa37d1C647153\";\n  const poseidon6Lib = \"0xb588b8f07012Dc958aa90EFc7d3CF943057F17d7\";\n\n\n  const ERC20Verifier = await ethers.getContractFactory(verifierContract,{\n    libraries: {\n      SpongePoseidon: spongePoseidonLib,\n      PoseidonUnit6L: poseidon6Lib\n    },\n  } );\n  const erc20Verifier = await ERC20Verifier.deploy(\n    verifierName,\n    verifierSymbol\n  );\n\n  await erc20Verifier.deployed();\n  console.log(verifierName, \" contract address:\", erc20Verifier.address);\n}\n</code></pre> <p>The contract ERC20Verifier must be deployed on the Mumbai test network as there is a set of supporting contracts that are already deployed on Mumbai! </p>"},{"location":"verifier/on-chain-verification/overview/#set-the-zkp-request","title":"Set the ZKP Request","text":"<p>As previously mentioned, the actual zkp request \"to be born before 01/01/2002\" hasn't been added to the Smart Contract yet. To do so it is necessary to call <code>setZKPRequest</code> function inherited inside the ERC20Verifier which takes 6 inputs:</p> <ol> <li><code>requestId</code>: the ID associated with the request.</li> <li><code>validator</code>: the address of the Validators Smart Contract already deployed on Mumbai. This is the contract that executes the verification on the zk proof submitted by the user. It can be of type CredentialAtomicQuerySigValidator or CredentialAtomicQueryMTPValidator.</li> <li><code>schema</code> namely the bigInt representation of the schema of the requested credential. This can be obtained by passing your schema to this Go Sandbox. In order to use the sandbox, the constants <code>jsonLDContext</code>, <code>typ</code>, <code>fieldName</code> and <code>schemaJSONLD</code> need to be modified according to your request.</li> <li><code>claimPathKey</code> represents the path to the queries key inside the merklized credential. In this case it is the path to the <code>birthday</code> key. This can be obtained by passing your schema to this Go Sandbox. In order to use the sandbox, the constants <code>jsonLDContext</code>, <code>typ</code>, <code>fieldName</code> and <code>schemaJSONLD</code> need to be modified according to your request.</li> <li><code>operator</code> is either 1,2,3,4,5,6. To understand more about the operator you can check the zk query language</li> <li><code>value</code> represents the threshold value you are querying. In this case it is the date 01/01/2002. </li> </ol> <p>Check out our Smart Contract section to learn more about the set of verifications executed on the zk proof.</p> <p>Execute this Hardhat script to set the zk request to the Smart Contract.</p> <pre><code>const Operators = {\n  NOOP : 0, // No operation, skip query verification in circuit\n  EQ : 1, // equal\n  LT : 2, // less than\n  GT : 3, // greater than\n  IN : 4, // in\n  NIN : 5, // not in\n  NE : 6   // not equal\n}\n\nasync function main() {\n\n  // you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\n  const schemaBigInt = \"74977327600848231385663280181476307657\"\n\n   // merklized path to field in the W3C credential according to JSONLD  schema e.g. birthday in the KYCAgeCredential under the url \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\"\n  const schemaClaimPathKey = \"20376033832371109177683048456014525905119173674985843915445634726167450989630\"\n\n  const requestId = 1;\n\n  const query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: Operators.LT, // operator\n    value: [20020101, ...new Array(63).fill(0).map(i =&gt; 0)], // for operators 1-3 only first value matters\n    };\n\n  // add the address of the contract just deployed\n  const ERC20VerifierAddress = \"&lt;ERC20VerifierAddress&gt;\"\n\n  let erc20Verifier = await hre.ethers.getContractAt(\"ERC20Verifier\", ERC20VerifierAddress)\n\n\n  const validatorAddress = \"0xF2D4Eeb4d455fb673104902282Ce68B9ce4Ac450\"; // sig validator\n  // const validatorAddress = \"0x3DcAe4c8d94359D31e4C89D7F2b944859408C618\"; // mtp validator\n\n  try {\n    await erc20Verifier.setZKPRequest(\n        requestId,\n        validatorAddress,\n        query.schema,\n        query.claimPathKey,\n        query.operator,\n        query.value\n    );\n    console.log(\"Request set\");\n  } catch (e) {\n    console.log(\"error: \", e);\n  }\n}\n</code></pre> <p>The contract is now correctly deployed on Mumbai Testnet and the query has been set up, congratulations! Now it is time to launch the airdrop! </p>"},{"location":"verifier/on-chain-verification/overview/#add-the-proof-request-inside-a-qr-code","title":"Add the Proof Request Inside a QR Code","text":"<p>The last step is to design the proof request to be embedded inside a QR code that will be shown to the users that want to Credential their airdrops. In this particular case this is how the request should look like (remember to modify it by adding the address of your ERC20Verifier Contract):</p> <pre><code>{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract_address\": \"&lt;ERC20VerifierAddress&gt;\",\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n                    \"credentialSubject\": {\n                        \"birthday\": {\n                            \"$lt\": 20020101\n                        }\n                    },\n                    \"type\": \"KYCAgeCredential\"\n                }\n            }\n        ]\n    }\n}\n</code></pre> <p>The scope section inside the JSON file must match the query previously set when calling the \"setZKPRequest\" function.</p> <p>Note that the request resembles in most of its parts with the one designed for off-chain verification. The extra part that has been added here is the <code>transcation_data</code> that includes:</p> <ul> <li><code>contract_address</code>, namely the address of the Verifier contract, in this case, ERC20Verifier</li> <li><code>method_id</code>, namely the Function Selector of the <code>submitZKPResponse</code> function</li> <li><code>chain_id</code>, the ID of the chain where the Smart Contract has been deployed</li> <li><code>network</code>, the name of the network where the Smart contract has been deployed</li> </ul> <p>To display the QR code inside your frontend, you can use the <code>express.static</code> built-in middleware function together with this Static Folder or this Code Sandbox.</p> <p>Scanning the QR with their Polygon ID Wallet, users will be able to generate proofs and send transactions to the Smart Contract in order to Credential their airdrops.</p> <p>The same proof generation request can also be delivered to users via Deep Linking. In order to do so, it is necessary to encode the <code>json</code> file to Base64 Format. The related deep link would be <code>iden3comm://?i_m={{base64EncodedJsonHere}}</code>. For example, in this specific case the deep link would be <code>iden3comm://?i_m=ewogICAgImlkIjogIjdmMzhhMTkzLTA5MTgtNGE0OC05ZmFjLTM2YWRmZGI4YjU0MiIsCiAgICAidHlwIjogImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwKICAgICJ0eXBlIjogImh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9wcm9vZnMvMS4wL2NvbnRyYWN0LWludm9rZS1yZXF1ZXN0IiwKICAgICJ0aGlkIjogIjdmMzhhMTkzLTA5MTgtNGE0OC05ZmFjLTM2YWRmZGI4YjU0MiIsCiAgICAiYm9keSI6IHsKICAgICAgICAicmVhc29uIjogImFpcmRyb3AgcGFydGljaXBhdGlvbiIsCiAgICAgICAgInRyYW5zYWN0aW9uX2RhdGEiOiB7CiAgICAgICAgICAgICJjb250cmFjdF9hZGRyZXNzIjogIjxFUkMyMFZlcmlmaWVyQWRkcmVzcz4iLAogICAgICAgICAgICAibWV0aG9kX2lkIjogImI2ODk2N2UyIiwKICAgICAgICAgICAgImNoYWluX2lkIjogODAwMDEsCiAgICAgICAgICAgICJuZXR3b3JrIjogInBvbHlnb24tbXVtYmFpIgogICAgICAgIH0sCiAgICAgICAgInNjb3BlIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAiaWQiOiAxLAogICAgICAgICAgICAgICAgImNpcmN1aXRJZCI6ICJjcmVkZW50aWFsQXRvbWljUXVlcnlTaWdWMk9uQ2hhaW4iLAogICAgICAgICAgICAgICAgInF1ZXJ5IjogewogICAgICAgICAgICAgICAgICAgICJhbGxvd2VkSXNzdWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgIioiCiAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAiY29udGV4dCI6ICJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaWRlbjMvY2xhaW0tc2NoZW1hLXZvY2FiL21haW4vc2NoZW1hcy9qc29uLWxkL2t5Yy12My5qc29uLWxkIiwKICAgICAgICAgICAgICAgICAgICAiY3JlZGVudGlhbFN1YmplY3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICJiaXJ0aGRheSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICIkbHQiOiAyMDAyMDEwMQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAidHlwZSI6ICJLWUNBZ2VDcmVkZW50aWFsIgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgXQogICAgfQp9</code></p>"},{"location":"verifier/on-chain-verification/overview/#user-demo-claim-the-airdrop","title":"User Demo: Claim the Airdrop!","text":"<p>This video shows how a user can use their PolygonID wallet app to claim a ERC-20 token airdrop. To join the airdrop users are required to have a Credential of type <code>KYCAgeCredential</code> attesting that they have been born before 01/01/2002.</p> <p>Or you can direcly test it scanning the QR Code below using your Polygon ID App: </p> <p></p>"},{"location":"verifier/on-chain-verification/overview/#how-the-proof-submission-is-executed","title":"How the proof submission is executed?","text":"<p>The wallet needs to call the <code>submitZKPResponse()</code> function before it can submit the proof for the requirements set in the Airdrop Participation process. This function forms part of the ZKPVerifier Interface <code>IZKPVerifier</code> and is actually implemented inside the <code>ZKPVerifier Contract</code>.</p> <pre><code>import \"./ICircuitValidator.sol\";\n\ninterface IZKPVerifier {\n    function submitZKPResponse(\n        uint64 requestId,\n        uint256[] memory inputs,\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c\n    ) external returns (bool);\n}\n</code></pre>"},{"location":"verifier/on-chain-verification/overview/#extend-it-to-your-own-logic","title":"Extend it to Your Own Logic","text":"<p>Now that you have been able to create your first on-chain zk-based application you can extend it to accommodate any type of imaginable logic. The target Smart Contract doesn't have to be an ERC20 but it can be an ERC721, a DeFi pool, a voting Smart Contract or whatever contract you can think of. Equally the query can be extended to any type of existing Credential and based on the different operators available inside the ZK Query Language.</p> <p>Another possibility to customize your Smart Contract involves setting different zk requests. First of all, multiple <code>REQUEST_ID</code> must be defined inside the main Smart Contract. Therefore, the contract deployer can set a different query for each request ID and create different outcomes inside <code>_afterProofSubmit</code> according to the type of proof received. For example, an airdrop contract can verify the role of a user inside a DAO and distribute a different amount of tokens based on the role.</p>"},{"location":"verifier/on-chain-verification/overview/#further-tutorial-for-on-chain-verification","title":"Further Tutorial for On-chain Verification","text":"<ul> <li>Polygon ID On-chain Verifications - Codingwithmanny, contains a more detailed explanation of the ERC20 Airdrop using Polygon ID. Furthermore it contains a section for debugging common errors and for minting an NFT starting from on-chain Polygon ID Credential Verification.</li> </ul>"},{"location":"verifier/verification-library/config/","title":"Config","text":""},{"location":"verifier/verification-library/config/#configuration","title":"Configuration","text":"<p>The set of APIs included in the verification library can be split into two steps:</p> <ul> <li>Request APIs allow to design the request to be presented to the user in order to authenticate.</li> <li>Verification APIs allow verifying the proof sent by the user. The proof is generated as response to the request. </li> </ul> <p>Check the workflow to disambiguate between these two processes</p> <p>Both the APIs are available either in Golang or Javascript:</p> GoLangJavascript <pre><code>go get github.com/iden3/go-iden3-auth/v2\n</code></pre> <pre><code>import (\n    \"github.com/iden3/go-circuits/v2\"\n    auth \"github.com/iden3/go-iden3-auth/v2\"\n    \"github.com/iden3/go-iden3-auth/v2/loaders\"\n    \"github.com/iden3/go-iden3-auth/v2/pubsignals\"\n    \"github.com/iden3/go-iden3-auth/v2/state\"\n    \"github.com/iden3/iden3comm/v2/protocol\"\n)\n</code></pre> <pre><code>npm i @iden3/js-iden3-auth --save\n</code></pre> <pre><code>const {auth, resolver, protocol} = require('@iden3/js-iden3-auth')\n</code></pre>"},{"location":"verifier/verification-library/request-api-guide/","title":"Request APIs","text":""},{"location":"verifier/verification-library/request-api-guide/#request-api","title":"Request API","text":"<p>The first step of interacting with a wallet involves presenting a request. In this tutorial, we will explain the difference between two types of requests: Basic Auth Request and Query-based Request.</p> <p>A Basic Auth Request allows to design a minimal DID request to the user. As a response to that, the user will share a proof that he/she is the owner of that DID.</p> <p>A Query-based Request allows to design a more complex query request to the user. As a response to that, the user will share a proof that he/she owns a credential that satisfies the properties defined inside the query.</p>"},{"location":"verifier/verification-library/request-api-guide/#basic-auth-request","title":"Basic Auth Request","text":"<p>The Basic Auth Request allows verifiers to interact with a wallet and authenticate the user by its DID. A Basic Auth Request can be implemented by any platform that is interested in providing a seamless web2-like login experience to its users without setting any specific requirements.</p>"},{"location":"verifier/verification-library/request-api-guide/#createauthorizationrequest","title":"CreateAuthorizationRequest","text":"GoLangJavascript <pre><code>var request protocol.AuthorizationRequestMessage\nrequest = auth.CreateAuthorizationRequest(reason, audience, url)\n</code></pre> <pre><code>const request : protocol.AuthorizationRequestMessage = auth.createAuthorizationRequest(reason, audience, url)\n</code></pre> <p>An example of the usage of this api can be found here (GO) and here (JS)</p> <p>Generate an Auth Request to the user that includes a reason for authenticating. The audience represents the DID of the requester, while the url is the callback URL where the user must send the response for verification.</p>"},{"location":"verifier/verification-library/request-api-guide/#createauthorizationrequestwithmessage","title":"CreateAuthorizationRequestWithMessage","text":"GoLangJavascript <pre><code>var request protocol.AuthorizationRequestMessage\nrequest = auth.CreateAuthorizationRequestWithMessage(reason, messageToSign, audience, url)\n</code></pre> <pre><code>const request : protocol.AuthorizationRequestMessage = auth.createAuthorizationRequestWithMessage(reason, messageToSign, audience, url)\n</code></pre> <p>The same functionality of CreateAuthorizationRequest but it also includes a messageToSign. This message will be shown to the users inside their wallets and will be signed as part of the response.</p>"},{"location":"verifier/verification-library/request-api-guide/#query-based-request","title":"Query-based Request","text":"<p>The Query-based Auth Request allows verifiers to interact with a wallet by setting up specific requirements for authentication. These requirements are the conditions that the user has to satisfy based on the credentials held in his/her wallet.</p> <p>The Query has to be attached to the Basic Auth Request output of the previous API. An example of its usage can be found here</p> GoLangJavascript <pre><code>var mtpProofRequest protocol.ZeroKnowledgeProofRequest\nmtpProofRequest.ID = 1\nmtpProofRequest.CircuitID = string(circuits.AtomicQuerySigV2CircuitID)\nmtpProofRequest.Query = map[string]interface{}{\n    \"allowedIssuers\": []string{\"*\"},\n    \"credentialSubject\": map[string]interface{}{\n        \"birthday\": map[string]interface{}{\n            \"$lt\": 20000101,\n        },\n    },\n    \"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n    \"type\":    \"KYCAgeCredential\",\n}\nrequest.Body.Scope = append(request.Body.Scope, mtpProofRequest)\n</code></pre> <pre><code>const proofRequest: protocol.ZKPRequest = {\n            id: 1,\n            circuitId: 'credentialAtomicQuerySigV2',\n            query: {\n              allowedIssuers: ['*'],\n              type: 'KYCAgeCredential',\n              context: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld',\n              credentialSubject: {\n                birthday: {\n                  $lt: 20000101,\n                },\n              },\n          },\n        };\nrequest.body.scope = [...scope, proofRequest];\n</code></pre> <p>Generate a request to prove that the user owns a credential that satisfies certain requirements. </p> <p><code>ID</code> represents the request id: ideally, in production, it should be a unique value for each request. <code>CircuitID</code> represents the identifier of the circuit that the user must use to generate the requested proof: here you can find a reference to the available circuits. </p> <p>In this case, the user has to provide a proof that he/she owns a credential issued by the <code>allowedIssuer</code> of schema <code>type</code> KYCAgeCredential described in the URL provided in <code>context</code>. This is the JSON-LD context of the credential. By setting the <code>allowedIssuer</code> to <code>*</code>, the user can provide a proof of that credential issued by any issuer. Alternatively, if the verifier adds the DID of a specific issuer inside the <code>allowedIssuer</code> array, the user must provide a proof of a credential issued by that specific issuer.</p> <p>Allowed Issuers</p> <p>As stated above, when we use <code>*</code> in the \"allowed issuers\" segment (<code>allowedIssuers: ['*']</code>), we mean that we accept any entity that might have provided the credential. Even though this seems to be convenient for testing purposes, it may also be considered risky. Applying due diligence by actually choosing trusted specific issuers should be the best approach. Only in rare cases, a verifier would accept any issuer, so we advise not to use <code>*</code>.  </p> <p>This credential contains details in its <code>credentialSubject</code> of the birthday of the receiver. In this scenario, the user has to prove that the value contained in the attribute <code>birthday</code> is less than <code>lt</code> 20000101, namely that the user was born before 01/01/2000.</p> <p>An additional optional field that can be included in the query is <code>skipClaimRevocationCheck</code>. By setting it to <code>true</code>, the user doesn't need to provide the proof of the revocation of the credential, which would otherwise be provided by default.  This is useful for credentials that are still useful even if they have been revoked. For example, a credential that states that a user is an employee of Google, is still useful even if it has been revoked after the user left the company and the credential was revoked.</p> <pre><code>mtpProofRequest.Query = map[string]interface{}{\n...\n\"skipClaimRevocationCheck\": true,\n...\n}\n</code></pre> <p>An example of the usage of this API can be found here (GO) and here (JS)</p> <p>Check out our Query Language guide to design any type of query request you can think of!</p> <p>Check out the Iden3Comm section inside the Wallet SDK to learn more about how these requests are interpreted by the wallet in order to generate a zk proof.</p>"},{"location":"verifier/verification-library/verification-api-guide/","title":"Verification APIs","text":""},{"location":"verifier/verification-library/verification-api-guide/#verification","title":"Verification","text":"<p>After having presented a Request to the user's wallet, the wallet will process the request and generate a proof that is sent back to the Verifier.  The proof must be verified in order to authenticate the user.  Let us see how to execute this verification.</p> <p>The proof verification always follows the same flow independently of the Request type presented in the previous step by the Verifier, whether it is a basic auth or a query-based request.</p> <p>Unpack the proof </p> GoLangJavascript <pre><code>import (\n    \"io\"\n)\n\ntokenBytes, err := io.ReadAll(req.Body)\n</code></pre> <pre><code>const getRawBody = require('raw-body')\n\nconst raw = await getRawBody(req);\nconst tokenStr = raw.toString().trim();\n</code></pre> <p><code>req</code> is the post request sent by the wallet in response to the Auth Request posed by the Verifier. This unpacks the proof sent by the wallet.</p> <p>Initiate the verifier</p> GoLangJavascript <pre><code>var verificationKeyloader = &amp;loaders.FSKeyLoader{Dir: keyDIR}\nresolver := state.ETHResolver{\n    RPCUrl:          ethURL,\n    ContractAddress: common.HexToAddress(contractAddress),\n}\n\nresolvers := map[string]pubsignals.StateResolver{\n    resolverPrefix: resolver,\n}\n\nverifier, err := auth.NewVerifier(\n        verificationKeyloader, resolvers, auth.WithIPFSGateway(\"&lt;gateway url&gt;\"))\n</code></pre> <pre><code>const ethStateResolver = new resolver.EthStateResolver(\n    ethURL,\n    contractAddress,\n);\n\nconst resolvers: resolver.Resolvers = {\n    ['polygon:mumbai']: ethStateResolver,\n};\n\nconst verifier = await Verifier.newVerifier(\n    {\n    stateResolver: resolvers,\n    circuitsDir: path.join(__dirname, './circuits-dir'),\n    ipfsGatewayURL:\"&lt;gateway url&gt;\"\n    }\n);\n</code></pre> <p>This creates a resolver which is used to fetch the identity state from the State Smart Contract and a verification key loader which is used to fetch the verification keys necessary to verify a zero-knowledge proof.  Eventually, it returns an instance of a Verifier. To set up a verifier, different parameters need to be passed:</p> <ul> <li><code>circuitsDir</code> is the path where the public verification keys for Iden3 circuits are located (such as <code>\"./circuits\"</code>). If not folder is set './circuits' folder is used. The verification key folder can be found here. Path to the circuit file is constructed from <code>${circuitsDir}/${circuitId}/verification_key.json</code>,</li> <li>hierarchical structure for files in curuits folder is mandatory</li> <li>e.g. --circuits</li> <li>-----circuitId</li> <li> <p>---------file</p> </li> <li> <p><code>ethURL</code> is the URL of your RPC node provider such as <code>\"https://polygon-testnet-rpc.allthatnode.com:8545\"</code> for Polygon Mumbai.</p> </li> <li><code>contractAddress</code> is the address of the identity state Smart Contract. On Polygon Mumbai, it is 0x134B1BE34911E39A8397ec6289782989729807a4.</li> <li><code>resolverPrefix</code> is the prefix of the resolver. For Polygon Mumbai it is <code>\"polygon:mumbai\"</code></li> <li><code>ipfsGatewayURL</code> can be your IPFS gateway or public one. You can path your loader or IPFS node also.</li> </ul> <p>Execute the verification</p> GoLangJavascript <pre><code>authResponse, err := verifier.FullVerify(\n    r.Context(),\n    string(tokenBytes),\n    authRequest.(protocol.AuthorizationRequestMessage),\n    pubsignals.WithAcceptedStateTransitionDelay(time.Minute*5))\n</code></pre> <pre><code>let authResponse: protocol.AuthorizationResponseMessage;\n\nconst opts: VerifyOpts = {\n    AcceptedStateTransitionDelay: 5 * 60 * 1000, // 5 minute\n  };\n\nauthResponse = await verifier.fullVerify(tokenStr, authRequest, opts);\n</code></pre> <p>Execute the verification. It verifies that the proof shared by the user satisfies the criteria set by the Verifier inside the initial request. <code>tokenBytes</code> contains the proof generated by the user's wallet. <code>authRequest</code> is the request previously presented to that specific user. <code>AcceptedStateTransitionDelay(time.Minute*5))</code> is the delay accepted by the Verifier. By setting it to 5 minutes, as in this case, the Verifier accepts a proof that verifies the validity of a credential against a state, as stated in the Smart Contract, which is up to 5 minutes old.</p> <p>An example of the usage of this API can be found here (GO) and here (JS)</p>"},{"location":"verifier/verification-library/verification-api-guide/#verification-under-the-hood","title":"Verification - Under the Hood","text":"<p>The auth library provides a simple handler to extract all the necessary metadata from the proof and execute all the verifications needed. The verification procedure that is happening behind the scenes involves the following steps: </p>"},{"location":"verifier/verification-library/verification-api-guide/#zero-knowledge-proof-verification","title":"Zero-Knowledge Proof Verification","text":"<p>Starting from the circuit-specific public verification key, the proof, and the public inputs provided by the user, it is possible to verify the proof. In this case, the proof verification involves: </p> <ul> <li>Verification of the proof contained based on the <code>AuthV2 Circuit</code></li> <li>Verification of the proof contained based on the <code>AtomicQuerySigV2 Circuit</code> or <code>AtomicQueryMTPV2</code> based on the query.</li> </ul>"},{"location":"verifier/verification-library/verification-api-guide/#verification-of-on-chain-identity-states","title":"Verification of On-chain Identity States","text":"<p>Starting from the DID of the user, the State is fetched from the blockchain and compared to the state provided as input to the proof; this is done to check whether the user is the actual \"owner\" of the state used to generate the proof or not. It is important to note here that there is no gas cost associated with the verification as the VerifyState method just reads the identity state of the user on-chain without making any operations/smart contract calls. The same verification is performed for the Issuer's Identity State.</p> <p>In this part, it is also verified that the requested credential has not been revoked by the Issuer.</p>"},{"location":"verifier/verification-library/verification-api-guide/#verification-of-circuit-public-inputs","title":"Verification of Circuit Public Inputs","text":"<p>This involves a verification based on the public inputs of the circuits used to generate the proof. These must match the rules requested by the Verifier inside the Auth Request. For example, the query and the credential schema used by the user to generate the proof must match the Auth Request:</p> <ul> <li>The message signed by the user must match the one passed to the user inside the auth request.</li> <li>The rules such as the <code>query</code> or the credential <code>schema</code> used to generate the proof must match the ones included inside the auth request. </li> </ul> <p>This \"off-circuit\" verification is important because a user can potentially modify the query and present a valid proof. A user born after 2000-12-31 shouldn't pass the check. But if they generate a proof using a query input <code>\"$lt\": 20010101</code>, the Verifier would see it as a valid proof. By doing verification of the public inputs of the circuit, the Verifier is able to detect malicious actors.</p> <p>At the end of the workflow:</p> <ul> <li>The web client is able to authenticate the user using its DID <code>ID</code> after having established that the user controls that identity and satisfies the query presented in the auth request.</li> <li>The user is able to log into the platform without disclosing any personal information to the client except for its DID.</li> </ul>"},{"location":"verifier/verification-library/verifier-library-intro/","title":"Introduction","text":""},{"location":"verifier/verification-library/verifier-library-intro/#introduction","title":"Introduction","text":"Off-chain verification workflow  <p>At its core, every off-chain interaction between a Verifier and a user's Wallet follows this workflow:</p> <ul> <li>A web application designs a request for the users. This is delivered to the user within a QR code (or via deep-linking; it is up to the implementer). This can either be a auth request or a query-based request.</li> <li>The user scans the QR code using his/her mobile ID wallet and parses the request</li> <li>The user fetches the revocation status of the requested credential from the Issuer of that credential.</li> <li>The user generates a zk proof on mobile according to the request of the website starting from the credentials held in his/her wallet. This also contains the zk proof that the credential is not revoked.</li> <li>The user sends the zk proof to the Verifier.</li> <li>The Verifier verifies the zk proof using the verification API.</li> <li>The Verifier checks that the State of the Issuer of the credential and the State of the user are still valid and have not been revoked (this is still performed using the same verification API).</li> <li>If the verification is successful, the Verifier grants access to the user (or activates any customized logic)</li> </ul> <p>Assume that the request is: \"Are you over 18 years old?\". The Verifier never gets access to any of the user's credentials. Instead, the Verifier receives a cryptographic proof which, on verification, provides an answer \"yes\" or \"no\" to the previous question. </p> <p>This section provides all the elements needed to integrate off-chain verification with Polygon ID.</p>"},{"location":"verifier/verification-library/verifier-library-intro/#libraries","title":"Libraries","text":"<p>The authentication flow can be implemented either in GoLang or Javascript</p> <ul> <li> <p>Go Iden3 Verification Library</p> </li> <li> <p>JS Iden3 Verification Library</p> </li> </ul>"},{"location":"verifier/verification-library/verifier-set-up/","title":"Tutorial - Run a Verifier","text":""},{"location":"verifier/verification-library/verifier-set-up/#run-a-verifier","title":"Run a Verifier","text":"<p>Any application that wants to authenticate users based on their Polygon ID Identity off-chain must set up a Verifier. A Verifier is made of a Server and a Client. </p> <p>The Server generates the ZK Request according to the requirements of the platform. There are two types of authentication:</p> <ul> <li>Basic Auth: For example, a platform that issues Credentials must authenticate users by their identifiers before sharing Credentials with them. </li> <li>Query-based Auth: For example, a platform that gives access only to those users that are over 18 years of age.</li> </ul> <p>The second role of the Server is to execute Verification of the proof sent by the Identity Wallet.</p> <p>The Verifier Client is the point of interaction with the user. In its simplest form, a client needs to embed a QR code that displays the zk request generated by the Server. The verification request can also be delivered to users via Deep Linking. After scanning the zk request, the user will generate a proof based on that request locally on their wallet. This proof is therefore sent back to the Verifier Server that verifies whether the proof is valid.</p> <p>This tutorial is based on the verification of a Credential of Type <code>KYCAgeCredential</code> with an attribute <code>birthday</code> with a Schema URL <code>https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld</code>.</p> <p>The prerequisite is that users have the Polygon ID Wallet app installed and self-issued a Credential of type <code>KYC Age Credential Merklized</code> using our Demo Issuer. Further credentials can be issued using the Issuer Node.</p> <p>In this example, the verifier will set up the query: \"Prove that you were born before the <code>2000/01/01</code>. To set up a different query check out the ZK Query Language section</p> <p>Note: The executable code for this section can be found here.</p>"},{"location":"verifier/verification-library/verifier-set-up/#verifier-server-setup","title":"Verifier Server Setup","text":"<ol> <li> <p>Add the authorization package to your project </p> GoLangJavascript <pre><code>go get github.com/iden3/go-iden3-auth/v2\n</code></pre> <pre><code>npm i @iden3/js-iden3-auth\n</code></pre> </li> <li> <p>Set up a server </p> <p>Initiate a server that contains two endpoints: </p> <ul> <li>GET /api/sign-in: Returns auth request.</li> <li>POST /api/callback: Receives the callback request from the identity wallet containing the proof and verifies it.</li> </ul> GoLangJavascript <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n\n    \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/iden3/go-circuits/v2\"\n    auth \"github.com/iden3/go-iden3-auth/v2\"\n    \"github.com/iden3/go-iden3-auth/v2/loaders\"\n    \"github.com/iden3/go-iden3-auth/v2/pubsignals\"\n    \"github.com/iden3/go-iden3-auth/v2/state\"\n    \"github.com/iden3/iden3comm/v2/protocol\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/api/sign-in\", GetAuthRequest)\n    http.HandleFunc(\"/api/callback\", Callback)\n    http.ListenAndServe(\":8080\", nil)\n}\n\n// Create a map to store the auth requests and their session IDs\nvar requestMap = make(map[string]interface{})\n</code></pre> <pre><code>const express = require('express');\nconst {auth, resolver, protocol} = require('@iden3/js-iden3-auth')\nconst getRawBody = require('raw-body')\n\nconst app = express();\nconst port = 8080;\n\napp.get(\"/api/sign-in\", (req, res) =&gt; {\n    console.log('get Auth Request');\n    GetAuthRequest(req,res);\n});\n\napp.post(\"/api/callback\", (req, res) =&gt; {\n    console.log('callback');\n    Callback(req,res);\n});\n\napp.listen(port, () =&gt; {\n    console.log('server running on port 8080');\n});\n\n// Create a map to store the auth requests and their session IDs\nconst requestMap = new Map();\n</code></pre> </li> <li> <p>Sign-in endpoint </p> <p>This endpoint generates the auth request for the user. Using this endpoint, the developers set up the requirements that users must meet in order to authenticate.</p> <p>If created using Polygon ID Platform, the schema URL can be fetched from there and pasted inside your Query</p> GoLangJavascript <pre><code>func GetAuthRequest(w http.ResponseWriter, r *http.Request) {\n\n    // Audience is verifier id\n    rURL := \"NGROK URL\"\n    sessionID := 1\n    CallbackURL := \"/api/callback\"\n    Audience := \"did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs\"\n\n    uri := fmt.Sprintf(\"%s%s?sessionId=%s\", rURL, CallbackURL, strconv.Itoa(sessionID))\n\n    // Generate request for basic authentication\n    var request protocol.AuthorizationRequestMessage = auth.CreateAuthorizationRequest(\"test flow\", Audience, uri)\n\n    request.ID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\"\n    request.ThreadID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\"\n\n    // Add request for a specific proof\n    var mtpProofRequest protocol.ZeroKnowledgeProofRequest\n    mtpProofRequest.ID = 1\n    mtpProofRequest.CircuitID = string(circuits.AtomicQuerySigV2CircuitID)\n    mtpProofRequest.Query = map[string]interface{}{\n        \"allowedIssuers\": []string{\"*\"},\n        \"credentialSubject\": map[string]interface{}{\n            \"birthday\": map[string]interface{}{\n                \"$lt\": 20000101,\n            },\n        },\n        \"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n        \"type\":    \"KYCAgeCredential\",\n    }\n    request.Body.Scope = append(request.Body.Scope, mtpProofRequest)\n\n    // Store auth request in map associated with session ID\n    requestMap[strconv.Itoa(sessionID)] = request\n\n    // print request\n    fmt.Println(request)\n\n    msgBytes, _ := json.Marshal(request)\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    w.Write(msgBytes)\n    return\n}\n</code></pre> <pre><code>async function GetAuthRequest(req,res) {\n\n    // Audience is verifier id\n    const hostUrl = \"&lt;NGROK_URL&gt;\";\n    const sessionId = 1;\n    const callbackURL = \"/api/callback\"\n    const audience = \"did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs\"\n\n    const uri = `${hostUrl}${callbackURL}?sessionId=${sessionId}`;\n\n    // Generate request for basic authentication\n    const request = auth.createAuthorizationRequest(\n        'test flow',\n        audience,\n        uri,\n    );\n\n    request.id = '7f38a193-0918-4a48-9fac-36adfdb8b542';\n    request.thid = '7f38a193-0918-4a48-9fac-36adfdb8b542';\n\n    // Add request for a specific proof\n    const proofRequest = {\n        id: 1,\n        circuitId: 'credentialAtomicQuerySigV2',\n        query: {\n          allowedIssuers: ['*'],\n          type: 'KYCAgeCredential',\n          context: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld',\n          credentialSubject: {\n            birthday: {\n              $lt: 20000101,\n            },\n          },\n      },\n      };\n    const scope = request.body.scope ?? [];\n    request.body.scope = [...scope, proofRequest];\n\n    // Store auth request in map associated with session ID\n    requestMap.set(`${sessionId}`, request);\n\n    return res.status(200).set('Content-Type', 'application/json').send(request);\n}\n</code></pre> <p>Allowed Issuers</p> <p>When we use <code>*</code> in the \"allowed issuers\" segment (<code>allowedIssuers: ['*']</code>), we mean that we accept any entity that might have provided the credential. Even though this seems to be convenient for testing purposes, it may also be considered risky. Applying due diligence by actually choosing trusted specific issuers should be the best approach. Only in rare cases, a verifier would accept any issuer, so we advise not to use <code>*</code>.   </p> <p>Note</p> <p>The highlighted lines are to be added only if the authentication needs to design a query for a specific proof as in the case of Query-based Auth. When not included, it will perform a Basic Auth. </p> </li> <li> <p>Callback Endpoint</p> <p>The request generated in the previous endpoint already contains the CallBackURL so that the response generated by the wallet will be automatically forwarded to the server callback function. The callback post endpoint receives the proof generated by the identity wallet. The role of the callback endpoint is to execute the Verification on the proof.</p> <p>Testnet / Mainnet</p> <p>The code samples on this page are using Polygon's Testnet Mumbai, including the smart contract address and the RPC endpoint in the <code>ethURL</code> variable. If you want to use the Mainnet, you need to add a resolver for it. </p> <p>Mainnet contract address: <code>0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D</code></p> <p>DID prefix: <code>polygon:main</code></p> <pre><code>const RPC_URL = 'RPC_URL&gt;';\nconst mainContractAddress = \"0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D\"\n\nconst mainStateResolver = new resolver.EthStateResolver(\n    RPC_URL,\n    mainContractAddress,\n);\n\nconst resolvers = {\n    ['polygon:mumbai']: ethStateResolver,\n    ['polygon:main']: mainStateResolver,\n};\n</code></pre> <p>A Verifier can work with multiple networks simultaneously. Even users and issuers can be on different networks. The verifier library can properly resolve the state of the issuer and the user from the different networks.</p> <p>Note</p> <p>The public verification keys for Iden3 circuits generated after the trusted setup can be found here and must be added to your project inside a folder called <code>keys</code>. </p> GoLangJavascript <pre><code>// Callback works with sign-in callbacks\nfunc Callback(w http.ResponseWriter, r *http.Request) {\n\n    // Get session ID from request\n    sessionID := r.URL.Query().Get(\"sessionId\")\n\n    // get JWZ token params from the post request\n    tokenBytes, _ := io.ReadAll(r.Body)\n\n    // Add Polygon Mumbai RPC node endpoint - needed to read on-chain state\n    ethURL := \"https://polygon-testnet-rpc.allthatnode.com:8545\"\n\n    // Add IPFS url - needed to load schemas from IPFS \n    ipfsURL := \"https://ipfs.io\"\n\n    // Add identity state contract address\n    contractAddress := \"0x134B1BE34911E39A8397ec6289782989729807a4\"\n\n    resolverPrefix := \"polygon:mumbai\"\n\n    // Locate the directory that contains circuit's verification keys\n    keyDIR := \"../keys\"\n\n    // fetch authRequest from sessionID\n    authRequest := requestMap[sessionID]\n\n    // print authRequest\n    fmt.Println(authRequest)\n\n    // load the verifcation key\n    var verificationKeyloader = &amp;loaders.FSKeyLoader{Dir: keyDIR}\n    resolver := state.ETHResolver{\n        RPCUrl:          ethURL,\n        ContractAddress: common.HexToAddress(contractAddress),\n    }\n\n    resolvers := map[string]pubsignals.StateResolver{\n        resolverPrefix: resolver,\n    }\n\n    // EXECUTE VERIFICATION\n    verifier, err := auth.NewVerifier(verificationKeyloader, resolvers, auth.WithIPFSGateway(ipfsURL))\n    if err != nil {\n        log.Println(err.Error())\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    authResponse, err := verifier.FullVerify(\n        r.Context(),\n        string(tokenBytes),\n        authRequest.(protocol.AuthorizationRequestMessage),\n        pubsignals.WithAcceptedStateTransitionDelay(time.Minute*5))\n    if err != nil {\n        log.Println(err.Error())\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    userID := authResponse.From\n\n    messageBytes := []byte(\"User with ID \" + userID + \" Successfully authenticated\")\n\n    w.WriteHeader(http.StatusOK)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Write(messageBytes)\n\n    return\n}\n</code></pre> <pre><code>async function Callback(req,res) {\n\n    // Get session ID from request\n    const sessionId = req.query.sessionId;\n\n    // get JWZ token params from the post request\n    const raw = await getRawBody(req);\n    const tokenStr = raw.toString().trim();\n\n    const ethURL = '&lt;MUMBAI_RPC_URL&gt;';\n    const contractAddress = \"0x134B1BE34911E39A8397ec6289782989729807a4\"\n    const keyDIR = \"../keys\"\n\n    const ethStateResolver = new resolver.EthStateResolver(\n        ethURL,\n        contractAddress,\n      );\n\n    const resolvers = {\n        ['polygon:mumbai']: ethStateResolver,\n    };\n\n\n    // fetch authRequest from sessionID\n    const authRequest = requestMap.get(`${sessionId}`);\n\n\n    // EXECUTE VERIFICATION\n    const verifier = await auth.Verifier.newVerifier(\n            {\n            stateResolver: resolvers,\n            circuitsDir: path.join(__dirname, './circuits-dir'),\n            ipfsGatewayURL:\"&lt;gateway url&gt;\"\n            }\n    );\n\n\ntry {\n    const opts = {\n        AcceptedStateTransitionDelay: 5 * 60 * 1000, // 5 minute\n      };        \n    authResponse = await verifier.fullVerify(tokenStr, authRequest, opts);\n} catch (error) {\nreturn res.status(500).send(error);\n}\nreturn res.status(200).set('Content-Type', 'application/json').send(\"user with ID: \" + authResponse.from + \" Succesfully authenticated\");\n}\n</code></pre> </li> </ol> <p>If you need to deploy an App or to build a Docker container, you'll need to bundle the libwasmer.so library together with the app. </p>"},{"location":"verifier/verification-library/verifier-set-up/#verifier-client-setup","title":"Verifier Client Setup","text":"<p>The Verifier Client must fetch the Auth Request generated by the Server (\"/api/sign-in\" endpoint) and deliver it to the user via a QR Code. </p> <p>To display the QR code inside your frontend, you can use this Code Sandbox </p> <p>Verifier can show QR that contains one of the following data structures:</p> <ul> <li>Raw JSON - message will be threated as on of the IDEN3 Protocol messages.</li> <li>Link with base64 encoded message or shortened request uri (encoded url) in case base64 encoded message is too large. Possible formats of links are: <ol> <li><code>iden3comm://?i_m={{base64EncodedRequestHere}}</code></li> <li><code>iden3comm://?request_uri={{shortenedUrl}}</code></li> </ol> </li> </ul> <p>if both params are present <code>i_m</code> is priority param and <code>request_uri</code> is ignored.</p> <p>The same request can also be delivered to users via Deep Linking. Same format for links must be used.</p> <p>Polygon ID wallet</p> <p>Polygon ID wallet will support handling of <code>request_uri</code> in the next release, while your client can already implement this specification.</p> <p>Shortened url algorithm</p> <p>While it's not strictly restricted how you can perform url shortage algorithm, it is recommended to follow next instruction:</p> <ol> <li>Generate uuid for particular request (or use id of the message itself )</li> <li>Implement endpoint to fetch message by uuid.</li> <li>Encode url to fetch message to <code>the request_uri</code>.</li> </ol> <p>Example of url shortage logic:</p> GoLangJavascript <pre><code>    package handlers\n\n    import (\n        \"encoding/json\"\n        \"fmt\"\n        \"io\"\n        \"net/http\"\n        \"os\"\n        \"time\"\n        \"github.com/gofrs/uuid\"\n        \"github.com/patrickmn/go-cache\"\n    )\n\n    var cacheStorage = cache.New(60*time.Minute, 60*time.Minute)    \n\n    func HandleQRData(w http.ResponseWriter, r *http.Request) {\n        switch r.Method {\n\n        // create url for the message\n        case http.MethodPost:\n\n            // get json data from request body\n            var data interface{}\n            body, err := io.ReadAll(r.Body)\n            if err != nil {\n                http.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n                return\n            }\n            defer r.Body.Close()\n\n            err = json.Unmarshal(body, &amp;data)\n            if err != nil {\n                http.Error(w, \"Failed to unmarshal body data\", http.StatusInternalServerError)\n                return\n            }\n\n            // generate random key\n            uv, err := uuid.NewV4()\n\n            if err != nil {\n                http.Error(w, \"Failed to generate uuid\", http.StatusInternalServerError)\n                return\n            }\n\n            // store data in map\n            cacheStorage.Set(uv.String(), data, 1*time.Hour)\n\n            hostURL := os.Getenv(\"HOST_URL\") // e.g. https://verifier.com\n            // write key to response\n            fmt.Fprintf(w, \"%s%s?id=%s\", hostURL, \"api/qr-store\", uv.String())\n            return  \n\n        // get message by identifier    \n        case http.MethodGet:\n\n            // get path param\n            id := r.URL.Query().Get(\"id\")\n            if id == \"\" {\n                http.Error(w, \"Failed to get id\", http.StatusNotFound)\n                return\n            }\n            // get data from map\n            data, ok := cacheStorage.Get(id)\n\n            if !ok {\n                http.Error(w, fmt.Sprintf(\"Failed to retrieve QR data by %s\", id), http.StatusNotFound)\n                return\n            }\n\n            jsonData, err := json.Marshal(data)\n            if err != nil {\n                http.Error(w, \"Failed to encode JSON\", http.StatusInternalServerError)\n                return\n            }\n\n            // write data to response\n            w.WriteHeader(http.StatusOK)\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            w.Write(jsonData)\n            return\n        }\n    }\n</code></pre> <pre><code>    const express = require('express');\n    const { v4: uuidv4 } = require('uuid');\n    const Cache = require('cache-manager');\n    const HttpStatus = require('http-status-codes');\n\n    const app = express();\n    app.use(express.json());\n\n    const cPromise = Cache.caching('memory', {\n        max: 100,\n        ttl: 10 * 1000 /*milliseconds*/,\n    });\n    app.get('/api/qr-store', async (req, res) =&gt; {\n    const id = req.query.id;\n    const cacheManager = await cPromise;\n    const data = await cacheManager.get(id);\n\n    if (!data) {\n        return res.status(HttpStatus.NOT_FOUND).json({ error: `item not found ${id}` });\n    }\n\n    return res.status(HttpStatus.OK).json(data);\n    });\n\n    app.post('/api/qr-store', async (req, res) =&gt; {\n    const body = req.body;\n    const uuid = uuidv4();\n    const cacheManager = await cPromise;\n\n    console.log(cacheManager);\n\n    await cacheManager.set(uuid, body, { ttl: 3600 });\n\n    const hostUrl = process.env.HOST_URL;\n    const qrUrl = `${hostUrl}/api/qr-store?id=${uuid}`;\n\n    return res.status(HttpStatus.OK).json({ qrUrl });\n    });\n\n    app.listen(3000, () =&gt; {\n    console.log('Express server is running on port 3000');\n\n    });\n</code></pre> <p>Implement Further Logic</p> <p>This tutorial showcased a minimalistic application that leverages Polygon ID libraries for authentication purposes. Developers can leverage the broad set of existing Credentials held by users to set up any customized Query using our zk Query Language to unleash the full potential of the framework. </p> <p>For example, the concept can be extended to exchanges that require KYC Credentials, DAOs that require proof-of-personhood Credentials, or social media applications that intend to re-use users' aggregated reputation.</p> <p>To do so, add the Static Folder to your Verifier repository. This folder contains an HTML static webpage that renders a static webpage with the QR code containing the Auth Request.</p> <p>To display the QR code inside your frontend, you can use the <code>express.static</code> built-in middleware function together with this Static Folder or this Code Sandbox.</p> <ol> <li> <p>Add routing to your Express Server</p> <p>To serve static files, we use the express.static built-in middleware function.</p> <pre><code>const express = require('express');\nconst {auth, resolver, protocol} = require('@iden3/js-iden3-auth')\nconst getRawBody = require('raw-body')\n\nconst app = express();\nconst port = 8080;\n\napp.use(express.static('static'));\n\napp.get(\"/api/sign-in\", (req, res) =&gt; {\n    console.log('get Auth Request');\n    GetAuthRequest(req,res);\n});\n\napp.post(\"/api/callback\", (req, res) =&gt; {\n    console.log('callback');\n    Callback(req,res);\n});\n\napp.listen(port, () =&gt; {\n    console.log('server running on port 8080');\n});\n\n// Create a map to store the auth requests and their session IDs\nconst requestMap = new Map();\n</code></pre> </li> <li> <p>Visit http://localhost:8080/</p> <p>When visiting the URL, the users will need to scan the QR code with their id wallets.</p> <p></p>  Sign Up with Polygon ID - Client Side  </li> </ol>"},{"location":"verifier/verification-library/zk-query-language/","title":"ZK Query Language","text":""},{"location":"verifier/verification-library/zk-query-language/#query-language","title":"Query Language","text":"<p>The <code>Atomic Query Signature V2 Circuit</code> and <code>Atomic Query MTP V2 Circuit</code> circuits have been designed as generic circuits to do the zk verification based on users' claims. </p> <p>The Query Language sits on top of these circuits to provide a simple way for developers to design customised authentication requirements based on someone's credentials. As long as the user holds a credential of a specific type, the Verifier can design a query related to the Credentials based on 6 operators, for example:  </p> <ul> <li>Must be a verified human to vote for a DAO specific proposal - <code>equals</code> (operator 1).</li> <li>Must have been born before 2000-01-01 to access an adult content website - <code>less-than</code> (operator 2).</li> <li>Must have a monthly salary greater than $1000 to get a loan - <code>greater-than</code> (operator 3).</li> <li>Must be an admin or a hacker of a Dao to enter a platform - <code>\u00ecn</code> (operator 4).</li> <li>Must not be a resident of a country in the list of blacklisted countries to operate on an exchange - <code>not-in</code> (operator 5).</li> <li>Must not be a resident of a specific country - <code>not-equal</code> (operator 6).</li> </ul> <p>The query is designed by the Verifier and presented to the user via a QR Code (or deep-linking). Starting from the proof generated by the user as a response to the query, the Verifier is easily able to check if the query is satisfied or not. The Verifier doesn't get access to any user's data.</p> <p>The Query Language follows the same rules whether the verification is implemented on-chain or off-chain, while the syntax to define these is a bit different. For each of the query presented above, both the on-chain and off-chain way of designing will now be defined. </p> <p>The entire scripts to set a query are available here: off-chain verification, on-chain verification</p> <p>Further examples of how to setup customized queries will be released soon!</p>"},{"location":"verifier/verification-library/zk-query-language/#equals-operator-1","title":"Equals - Operator 1","text":"<p>Credential Schema</p> <p>The <code>ProofOfHumanity</code> Schema encodes whether a user has been verified as a human or not. Here's the JSON-LD Context of the Schema Type.</p> <p>You can create customised schemas, check out this tutorial! </p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is a Person.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\n      id: 1,\n      circuitId: 'credentialAtomicQuerySigV2',\n      query: {\n        allowedIssuers: ['*'],\n        type: 'ProofOfHumanity',\n        context: 'https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-humanity/proof-of-humanity.jsonld',\n        credentialSubject: {\n        isHuman: {\n          $eq: 1,\n        },\n        },\n      },\n    };\n</code></pre> <p></p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"324849518749029195374186444632030216125\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"14815366841010849835350402710291849818496586666144492189460088557509920034090\"\n\nconst requestId = 1;\n\nconst query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: 1,\n    value: [1, ...new Array(63).fill(0).map(i =&gt; 0)], // for operators 1,2,3,6 only first value matters\n    };\n</code></pre> <pre><code>// Corresponding QR Code\n{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract address\" : \"&lt;add your contract address here&gt;\", // replace with your contract address\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-humanity/proof-of-humanity.jsonld\",\n                    \"credentialSubject\": {\n                        \"isHuman\": {\n                            \"$eq\": 1\n                        }\n                    },\n                    \"type\": \"ProofOfHumanity\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"verifier/verification-library/zk-query-language/#less-than-operator-2","title":"Less-than - Operator 2","text":"<p>Credential Schema</p> <p>The <code>KYCAgeCredential</code> Schema encodes the date of birth of the credential subject. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she has been born before 2001/01/01.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\n      id: 1,\n      circuitId: 'credentialAtomicQuerySigV2',\n      query: {\n        allowedIssuers: ['*'],\n        type: 'KYCAgeCredential',\n        context: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld',\n        credentialSubject: {\n        birthday: {\n          $lt: 20010101,\n        },\n        },\n      },\n    };\n</code></pre> <p></p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"267831521922558027206082390043321796944\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"20376033832371109177683048456014525905119173674985843915445634726167450989630\"\n\nconst requestId = 1;\n\nconst query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: 1,\n    value: [1, ...new Array(63).fill(0).map(i =&gt; 0)],  // for operators 1,2,3,6 only first value matters\n    };\n</code></pre> <pre><code>// Corresponding QR Code\n{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract address\" : \"&lt;add your contract address here&gt;\",\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld\",\n                    \"credentialSubject\": {\n                        \"birthday\": {\n                            \"$lt\": 20010101\n                        }\n                    },\n                    \"type\": \"KYCAgeCredential\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"verifier/verification-library/zk-query-language/#greater-than-operator-3","title":"Greater-than - Operator 3","text":"<p>Credential Schema</p> <p>The <code>EmployeeData</code> Schema encodes the monthly salary of the credential subject. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that his/her monthly salary is greater than $1000.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\n      id: 1,\n      circuitId: 'credentialAtomicQuerySigV2',\n      query: {\n        allowedIssuers: ['*'],\n        type: 'EmployeeData',\n        context: 'https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/employee-data/employee-data.jsonld',\n        credentialSubject: {\n        monthlySalary: {\n          $gt: 1000,\n        },\n        },\n      },\n    };\n</code></pre> <p></p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"215529050624769177581695011121804343416\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"18323209396655941018370955962714740724727867245625378697671016248362870463698\"\n\nconst requestId = 1;\n\nconst query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: 3, // operator\n    value: [1000, ...new Array(63).fill(0).map(i =&gt; 0)],\n};\n</code></pre> <pre><code>{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract address\" : \"&lt;add your contract address here&gt;\",\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/employee-data/employee-data.jsonld\",\n                    \"credentialSubject\": {\n                        \"monthlySalary\": {\n                            \"$gt\": 1000\n                        }\n                    },\n                    \"type\": \"EmployeeData\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"verifier/verification-library/zk-query-language/#in-operator-4","title":"In - Operator 4","text":"<p>Credential Schema</p> <p>The <code>ProofOfDaoRole</code> Schema encodes the role of someone inside a DAO. Each role is identified by a code as described in the Schema Vocab.</p> <p>Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is either an Admin or a Hacker of a DAO (which corresponds to value 4 and 5).</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\n      id: 1,\n      circuitId: 'credentialAtomicQuerySigV2',\n      query: {\n        allowedIssuers: ['*'],\n        type: 'ProofOfDaoRole',\n        context: 'https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-dao-role/proof-of-dao-role.jsonld',\n        credentialSubject: {\n        role: {\n          $in: [4, 5],\n        },\n        },\n      },\n    };\n</code></pre> <p></p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"80689572245316684375295691372009959153\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"19483179179477598314891505360164348442915562939736565831310034495973163044179\"\n\nconst requestId = 1;\n\nconst query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: 4, // operator\n    value: [4, 5, ...new Array(62).fill(0).map(i =&gt; 0)],\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract address\" : \"&lt;add your contract address here&gt;\",\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-dao-role/proof-of-dao-role.jsonld\",\n                    \"credentialSubject\": {\n                        \"role\": {\n                            \"$in\": [4, 5]\n                        }\n                    },\n                    \"type\": \"ProofOfDaoRole\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"verifier/verification-library/zk-query-language/#not-in-operator-5","title":"Not-in - Operator 5","text":"<p>Credential Schema</p> <p>The <code>KYCCountryOfResidenceCredential</code> Schema encodes the countryCode of residence of the credential subject according to the ISO Standard. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is not resident of the countries <code>840, 120, 340, 509</code> identified following the ISO Standard.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\n      id: 1,\n      circuitId: 'credentialAtomicQuerySigV2',\n      query: {\n        allowedIssuers: ['*'],\n        type: 'KYCCountryOfResidenceCredential',\n        context: 'https://github.com/iden3/claim-schema-vocab/blob/main/schemas/json-ld/kyc-v4.jsonld',\n        credentialSubject: {\n        countryCode: {\n          $nin: [840, 120, 340, 509],\n        },\n        },\n      },\n    };\n</code></pre> <p></p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"201134713754279235117373236841506344285\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"17002437119434618783545694633038537380726339994244684348913844923422470806844\"\n\nconst requestId = 1;\n\nconst query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: 5, // operator\n    value: [840, 120, 340, 509, ...new Array(60).fill(0).map(i =&gt; 0)],\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract address\" : \"&lt;add your contract address here&gt;\",\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld\",\n                    \"credentialSubject\": {\n                        \"countryCode\": {\n                            \"$nin\": [840, 120, 340, 509]\n                        }\n                    },\n                    \"type\": \"KYCCountryOfResidenceCredential\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"verifier/verification-library/zk-query-language/#not-equal-operator-6","title":"Not-equal - Operator 6","text":"<p>Credential Schema</p> <p>The <code>KYCCountryOfResidenceCredential</code> Schema encodes the countryCode of residence of the credential subject according to the ISO Standard. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is not resident of the country <code>840</code> identified following the ISO Standard.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\n      id: 1,\n      circuitId: 'credentialAtomicQuerySigV2',\n      query: {\n        allowedIssuers: ['*'],\n        type: 'KYCCountryOfResidenceCredential',\n        context: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld',\n        credentialSubject: {\n        countryCode: {\n          $ne: 840\n        },\n        },\n      },\n    };\n</code></pre> <p></p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"201134713754279235117373236841506344285\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"17002437119434618783545694633038537380726339994244684348913844923422470806844\"\n\nconst requestId = 1;\n\nconst query = {\n    schema: schemaBigInt,\n    claimPathKey  : schemaClaimPathKey,\n    operator: 6,\n    value: [840, ...new Array(63).fill(0).map(i =&gt; 0)], // for operators 1,2,3,6 only first value matters\n    };\n</code></pre> <pre><code>// Corresponding QR Code\n{\n    \"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"body\": {\n        \"reason\": \"airdrop participation\",\n        \"transaction_data\": {\n            \"contract address\" : \"&lt;add your contract address here&gt;\",\n            \"method_id\": \"b68967e2\",\n            \"chain_id\": 80001,\n            \"network\": \"polygon-mumbai\"\n        },\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n                \"query\": {\n                    \"allowedIssuers\": [\n                        \"*\"\n                    ],\n                    \"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld\",\n                    \"credentialSubject\": {\n                        \"countryCode\": {\n                            \"$ne\": 840\n                        }\n                    },\n                    \"type\": \"KYCCountryOfResidenceCredential\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"verifier/verification-library/zk-query-language/#selective-disclosure","title":"Selective Disclosure","text":"<p>Selective Disclosure is a feature provided for the Verifier, which makes it capable of requiring some specific data from the ID Holder. Using a similar approach to the ZK language equal operation, the Verifier sends a verification request for a piece of the Holder's identity. As seen below, the way to make this request is by sending an empty object as a value.</p> <p>Query</p> <p>In the example below, the verifier requests the Holder's country code.</p> Off-chain<pre><code>const proofRequest: protocol.ZKPRequest = {\n    id: 1,\n    circuitId: 'credentialAtomicQuerySigV2',\n    query: {\n        allowedIssuers: ['*'],\n        type: 'KYCCountryOfResidenceCredential',\n        context: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld',\n        credentialSubject: {\n            countryCode: {},\n        },\n    },\n};\n</code></pre> <p>Allowed Issuers</p> <p>When we use <code>*</code> in the \"allowed issuers\" segment (<code>allowedIssuers: ['*']</code>), we mean that we accept any entity that might have provided the credential. Even though this seems to be convenient for testing purposes, it may also be considered risky. Applying due diligence by actually choosing trusted specific issuers should be the best approach. Only in rare cases, a verifier would accept any issuer, so we advise not to use <code>*</code>. </p>"},{"location":"wallet/features/","title":"Features","text":""},{"location":"wallet/features/#profile-selection","title":"Profile Selection","text":"<p>Whenever an ID Holder creates a connection with an Issuer, the Holder can select what kind of profile is more appropriate for that interaction. In this way, aside from the public profile (the original DID), they can also have a different identifier for each connection they might have with an Issuer, which is called a private profile.</p> <p>You can always switch profiles:  </p> <p>Info</p> <p>Your private profile generates a unique identifier for the organization you created it with, ensuring that your connections and interactions with them cannot be linked to any other organizations.</p>"},{"location":"wallet/features/#switch-network","title":"Switch Network","text":"<p>Switching networks is also available on Polygon ID. You just need to reach the Settings menu and tap the network you would like to change to:</p>"},{"location":"wallet/wallet-overview/","title":"Overview","text":""},{"location":"wallet/wallet-overview/#wallet-overview","title":"Wallet Overview","text":"<p>A digital wallet is a software that can hold and manage users' <code>Credentials</code>. Based on the principles of Self-Sovereign Identity (SSI) and cryptography, a wallet helps its Holder share data with others without exposing any other sensitive private information stored on it. Only the wallet holder has the right to decide which information to share with other entities and what needs to remain private. </p> <p>Polygon ID offers some interesting ways to get started with leveraging a credential-focused wallet: the Wallet SDK and the Polygon ID Wallet app.</p>"},{"location":"wallet/wallet-overview/#wallet-sdk","title":"Wallet SDK","text":"<p>The Wallet SDK is a Flutter-based SDK that can be used by developers to build applications or integrate the wallet functionalities seamlessly with their existing apps. Get started with the Wallet SDK here.</p> <p>These are the modules (SDKs) we provide:</p> <ul> <li>polygonid-flutter-sdk [Dart plugin]</li> <li>polygonid-ios-wrapper-sdk [Swift lib (Framework)] (work in progress)</li> <li>(polygonid-android-wrapper-sdk)[https://github.com/0xPolygonID/polygonid-android-sdk] [Kotlin lib (.aar)]</li> <li>Polygonid-react-native-wrapper-sdk [RN lib] (work in progress)</li> </ul> <p>Depending on which type of developer (integrator) you are, you can use different modules (SDK):</p> <ul> <li>Flutter developers should use \"polygonid-flutter-sdk\"</li> <li>IOS developers should use \"polygonid-ios-wrapper-sdk\"</li> <li>Android developers should use \"polygonid-android-wrapper-sdk\"</li> <li> <p>React native developers can use several modules (SDKs): </p> <ul> <li>\"polygonid-ios-wrapper-sdk\" AND \"polygonid-android-wrapper-sdk\" (together for supporting both platforms)</li> </ul> <p>OR </p> <ul> <li>\"Polygonid-react-native-wrapper-sdk\" (work in progress)</li> </ul> </li> </ul> <p>Info</p> <p>If you are interested in building web-based applications with Polygon ID, please visit the JS SDK documentation. </p>"},{"location":"wallet/wallet-overview/#polygon-id-wallet-app","title":"Polygon ID Wallet app","text":"<p>The Polygon ID Wallet app is a reference implementation built using our Wallet SDK. It has a simple user interface and seamless UX to facilitate its main uses: managing credentials and generating proofs for verifiers. Learn more about the wallet here. </p> <p>The app is available for Android and IOS: </p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul> <p></p>"},{"location":"wallet/wallet-sdk/polygonid-app/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-app/#polygon-id-wallet-overview","title":"Polygon ID Wallet Overview","text":"<p>The Polygon ID Wallet app is a reference implementation built with the Wallet SDK. It is a <code>Privacy by Default</code> wallet that helps protect a user's identity (and other metadata) by using zero-knowledge proofs. The wallet interacts with an Issuer to fetch credentials and with Verifier for sharing zkProofs based on these credentials.</p> <p></p> <p>Note</p> <p>In addition to this reference identity wallet you can see other Polygon ID compatible wallets in our Polygon ID Ecosystem page.</p>"},{"location":"wallet/wallet-sdk/polygonid-app/#quick-start","title":"Quick Start","text":"<p>To get started with the Polygon ID Wallet, download the Polygon ID Wallet App and create an Identity:</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-app/#features-of-the-polygon-id-wallet","title":"Features of the Polygon ID Wallet","text":"<p>The Polygon ID Wallet supports the following features:</p> <ul> <li>Privacy by design and Self-sovereignty: The user is in full control of his/her identity data and exchanges credentials with other identities without the need for an intermediary or centralized authority. </li> <li>Open and Permissionless. </li> <li>Fetching, storing, and managing credentials.</li> <li>Generating cost-optimized zero-knowledge proofs for credentials verification.</li> <li>Communication with Issuer and Verifier.</li> <li>Identity recovery using seed phrase.</li> </ul> <p>It is worth noticing that, in order to comply with the principles of the Self-Sovereign Identity (SSI), all the credentials are stored only locally on your wallet and are not stored on-chain; this ensures strong privacy for the sensitive data related to your credential(s). </p>"},{"location":"wallet/wallet-sdk/polygonid-app/#how-is-polygon-id-wallet-different-from-other-wallets","title":"How is Polygon ID Wallet Different from Other Wallets?","text":"<p>You, at some point in time, must have used cryptographic wallets such as Metamask, Trust Wallet, Coinbase Wallet, Ledger, and so many more. How is Polygon ID Wallet different from all these hot and cold storage wallets? Let us see:</p> <ul> <li> <p>The wallets like Metamask and Trust Wallet are used for sending and receiving crypto transactions on-chain. Polygon ID Wallet, on the other hand, is used for creating and storing unique identities for the wallet so that these identities can be used to authenticate with the Issuer and the Verifier. This Identity wallet helps an Integrator fetch and save credentials from Issuers and also present proof of these credentials to the Verifiers. </p> </li> <li> <p>While the commonly-used crypto wallets let you interact with Ethereum and other blockchain networks using RPCs (Remote Procedure Calls), this is not the case with Polygon ID Wallet - it functions solely to store credentials linked to an identity and lets these credentials get verified by creating zero-knowledge proofs. </p> </li> <li> <p>General wallets store cryptographic keys while the Polygon ID Wallet stores users' identities. While both types of wallets are based on private-public key cryptography, the two are different in the sense that in a wallet like MetaMask, the elliptic curve used is <code>secp256k1</code>, which is used to convert a private key to a public key and eventually to an Ethereum Address, which identifies your wallet. On the other hand, Polygon ID Wallet is based on the <code>Baby Jubjub Key</code> which generates Polygon Id Identifier, which is the identifier for your wallet instead of the Ethereum Wallet Address. </p> </li> </ul>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/","title":"Example App","text":"<p>You can find an executable example app in the source with several call to the SDK, which can guide you through your development.</p>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Clone Repository: Clone the polygonid-android-sdk repository.</p> </li> <li> <p>Run the app:</p> <pre><code>./gradlew installDebug app\n</code></pre> </li> </ol>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#general-flow","title":"General Flow","text":""},{"location":"wallet/wallet-sdk/android-sdk/example-app/#overview","title":"Overview","text":"<p>In the upcoming sections, we shall see the general flow of how to use the Polygon ID SDK plugin. The steps are summarised as:</p> <p>A. Identity</p> <ol> <li>Initialise Polygon ID SDK.</li> <li>Create an Identity for the wallet.</li> <li>Get (Retrieve) Identifier from the Identity created in the previous step.</li> <li>Remove Identity (only if required).</li> <li>Get iden3Message from Issuer.</li> <li>Authenticate Identity using Identifier, iden3Message, and Private Key.</li> </ol> <p>B. Credential</p> <ol> <li>Create CredentialRequestEntity from the Iden3Message received from an Issuer.</li> <li>Fetch and Save credentials (received from Issuer) on SDK using CredentialRequestEntity, Identifier, and Private Key.</li> <li>Get credentials that are saved on wallet SDK. One can also retrieve them with credential IDs.</li> <li>Remove credential (only if required).</li> <li>Update credential (only if required).</li> </ol> <p>C. Proof</p> <ol> <li>Generate zero-knowledge proof using iden3Message, Identifier, and Private Key. </li> </ol>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#steps-in-detail","title":"Steps in Detail","text":""},{"location":"wallet/wallet-sdk/android-sdk/example-app/#sdk","title":"** SDK**","text":""},{"location":"wallet/wallet-sdk/android-sdk/example-app/#initiate-polygon-id-sdk","title":"Initiate Polygon ID SDK","text":"<p>To start using Polygon ID SDK, an integrator needs to initialize it first. This is done by using: </p> <p></p><pre><code>PolygonIdSdk.init(\n    context = context,\n    env = EnvEntity(\n      blockchain = \"polygon\",\n      network = \"mumbai\",\n      web3Url = \"https://polygon-mumbai.infura.io/v3/\",\n      web3RdpUrl = \"wss://polygon-mumbai.infura.io/v3/\",\n      web3ApiKey = \"theApiKey\",\n      idStateContract = \"0x134B1BE34911E39A8397ec6289782989729807a4\",\n      pushUrl = \"https://push-staging.polygonid.com/api/v1\"\n  ),\n)\n</code></pre> <code>env</code> is optional and can be set afterward with <code>PolygonIdSdk.getInstance().setEnv()</code> <p>After the SDK initialization, the Integrator  will need to use the instance of PolygonIdSDK <code>PolygonIdSdk.getInstance()</code>.</p>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#get-current-environment","title":"Get current environment","text":"<p>The current environment can be retrieved using <code>getEnv()</code>, it gives an <code>EnvEntity</code>: </p><pre><code>PolygonIdSdk.getInstance().getEnv(context = context)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#get-iden3message-from-a-string","title":"Get Iden3Message from a String","text":"<p>An Integrator uses <code>iden3Message</code> to communicate with an Issuer/Verifier. This 'iden3message' is created from the QR code scanned by the user on his/her wallet. The <code>getIden3Message()</code> uses a string message (created after scanning the QR code) as the input parameter and generates <code>iden3Message</code>.</p> <pre><code>PolygonIdSdk.getInstance().getIden3Message(\n    context, theMessage\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#a-identity","title":"A. Identity","text":"<p>This part of the flow consists of initialising Polygon ID SDK, creating an identifier for an identity and retrieving it, and using the identifier to authenticate the Identity.</p>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#1-create-identity","title":"1. Create Identity","text":"<p>After SDK initialization, the SDK checks the existence of an Identifier that was previously created with the <code>addIdentity()</code> function. If no previously created Identifier is found, the SDK first needs to create an identity first using <code>addIdentity()</code> function. </p> <pre><code>PolygonIdSdk.getInstance().addIdentity(\n    context = context, secret = \"theSecret\"\n)\n</code></pre> <p>You can retrieve your <code>private key</code> from the <code>PrivateIdentityEntity</code> specified in the code above. Keep this private key safe; it will be used in a few other SDK methods as you will see in the following steps.</p> <p>Note: It is not mandatory to pass the <code>secret</code> as the input parameter in the function. If you do not pass it, a random <code>secret</code> is generated by the system. </p>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#2-get-did-identifier","title":"2. Get did Identifier","text":"<p>This retrieves the <code>did identifier</code> by passing the environment detail and <code>private key</code> input parameter to the <code>getDidIdentifier()</code> function; please note that the <code>private key</code> is generated from <code>PrivateIdentityEntity</code> that we generated via <code>addIdentity()</code> function in the previous section. </p> <pre><code>PolygonIdSdk.getInstance().getDidIdentifier(\n    context = context,\n    privateKey = privateKey,\n    blockchain = env.blockchain,\n    network = env.network,\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#3-remove-identity","title":"3. Remove Identity","text":"<p>To remove an existing Identity (use this only when required), you need to call the <code>removeIdentity()</code> with <code>did identifier</code> and the <code>privateKey</code> as the input parameters. </p> <pre><code>PolygonIdSdk.getInstance().removeIdentity(\n    context = context,\n    privateKey = privateKey,\n    genesisDid = didIdentifier\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#4-authenticate-identity","title":"4. Authenticate Identity","text":"<p>The authentication includes two steps:</p> <ul> <li>Get an iden3message from the QR code as seen on 2.</li> <li>Authenticate Identity using iden3message</li> </ul> <p>We use <code>authenticate()</code> to authenticate an identity by using <code>privateKey</code>, <code>did identifier</code>, and <code>iden3Message</code> as the input parameters. </p> <pre><code>PolygonIdSdk.getInstance().authenticate(\n    context = context,\n    message = message as Iden3MessageEntity.AuthIden3MessageEntity,\n    genesisDid = did,\n    privateKey = privateKey\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#b-credential","title":"B. Credential","text":"<p>This part of the flow consists of retrieving credentials from an Issuer and saving them in the wallet. One or more credentials can be retrieved and one or more credentials can be removed from the wallet. </p>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#1-fetch-and-save-credentials","title":"1. Fetch and Save Credentials","text":"<p>This functionality consists of retrieving credentials from an Issuer (by fetching them) and then saving them on the wallet.</p> <p>This involves:</p> <ul> <li>Get an iden3message from the QR code as seen on 2.</li> <li>Fetching and saving credentials using <code>CredentialRequestEntity</code>, <code>identifier</code>, and <code>privateKey</code>.</li> </ul> <pre><code>PolygonIdSdk.getInstance().fetchAndSaveClaims(\n    context = context,\n    message = message as Iden3MessageEntity.OfferIden3MessageEntity,\n    genesisDid = did,\n    privateKey = privateKey\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#2-get-credentials","title":"2. Get Credentials","text":"<p>Once credentials have been saved on the wallet SDK, these can be retrieved by the Integrator using <code>getClaims()</code> with <code>did identifier</code>, and <code>privateKey</code> used as the mandatory input parameters and <code>filters</code> as an optional one. <code>Filters</code> let an Integrate get credentials based on some pre-determined criteria. </p> <pre><code>PolygonIdSdk.getInstance().getClaims(\n    context = context,\n    genesisDid = did,\n    privateKey = privateKey,\n    filters = filters\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#3-get-credentials-by-ids","title":"3. Get Credentials by Ids","text":"<p>This functionality lets an Integrator get credentials from an Issuer based on their IDs. The list of IDs <code>claimIds</code>, <code>did identifier</code>, and <code>privateKey</code>are passed as input parameters to the <code>getClaimsByIds()</code> function and a list of credentials in the form of <code>ClaimEntity</code> is retrieved.</p> <pre><code>PolygonIdSdk.getInstance().getClaimsByIds(\n    context = context,\n    genesisDid = did,\n    privateKey = privateKey,\n    claimIds = listOf(id)\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#4-remove-a-credential","title":"4. Remove a Credential","text":"<p>A credential can be removed from the wallet using <code>removeClaim()</code> by passing <code>claimId</code> (the ID of the credential to be removed), the <code>did identifier</code> and the <code>privateKey</code> as the input parameters. </p> <pre><code>PolygonIdSdk.getInstance().removeClaim(\n    context = context,\n    genesisDid = did,\n    privateKey = privateKey,\n    claimId = id\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#5-remove-multiple-credentials","title":"5. Remove  Multiple Credentials","text":"<p>This is similar to removing a single credential described above. In this case, you need to pass a list of <code>claimIds</code> to be removed, the <code>did identifier</code>, and the <code>privateKey</code> as the input parameters to <code>removeClaims()</code>.</p> <pre><code>PolygonIdSdk.getInstance().removeClaims(\n    context = context,\n    genesisDid = did,\n    privateKey = privateKey,\n    claimIds = ids\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/example-app/#6-update-credential","title":"6. Update Credential","text":"<p>To update a credential, the <code>updateClaim()</code> function is used with the following fields passed as input parameters:</p> <ul> <li><code>claimId</code></li> <li><code>identifier</code></li> <li><code>privateKey</code></li> <li>other information such as identity <code>state</code>, <code>issuer</code>, credential's <code>expiration</code> date, <code>type</code> of credential, etc. </li> </ul> <pre><code>PolygonIdSdk.getInstance().updateClaim(\n    context = context,\n    claimId = claimId\n    genesisDid = did,\n    privateKey = privateKey,\n    state: theState,\n    expiration: theExpiration,\n    type: theType,\n    data: theData,\n)\n</code></pre>"},{"location":"wallet/wallet-sdk/android-sdk/install-android-sdk/","title":"Implement Android SDK","text":"<p>This native SDK enables Android developers to use the PolygonID solution in Android project.</p>"},{"location":"wallet/wallet-sdk/android-sdk/install-android-sdk/#how-to-use-the-sdk","title":"How to use the SDK","text":""},{"location":"wallet/wallet-sdk/android-sdk/install-android-sdk/#prerequisite","title":"Prerequisite","text":"<p>Follow the steps from the up to date README GitHub repository prerequisites.</p>"},{"location":"wallet/wallet-sdk/android-sdk/install-android-sdk/#initialization","title":"Initialization","text":"<p>The SDK needs to be initialized before being used: </p><pre><code>            PolygonIdSdk.init(\n                context = context,\n                env = EnvEntity(\n                    blockchain = \"polygon\",\n                    network = \"mumbai\",\n                    web3Url = \"https://polygon-mumbai.infura.io/v3/\",\n                    web3RdpUrl = \"wss://polygon-mumbai.infura.io/v3/\",\n                    web3ApiKey = \"theApiKey\",\n                    idStateContract = \"0x134B1BE34911E39A8397ec6289782989729807a4\",\n                    pushUrl = \"https://push-staging.polygonid.com/api/v1\"\n                )\n            )\n</code></pre> The <code>env</code> param is optional but you need to set it up at some point via <code>PolygonIdSdk.getInstance().setEnv()</code>. <p>Once initialized, you can use the SDK through his singleton <code>PolygonIdSdk.getInstance()</code></p> <p>Under the hood</p> <p>This SDK is calling the Flutter SDK through <code>MethodChannel</code>, that's why each method has a <code>Context</code> param to initialize the get <code>FlutterEngine</code>. You don't need to install or know anything about Flutter.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/","title":"Build App with SDK","text":""},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/#build-an-app-using-flutter-first-few-steps","title":"Build an App using Flutter: First Few Steps","text":"<p>Once your Flutter and Dart plugins are installed, you can start creating your first Flutter app.</p> <ol> <li>On the Terminal or Powershell, change your directory to where you want to install your app:    <pre><code>cd new-app-directory\n</code></pre></li> <li> <p>Create your first app; let's call it \"firstapp\".    </p><pre><code>flutter create firstapp\nflutter run\n</code></pre>    With these commands, the Flutter SDK creates a new project from scratch. </li> <li> <p>Flutter creates your app.</p> </li> <li> <p>Change your directory to your app:</p> </li> </ol> <pre><code>cd firstapp\n</code></pre> <p>Note: In your directory, inside your app, there is a <code>lib</code> folder, which contains a <code>main.dart</code> file. When you click <code>main.dart</code>, it opens in your editor. This file contains the Dart code and for your own app, you will need to replace the content of this .dart file with your own code.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/#pubspecyaml-file","title":"Pubspec.yaml File","text":"<p>In your app folder, click the <code>pubspec.yaml</code> to open it in your editor. The <code>pubspec.yaml</code> file contains the following information about your app:</p> <ul> <li>Name of your app</li> <li>Description</li> <li>Version and build number of your app</li> <li>Environment</li> <li>Dependencies</li> </ul>"},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/#add-dependencies-of-your-app-to-pubspecyaml","title":"Add Dependencies of your app to Pubspec.yaml","text":"<p>Dependencies are any additional packages that your app requires to run smoothly. These dependencies can be automatically updated to the latest version by running the following command:</p> <p></p><pre><code>flutter pub upgrade --major-versions\n</code></pre> To update the dependencies manually, change the dependency version number to the latest one."},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/","title":"Install Flutter SDK","text":""},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#install-flutter-sdk","title":"Install Flutter SDK","text":""},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#steps-to-install-flutter-sdk","title":"Steps to Install Flutter SDK","text":"<p>Flutter SDK installation is available for different operating systems including Windows, macOS, Linux, and ChromeOS.</p> <ol> <li>Click here to select your operating system.</li> <li>Check for the system requirements specific to each operating system and make sure that you have all the necessary tools already installed on your system. For instance, for macOS, <code>git</code> must be pre-installed while for Windows, you need to have <code>git for Windows</code> and <code>Windows Powershell 5.0 or above</code> installed.</li> <li> <p>Download the installation bundle (install the latest version for stable release ) relevant to your Operating System. In the case of macOS, different bundles are available for Intel and Apple Silicon processors.</p> </li> <li> <p>Extract the downloaded installation file to the desired directory on your machine. This creates a flutter folder in the directory. </p> </li> <li> <p>On your Terminal, change the directory to the flutter folder extracted in the previous step.</p> <p></p><pre><code>cd flutter\n</code></pre> 6. To run the flutter commands, the shell you are working in must be set to the directory where your flutter binary file (.exe) is located. For this, you must first set the path: <p></p><pre><code>export PATH=\"$PATH:/[path where Flutter is installed]/flutter/bin\"\n</code></pre> For example, if our extracted installation is on your Desktop, we can run the following command: <pre><code>export PATH=\"$PATH:/Users/username/Desktop/flutter/bin\"\n</code></pre> where <code>export</code> sets the <code>PATH</code> on the left to the value of the <code>PATH</code> specified on the right.  <p>To verify if the Path has been correctly set, we run an <code>echo $PATH</code> command:</p> <p></p><pre><code>echo $PATH\n</code></pre> <code>/opt/homebrew/bin:/opt/homebrew/sbin:/opt/local/bin:/opt/local/sbin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/Library/Apple/usr/bin:/usr/local/bin:/Users/username/Desktop/flutter/bin</code> <p>where <code>Users/username/Desktop/flutter/bin</code> is the intended path where we had set our path to.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#using-dart-with-flutter","title":"Using Dart with Flutter","text":"<p>Flutter apps are created using a programming language called <code>Dart</code>. An object-oriented language with similarity to C language, Dart is used for creating mobile and web applications. With Dart, Flutter apps can be developed quickly and deployed to different platforms.</p> <p>Note: The Dart SDK comes bundled with Flutter, so if you installed Flutter, it is not required to install Dart separately.</p> <p>Note: For more information on Dart, click here.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#install-flutter-plugin-for-text-editors","title":"Install Flutter Plugin for Text Editors","text":"<p>Generally, developers can create a Flutter-based app using a combination of the CLI (Command Line Interface) and a text editor. The easier way is to install a plugin within the editor. The plugins for editors like Visual Studio Code, Android Studio, Emacs, and IntelliJ are available for installation. To install the plugin for both Flutter and Dart on VS Code:</p> <ol> <li>Open VS Code.</li> <li>Click View menu, and then click Command Palette.</li> <li>On the palette, enter Extensions. The system displays a list of options. Select Extensions: Install Extensions.</li> <li>In the Search Extension in Markdown box, enter flutter. The system displays the Flutter plugin. Click install.This installs Flutter along with the Dart plugin.</li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/","title":"Example App","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#polygon-id-sdk-plugin-example-app","title":"Polygon ID SDK Plugin: Example App","text":"<p>To use Polygon ID Mobile SDK, we have created a Polygon ID SDK Plugin. This plugin helps you communicate with our Polygon ID Platform. </p> <p>The following steps illustrate how to do initial setup to get things started and then use this plugin to create an identity, authenticate this identity, fetch a credential from an Issuer using identity, and generate a proof to verify (by Verifier) this credential. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Install Flutter: Install Flutter SDK. To know the steps in detail, read the tutorial here.</p> </li> <li> <p>Clone Repository: Clone the polygonid-sdk-repository.</p> </li> <li> <p>Set Directory: On your Terminal, change the directory to <code>example</code>, which is a folder in the <code>polygonid-sdk-repository</code>.</p> <pre><code>cd example\n</code></pre> </li> <li> <p>Set Dependencies: To use the Polygon ID Flutter SDK plugin, add the following dependencies to your <code>pubspec.yaml</code> file:</p> <p>environment:</p> <pre><code>  sdk: \"&gt;=2.17.0 &lt;3.0.0\"\n</code></pre> <p>dependencies:</p> <pre><code>  flutter:\n        sdk: flutter\n\n  polygonid_flutter-sdk: ^x.y.z\n</code></pre> <p>where \"^x.y.z\" stands for the version constraints (range of versions that are backward compatwith the x.y version.</p> <p>Read more here.</p> </li> <li> <p>Get Dart packages: While in the <code>example</code> directory, run the following command:</p> <p></p><pre><code>flutter pub get\nflutter pub run build_runner build --delete-conflicting-outputs\n</code></pre>   The system runs the command and shows: <p>Running \"flutter pub get\" in example...</p> <p>where <code>pub</code> command (in Dart) invokes a set of tools for managing Dart packages and <code>pub get</code> downloads these packages for your Dart project. The <code>flutter pub get</code> indicates that the command is run via flutter SDK.</p> </li> <li> <p>Build your first project and run it. For more details, click here.</p> </li> </ol> <p>While running a Flutter command, if you encounter a command not found: flutter error, make sure that the path set above is correct. If you still encounter the error, install Vim emulation for Visual Studio Code as an extension and follow these steps:</p> <ol> <li>Run the following command:</li> </ol> <pre><code>vim $HOME/.zshrc\n</code></pre> <p>where we assume that you are working in the Z shell. </p> <p>If you are using the Bash shell, you can run this command:</p> <pre><code>vim $HOME/.bashrc\n</code></pre> <p>To know your shell, type:     </p><pre><code>echo $SHELL\n</code></pre>   which, in our case shows: <code>/bin/zsh</code> <ol> <li>This opens the <code>.zshrc</code> configuration window (for the Z Shell). Press \"I\" to initiate the insert mode.</li> <li>Run the following command to set your path variable:</li> </ol> <p></p><pre><code>export PATH=\"$PATH:/Flutter-Directory-Path/flutter/bin\"\n</code></pre>    where \"Flutter-Directory-Path\" is the directory where your Flutter is installed. <ol> <li>Press <code>Escape</code> on your keyboard and then enter the following command:</li> </ol> <p></p><pre><code>:wq!\n</code></pre>    Press <code>Enter</code>. This saves the file in Vim and exits the editor (<code>wq</code> stands for write and quit). <ol> <li>Run your flutter commands.</li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#general-flow","title":"General Flow","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#overview","title":"Overview","text":"<p>In the upcoming sections, we shall see the general flow of how to use the Polygon ID SDK plugin. The steps are summarised as:</p> <p>A. Identity</p> <ol> <li>Initialise Polygon ID SDK.</li> <li>Create an Identity for the wallet.</li> <li>Get (Retrieve) Identifier from the Identity created in the previous step.</li> <li>Remove Identity (only if required).</li> <li>Get iden3Message from Issuer.</li> <li>Authenticate Identity using Identifier, iden3Message, and Private Key.</li> </ol> <p>B. Credential</p> <ol> <li>Create CredentialRequestEntity from the Iden3Message received from an Issuer.</li> <li>Fetch and Save credentials (received from Issuer) on SDK using CredentialRequestEntity, Identifier, and Private Key.</li> <li>Get credentials that are saved on wallet SDK. One can also retrieve them with credential IDs.</li> <li>Remove credential (only if required).</li> <li>Update credential (only if required).</li> </ol> <p>C. Proof</p> <ol> <li>Generate zero-knowledge proof using iden3Message, Identifier, and Private Key. </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#sdk","title":"** SDK**","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#initiate-polygon-id-sdk","title":"Initiate Polygon ID SDK","text":"<p>To start using Polygon ID SDK, an integrator needs to initialize it first. This is done inside the dependency injection initializer using <code>await PolygonIdSDK.init()</code>. </p> <pre><code>import 'package:flutter/material.dart';\nimport 'package:polygonid_flutter_sdk/sdk/polygon_id_sdk.dart';\n\nFuture&lt;void&gt; main() async {\nawait PolygonIdSdk.init();\nrunApp(const App());\n}\n</code></pre> <p>If the SDK has not been initialized, the system throws an exception: <code>PolygonIsSdkNotInitializedException</code> indicating that the Polygon ID SDK has not been initialized and must be initialized first with <code>await PolygonIdSDK.init()</code>.</p> <p>After the SDK initialization, the Integrator  will need to use the instance of PolygonIdSDK:</p> <pre><code>PolygonIdSdk.I\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#get-current-environment","title":"Get current environment","text":"<p>The current environment can be retrieved using <code>getEnv()</code>, it gives an <code>EnvEntity</code>: </p><pre><code>PolygonIdSdk.I.getEnv();\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#get-iden3message-from-a-string","title":"Get Iden3Message from a String","text":"<p>An Integrator uses <code>iden3Message</code> to communicate with an Issuer/Verifier. This 'iden3message' is created from the QR code scanned by the user on his/her wallet. The <code>getIden3Message()</code> uses a string message (created after scanning the QR code) as the input parameter and generates <code>iden3Message</code>.</p> <pre><code>PolygonIdSdk.I.iden3comm.getIden3Message(message: message);\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#steps-in-detail","title":"Steps in Detail","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#a-identity","title":"A. Identity","text":"<p>This part of the flow consists of initialising Polygon ID SDK, creating an identifier for an identity and retrieving it, and using the identifier to authenticate the Identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#1-create-identity","title":"1. Create Identity","text":"<p>After SDK initialization, the SDK checks the existence of an Identifier that was previously created with the <code>addIdentity()</code> function.  If no previously created Identifier is found, the SDK first needs to create an identity first using <code>identity.addIdentity()</code> function. </p> <pre><code>Future&lt;void&gt; addIdentity() async {\n  // we get the sdk instance previously initialized\n  final sdk = PolygonIdSdk.I;\n  PrivateIdentityEntity identity = await sdk.identity.addIdentity(secret: secretKey);\n}\n</code></pre> <p>You can retrieve your <code>private key</code> from the <code>PrivateIdentityEntity</code> specified in the code above. Keep this private key safe; it will be used in a few other SDK methods as you will see in the following steps.</p> <p>Note: It is not mandatory to pass the <code>secret</code> as the input parameter in the function. If you do not pass it, a random <code>secret</code> is generated by the system. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#3-get-did-identifier","title":"3. Get did Identifier","text":"<p>This retrieves the <code>did identifier</code> by passing the environment detail and <code>private key</code> input parameter to the <code>getDidIdentifier()</code> function; please note that the <code>private key</code> is generated from <code>PrivateIdentityEntity</code> that we generated via <code>addIdentity()</code> function in the previous section. </p> <pre><code>PolygonIdSdk.I.identity.getDidIdentifier(\n        privateKey: privateKey,\n        blockchain: env.blockchain,\n        network: env.network,\n        profileNonce: profileNonce);\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#4-remove-identity","title":"4. Remove Identity","text":"<p>To remove an existing Identity (use this only when required), you need to call the <code>identity.removeIdentity()</code> with <code>did identifier</code> and the <code>privateKey</code> as the input parameters. </p> <pre><code>Future&lt;void&gt; removeIdentity({\n  required String privateKey,\n  required String did,\n}) async {\n  await sdk.identity.removeIdentity(\n    privateKey: privateKey,\n    genesisDid: did,\n  );\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#5-authenticate-identity","title":"5. Authenticate Identity","text":"<p>We use <code>authenticate()</code> to authenticate an identity by using <code>privateKey</code>, <code>did identifier</code>, and <code>iden3Message</code> as the input parameters. </p> <pre><code>Future&lt;void&gt; authenticate({\n  required Iden3MessageEntity iden3message,\n  required String genesisDid,\n  required String privateKey,\n}) async {\n  await sdk.iden3comm.authenticate(\n    iden3message: iden3message,\n    genesisDid: genesisDid,\n    privateKey: privateKey,\n  );\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#b-credential","title":"B. Credential","text":"<p>This part of the flow consists of retrieving credentials from an Issuer and saving them in the wallet. One or more credentials can be retrieved and one or more credentials can be removed from the wallet. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#1-fetch-and-save-credentials","title":"1. Fetch and Save Credentials","text":"<p>This functionality consists of retrieving credentials from an Issuer (by fetching them) and then saving them on the wallet.</p> <p>This involves:</p> <ul> <li>Getting <code>Iden3Message</code> (see above).</li> <li>Fetching and saving credentials.</li> </ul> <pre><code>List&lt;ClaimEntity&gt; claimList =\n    await sdk.iden3comm.fetchAndSaveClaims(\n  message: iden3message as OfferIden3MessageEntity,\n  genesisDid: didIdentifier,\n  privateKey: privateKey,\n);\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#2-get-credentials","title":"2. Get Credentials","text":"<p>Once credentials have been saved on the wallet SDK, these can be retrieved by the Integrator using <code>credential.getClaims()</code> with <code>did identifier</code>, and <code>privateKey</code> used as the mandatory input parameters and <code>filters</code> as an optional one. <code>Filters</code> let an Integrate get credentials based on some pre-determined criteria. </p> <pre><code>List&lt;ClaimEntity&gt; claimList = await sdk.credential.getClaims(\n  filters: filters,\n  genesisDid: did,\n  privateKey: privateKey,\n);\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#3-get-credentials-by-ids","title":"3. Get Credentials by Ids","text":"<p>This functionality lets an Integrator get credentials from an Issuer based on their IDs. The <code>claimId</code>, <code>did identifier</code>, and <code>privateKey</code>are passed as input parameters to the <code>credential. getClaimsByIds()</code> function and a list of credentials in the form of <code>ClaimEntity</code> are retrieved. The ID of each credential is stored on the SDK from where they can be retrieved.</p> <pre><code>Future&lt;void&gt; getClaimsByIds({\n  required List&lt;String&gt; claimIds,\n  required String genesisDid,\n  required String privateKey,\n}) async {\n  List&lt;ClaimEntity&gt; claimList = await sdk.credential.getClaimsByIds(\n    claimIds: claimIds,\n    genesisDid: genesisDid,\n    privateKey: privateKey,\n  );\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#4-remove-a-credential","title":"4. Remove a Credential","text":"<p>A credential can be removed from the wallet using <code>credential.removeClaim()</code> by passing <code>claimId</code> (the ID of the credential to be removed), the <code>did identifier</code> and the <code>privateKey</code> as the input parameters. </p> <pre><code>Future&lt;void&gt; removeClaim({\n  required String claimId,\n  required String genesisDid,\n  required String privateKey,\n}) async {\n  await sdk.credential.removeClaim(\n    claimId: claimId,\n    genesisDid: genesisDid,\n    privateKey: privateKey,\n  );\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#5-remove-multiple-credentials","title":"5. Remove  Multiple Credentials","text":"<p>This is similar to removing a single credential described above. In this case, you need to pass a list of <code>claimids</code> to be removed, the <code>did identifier</code>, and the <code>privateKey</code> as the input parameters to <code>credential.removeClaims()</code>.</p> <pre><code>Future&lt;void&gt; removeClaims({\n  required List&lt;String&gt; claimIds,\n  required String genesisDid,\n  required String privateKey,\n}) async {\n  await sdk.credential.removeClaims(\n    claimIds: claimIds,\n    genesisDid: genesisDid,\n    privateKey: privateKey,\n  );\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#6-update-credential","title":"6. Update Credential","text":"<p>To update a credential, the <code>credential.updateClaim()</code> function is used with the following fields passed as input parameters:</p> <ul> <li><code>claimId</code></li> <li><code>did identifier</code></li> <li><code>privateKey</code></li> <li>other information such as identity <code>state</code>, <code>issuer</code>, credential's <code>expiration</code> date, <code>type</code> of credential, etc. </li> </ul> <pre><code>Future&lt;void&gt; updateClaim({\n  required String claimId,\n  required String genesisDid,\n  required String privateKey,\n  String? issuer,\n  ClaimState? state,\n  String? expiration,\n  String? type,\n  Map&lt;String, dynamic&gt;? data,\n}) async {\n  PolygonIdSdk sdk = PolygonIdSdk.I;\n  await sdk.credential.updateClaim(\n    id: claimId,\n    genesisDid: genesisDid,\n    privateKey: privateKey,\n    issuer: issuer,\n    state: state,\n    expiration: expiration,\n    type: type,\n    data: data,\n  );\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/#polygon-id-sdk-overview","title":"Polygon ID SDK Overview","text":"<p>Like any other SDK, the Polygon ID SDK is a Flutter-based set of tools that consists of core components including libraries, code samples, APIs, and documentation that have been used to create the Polygon ID Wallet App. An Integrator can use this PolygonID SDK to either create their own apps (that provide similar functionality as that of the Polygon ID Wallet App) or integrate the functionalities seamlessly with their existing apps. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/#polygon-id-wallet-sdk-and-polygon-id-wallet-app","title":"Polygon ID Wallet SDK and Polygon ID Wallet App","text":"<p>In the wallet tutorials, you would be reading terms like Polygon ID SDK (also Wallet SDK) and Polygon ID Wallet APP repeatedly. Do not let the terminology confuse you here! The Polygon ID Wallet SDK and the Polygon ID Wallet App are different concepts: the prior is the technology and the later one is one of its possible implementations. </p> <p>While, as you read above, the Polygon ID SDK is the software development kit that acts as a core functionality, the Wallet App is an application that has been built over this SDK. This Identity Wallet helps Integrators create identities for their wallets and authenticate these identities while interacting with Issuers and Verifiers. </p> <p>Here, we can conclude that an Integrator can use the Polygon ID Wallet SDK to build an Identity Wallet of his/her own or can also customize any pre-existing identity wallets using the features provided by the SDK.  </p> <p>In the sections to come, you will read more about the Polygon ID Wallet SDK plugin and also an example app that will guide you to the initial setup required for using this plugin. In the later part of this example app, you will get to know the overall flow of the functionality that this plugin provides. </p> <p>Note</p> <pre><code>Please note that the iOS Simulator for testing the Polygon ID Wallet SDK application is still under maintenance and would be available to use soon.\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/#why-polygon-id-wallet-sdk","title":"Why Polygon ID Wallet SDK?","text":"<p>Integrating your app with the Polygon ID Wallet SDK can provide you with the major features of an SSI system. As it is built leveraging a zero-knowledge identity protocol, it can let you create an identity application that is not only robust but also maintains high standards of privacy for your users, thus letting them protect their sensitive data from the third-party while revealing only the required information. The Polygon ID Wallet SDK lets you:</p> <ul> <li>Create an Identity for a wallet</li> <li>Remove and restore identities from a wallet.</li> <li>Authenticate your wallet with an Issuer/Verifier.</li> <li>Receive credentials from an Issuer and store them in the wallet.</li> <li>Update credentials and remove them from the wallet when required.</li> <li>Generate zero-knowledge proof that can be sent to a Verifier for verification. </li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/#flutter-sdk","title":"Flutter SDK","text":"<p>Flutter SDK is a set of tools that are built in Dart programming language and let the developers create and test apps. It is an open-source, platform-agnostic framework that helps in building mobile apps. The Flutter SDK provides a developer with CLI(Command Line Interface) tools and APIs that help built cross-platform apps. </p> <p>The Flutter plug-in package helps in implementing code for a specific platform: Android/iOS/web. To know more about different types of packages and the plugins provided by Flutter, click here.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-plugin/","title":"Flutter Plugin","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-plugin/#flutter-plugin","title":"Flutter Plugin","text":"<p>We use a Flutter plugin that lets you interact with the Polygon ID platform. It is a tool that lets you use everything that Polygon ID provides (identity wallet, credential wallet, proof generation, etc.).</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-plugin/#install-flutter-plugin","title":"Install Flutter Plugin","text":"<p>To use the Polygon ID Flutter SDK plugin, you need to add this plugin as a dependency in your <code>pubspec.yaml</code> file:</p> <ol> <li>Open the <code>pubspec.yaml</code> file in your editor.</li> <li> <p>Scroll down to the dependency section and add the following dependency:</p> <pre><code>dependencies:\npolygonid_flutter_sdk: ^x.y.z\n</code></pre> <p>where x stands for the major version, y stands for the minor version, and z stands for the patch version of the Polygon ID Flutter SDK.</p> </li> </ol> <p>If you are working on a branch of the Polygon ID Flutter SDK repository, you can add the dependency in the following way:</p> <pre><code>dependencies:\n polygonid_flutter_sdk:\n   git:\n     url: ssh://git@github.com/0xPolygonID/polygonid-flutter-sdk.git\n     ref: branchPathName\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/overview/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/overview/#credential-wallet-overview","title":"Credential Wallet Overview","text":"<p>The Credential Wallet lets a user fetch credentials from the Issuer and save these credentials to his/her wallet. These credentials are later used to prove his/her identification to a Verifier. Once the credentials have been fetched and stored, a user can, later, retrieve them from the database, can update them, or delete them altogether. The credentials have unique IDs that let a user access them seamlessly. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/","title":"Fetch and Save Claims","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/#to-fetch-and-save-credentials-fetchandsaveclaims","title":"To Fetch and Save Credentials: <code>fetchAndSaveClaims</code>","text":"<p>An Integrator can fetch credentials stored on an Issuer and then save them in his/her wallet. The<code>fetchAndSaveClaims()</code> function is called to fetch and save a list of credentials from an Issuer.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/#fetch-and-save-credentials","title":"Fetch and Save Credentials","text":"<pre><code>Future&lt;List&lt;ClaimEntity&gt;&gt; fetchAndSaveClaims(\n      {required OfferIden3MessageEntity message,\n      required String did,\n      required String privateKey});\n</code></pre> <p>The <code>fetchAndSaveClaims()</code> function uses <code>OfferIden3MessageEntity</code>, <code>privateKey</code>, and <code>did</code> as the input parameters. and returns a list of <code>ClaimEntity</code>.</p> <p><code>OfferIden3MessageEntity</code>: OfferIden3MessageEntity is a type of <code>Iden3MessageEntity</code>. As you can see in the iden3 Message API tutorial, we get <code>Iden3MessageEntity</code> when we call <code>getIden3Message()</code>method. </p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique id of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/#wallet-issuer-interaction-for-fetching-credentials","title":"Wallet-Issuer Interaction for Fetching Credentials","text":"<ol> <li> <p>Integrator scans the QR code displayed on the Issuer site to get the Iden3 message.</p> </li> <li> <p>The Integrator uses the <code>OfferIden3MessageEntity</code> obtained from the Iden3 message to authenticate and fetch the credentials from the Issuer.</p> </li> <li> <p>The Issuer validates the identity and returns a list of <code>ClaimEntities</code> back to the Integrator.</p> </li> <li> <p>The credentials are stored on the SDK associated with the identity.</p> </li> </ol> <p></p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/","title":"Get Claims","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#to-get-credentials-getclaims","title":"To Get Credentials: <code>getClaims</code>","text":"<p>After a credential is fetched from an Issuer and stored on the wallet SDK, an Integrator can retrieve this credential from the storage. This is done using <code>getClaims()</code> function.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#get-credentials","title":"Get Credentials","text":"<pre><code>Future&lt;List&lt;ClaimEntity&gt;&gt; getClaims(\n      {List&lt;FilterEntity&gt;? filters,\n      required String did,\n      required String privateKey});\n</code></pre> <p>This function returns a list of <code>ClaimEntity</code> based on some pre-defined criteria or filters. The function uses <code>privateKey</code> and <code>did</code> as input parameters.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique ID of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#get-credentials-by-ids-getclaimsbyids","title":"Get Credentials by Ids: <code>getClaimsByIds</code>","text":"<p>The <code>getClaimsByIds()</code> function retrieves a list of credentials stored on the SDK using a list of credential IDs.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#get-credentials-by-ids","title":"Get Credentials by Ids","text":"<pre><code>Future&lt;List&lt;ClaimEntity&gt;&gt; getClaimsByIds(\n      {required List&lt;String&gt; claimIds,\n      required String did,\n      required String privateKey});\n</code></pre> <p>The method, based on the credential IDs, retrieves a list of <code>ClaimEntity</code> from the storage. </p> <p>Note: An Issuer assigns IDs to the credentials. The wallet, after fetching these credentials, stores them on the SDK. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/","title":"Remove Claims","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/#to-remove-claims-removeclaims-and-removeclaim","title":"To Remove Claims: <code>removeClaims</code> and <code>removeClaim</code>","text":"<p>The credentials stored on the SDK storage can be removed locally by the Integrator. They remain on the Issuer unless it removes them. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/#remove-credentials-removeclaims","title":"Remove Credentials: <code>removeClaims</code>","text":"<p>The <code>removeClaims()</code> method removes credentials from the storage based on a list of <code>claimIds</code>:</p> <pre><code>Future&lt;void&gt; removeClaims({required List&lt;String&gt; claimIds,\n      required String did,\n      required String privateKey});\n</code></pre> <p><code>claimids</code> are the IDs of the credentials. </p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique id of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/#remove-a-single-credential-removeclaim","title":"Remove a single Credential: <code>removeClaim</code>","text":"<p>A single credential can also be removed from the storage based on its credential ID. </p> <p>The <code>removeClaim()</code> method, just like <code>removeClaims()</code> method, removes a single credential based on credential's ID. </p> <pre><code>Future&lt;void&gt; removeClaim(\n      {required String claimId,\n      required String did,\n      required String privateKey});\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/update-claims/","title":"Update Claims","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/update-claims/#to-update-credentials-updateclaim","title":"To Update Credentials: <code>updateClaim</code>","text":"<p>The credentials stored on the SDK can be updated using the credential's ID.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/update-claims/#update-credentials","title":"Update Credentials","text":"<p>The <code>updateClaim()</code> method uses <code>claimId</code>, <code>issuer</code>, <code>did</code>, <code>state</code>, <code>expiration</code>, <code>type</code>, <code>date</code>, and <code>privateKey</code> as input parameters and updates the credential information. </p> <pre><code>Future&lt;ClaimEntity&gt; updateClaim({\n    required String claimId,\n    String? issuer,\n    required String did,\n    ClaimState? state,\n    String? expiration,\n    String? type,\n    Map&lt;String, dynamic&gt;? data,\n    required String privateKey,\n  });\n</code></pre> <p>where:</p> <p><code>claimId</code> is the credential's ID.</p> <p><code>issuer</code> is the <code>did</code> of the issuer.</p> <p><code>did</code> is the unique ID of the identity.</p> <p><code>state</code> is the credential's current state.</p> <p><code>expiration</code> is the date and time of the expiration of the credential in string format.</p> <p><code>type</code> is type of verifiable credential, for example: KYCAgeCredential.</p> <p><code>data</code> is the information related to a verifiable credential.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity.  </p> <p>This function returns the updated <code>ClaimEntity</code>.</p> <p>Note: Only the <code>ClaimEntity.info</code> is updated and <code>data</code> is subject to validation by the data layer. <code>ClaimEntity.info</code> is the information related to a verifiable credential that an Integrator receives from an Issuer. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/","title":"Auth Requests","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#type-of-authorization-requests","title":"Type of Authorization Requests","text":"<p>The proof generation by the wallet SDK is based on two types of authorization requests sent by the Verifier (or also by the Issuer in the case of Basic Auth):</p> <ul> <li>Based on <code>Basic Auth</code> Requests</li> <li>Based on <code>Query-based</code> Requests</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#basic-auth-request","title":"Basic Auth Request","text":"<p>The Issuer/Verifier sends the <code>Basic Auth</code> request to the wallet when wallet needs to prove its identity (based on the Identifier generated earlier) to the Issuer/Verifier. This request is sent when an Identity needs to prove that it is, indeed, what it asserts to be. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#structure-of-basic-auth-request","title":"Structure of Basic Auth Request","text":"<p>The structure of a <code>Basic Auth</code> request can be seen below:</p> <p></p><pre><code>{\n \"id\": \"6c004daa-b664-4c1a-8393-66ef6755a07b\",\n \"thid\": \"6c004daa-b664-4c1a-8393-66ef6755a07b\",\n \"from\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\",\n \"typ\": \"application/iden3comm-plain-json\",\n \"type\": \"https://iden3-communication.io/authorization/1.0/request\",\n \"body\": {\n   \"reason\": \"test flow\",\n   \"message\": \"\",\n   \"callbackUrl\": \"https://verifier.polygonid.me/api/callback?sessionId=95209\",\n   \"scope\":\n }\n}\n</code></pre> Note: The details of each of the fields of the request can be seen in the section below on Query Request."},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#query-based-request","title":"Query-based Request","text":"<p>A Query-Based Request is used for generating two types of proofs: Signature-based Proof and Merkle Tree Proof (MTP). For such proofs, we have a credential that satisfies pre-determined criteria (as can be seen from the structure of the Query-based Request below) and these credentials are used for generating the proofs and shared with the Verifier using <code>callbackUrl</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#structure-of-query-based-request","title":"Structure of Query-based Request","text":"<pre><code>{\n \"id\": \"b5d9edf2-adcf-4600-b273-1f6f32da87ee\",\n \"thid\": \"b5d9edf2-adcf-4600-b273-1f6f32da87ee\",\n \"from\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\",\n \"typ\": \"application/iden3comm-plain-json\",\n \"type\": \"https://iden3-communication.io/authorization/1.0/request\",\n \"body\": {\n   \"reason\": \"test flow\",\n   \"message\": \"\",\n   \"callbackUrl\": \"https://verifier.polygonid.me/api/callback?sessionId=932469\",\n   \"scope\": {\n     \"0\": {\n       \"id\": \"1\",\n       \"circuit_id\": \"credentialAtomicQuerySig\",\n       \"rules\": {\n         \"query\": {\n           \"allowedIssuers\":\n               \"0\": \"*\",\n           \"schema\": {\n               \"type\": \"KYCAgeCredential\",\n               \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\"\n           },\n           \"req\": {\n               \"birthday\": {\n                   \"$lt\": \"20000101\"\n             }\n           }\n         }\n       }\n     }\n   }\n }\n}\n</code></pre> where: <ul> <li>id: Identifier stored on the wallet SDK</li> <li>thid: ID of the message thread</li> <li>from: from where the authentication request comes, i.e. the identifier of the identity from which a Verifier requests proof</li> <li>typ: iden3comm Media Type, i.e. file format for the type field. (For example, JSON)</li> <li>type: Type of iden3comm Protocol Message; type of request; it could be an auth request, proof request, or a credential offer</li> <li>reason: reason of authentication (it could be age verification or simply a test flow)</li> <li>message: Message to be signed; can be left blank</li> <li>callbackUrl: URL to which requested information is sent and response is received</li> <li>scope: information related to the proof request and the requirements to be fulfilled by the proof generated and shared from mobile. It is in the form of an array of proofs that the SDK generates.</li> <li>0:</li> <li>id: Scope id</li> <li>circuit_id: Type of proof; in the above example, it is credentialAtomicQuerySig.</li> <li>rules:</li> <li>query:</li> <li>allowedissuers: types of Issuers allowed</li> <li>0: \"*\" : all types of Issuers are allowed</li> <li>schema: a structure that is used for proof generation for a credential</li> <li>type: type of credentials allowed</li> <li>url: URL for getting the vocabulary for the credential</li> <li>req: a query request to a query circuit; for example, the user's birthday should fall before January 1, 2000</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#difference-between-basic-auth-and-query-based-requests","title":"Difference Between <code>Basic Auth</code> and <code>Query-based</code> Requests","text":"<p>The difference between the proofs based on <code>Basic Auth</code> and <code>Query-based</code> requests is that the <code>Basic Auth</code> is used by an identity for authenticating itself (as was mentioned above) and the <code>Query-based</code> is used for authenticating the credentials that the Identity receives from an Issuer.</p> <p>The fundamental structure of the request types is the same except that the <code>Query-based request</code> carries more parameters: in the form of more information linked to the proof generated by the wallet SDK; it includes information such as type of credentials allowed, URL for getting vocabulary for those credentials and requirements that a credential must satisfy (ex, the birth date should be more than 18).</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#auth-circuit-and-atomicquerysig-circuit","title":"Auth Circuit and AtomicQuerySig Circuit","text":"<p>A circuit is zero-knowledge based program that generates a zk proof based on a set of inputs provided. An <code>Auth Circuit</code> creates a proof for the <code>Basic Auth</code> requests and <code>AtomicQuerySig Circuit</code> generates proof for signature-based requests <code>AtomicQueryMTP</code> is used for the MTP-based requests.</p> <p>For more information on circuits, go through the following links:</p> <p>auth circom</p> <p>credentialAtomicQuerySigV2</p> <p>credentialAtomicQueryMTPV2</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#how-is-proof-sent-to-the-verifier","title":"How is Proof sent to the Verifier?","text":"<p>The wallet sends the proof generated to a Verifier using a <code>callbackUrl</code>; this URL is included in the auth request and includes the information that the Verifier requests from the Wallet. So, the Wallet sends the proof request along with the credential via this <code>callbackUrl</code> and receives the proof response from the Verifier on the same URL.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/","title":"JWZ","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#jwz-json-web-zero-knowledge","title":"JWZ - JSON Web Zero Knowledge","text":"<p>JSON Web Zero-knowledge (JWZ) is an open standard for representing messages proven with zero-knowledge technology.</p> <p>Based on the existing secure messaging standards, namely, JWM (JSON Web Message) and JWT (JSON Web Token), JWZ is a standard format for representing and sending secure messages backed by zero-knowledge technology. It is a novel way of providing interaction between two parties that intend to exchange messages while keeping the sender's public keys hidden. The proof that the wallet generates is packed in the JWZ format and sent to the Verifier using <code>callbackUrl</code>.</p> <p>In the Iden3 Protocol, JWZ is the core primitive to manage communications between different parties. A JWZ expands the signature schema of the popular JWT standard.</p> <p>Any message can be packed inside a JWZ while the proof guarantees data integrity and provenance of the message, providing helpful metadata among the message.</p> <p>JWZ</p> <p>This is an example of a JWZ generated by an identity wallet as a response to the auth request generated as a response to a zk request posed by a Verifier, similar to the one performed inside the Verifier Setup Tutorial.</p> <p>JWZ consists of three parts separated by a dot (.):</p> <ul> <li>Header</li> <li>Payload message</li> <li>Proof</li> </ul> <p><code>eyJhbGciOiJncm90aDE2IiwiY2lyY3VpdElkIjoiYXV0aFYyIiwiY3JpdCI6WyJjaXJjdWl0SWQiXSwidHlwIjoiYXBwbGljYXRpb24vaWRlbjMtemtwLWpzb24ifQ.eyJpZCI6IjVlOWZmMGJiLTk1NzctNDNiNS1iZWZlLWQxMWNlMDRkYzZlMiIsInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwidHlwZSI6Imh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXNwb25zZSIsInRoaWQiOiI3ZjM4YTE5My0wOTE4LTRhNDgtOWZhYy0zNmFkZmRiOGI1NDIiLCJmcm9tIjoiZGlkOnBvbHlnb25pZDpwb2x5Z29uOm11bWJhaToycU1ZN3h5bWFYV2RGRHQ3NHhSMXo4bVlyelNZQkMxVmVTV3c2WmhjU1AiLCJ0byI6ImRpZDpwb2x5Z29uaWQ6cG9seWdvbjptdW1iYWk6MnFEeXkxa0VvMkFZY1AzUlQ0WEdlYTdCdHhzWTI4NXN6ZzZ5UDlTUHJzIiwiYm9keSI6eyJkaWRfZG9jIjp7IkBjb250ZXh0IjpbImh0dHBzOi8vd3d3LnczLm9yZy9ucy9kaWQvdjEiXSwiaWQiOiJkaWQ6cG9seWdvbmlkOnBvbHlnb246bXVtYmFpOjJxTVk3eHltYVhXZEZEdDc0eFIxejhtWXJ6U1lCQzFWZVNXdzZaaGNTUCIsInNlcnZpY2UiOlt7ImlkIjoiZGlkOnBvbHlnb25pZDpwb2x5Z29uOm11bWJhaToycU1ZN3h5bWFYV2RGRHQ3NHhSMXo4bVlyelNZQkMxVmVTV3c2WmhjU1AjcHVzaCIsInR5cGUiOiJwdXNoLW5vdGlmaWNhdGlvbiIsInNlcnZpY2VFbmRwb2ludCI6Imh0dHBzOi8vcHVzaC1zdGFnaW5nLnBvbHlnb25pZC5jb20vYXBpL3YxIiwibWV0YWRhdGEiOnsiZGV2aWNlcyI6W3siY2lwaGVydGV4dCI6IllleWRnWnBWRXVFRFM5VnV6OEhGL0lVWDJFUS9admxWZjZHYWVJZWJVQ005SGc1bk5maHZhZEpjL0JMd25GejJEK1l0L29vMkdEYnpjZittcEpOcCt4di9Zb2dxbjl0Q3lJVU9icTdJYVpJdUVTZXhoL1VhdCtTZnZHODdJSks1M0hKR1JJTHU4VzF3SHdVeVFZeGR5YUtCaWtmTnRZajdZdFdNS0dXUTVSNnlwWnFBUG8rZjQzNUtjZ3B4R1EybVRMNHRNMmpWRWxaZjlVTVhEeDl1b0QrdU9sbzJQb2hIamNnUDNLZDVqYVNsZmV2T0ZMc0JGVmFseWVzbWNjMldqYzU4KzVDTUxabm5tSkU0Vkl3Q1Nwd1NOb2ZNM1FvREEyOHA0eVR1ay9VaHhUbUNzSVNMN3hyNkRCa3MzN3NyUmpUNkF0QU90QkZKTXljZk5JUFAvd1ROSUVmanp3VXN3Vlg2Zmpzd2tYbmtScWQ5QWVlK1U0Y25jSFMvdWw4U21DLzhpNGx2b083KzhHTjE1TlJaTk1oV2tNL0RNSVMrRVNWYnhCTVdJSWJUWktFbVErWXRERGJhMEI4R09OSU92Zi93eDhoU1IxL1NwTCtFMDhXTDU4UmlKWTNuUFhvS0dZK1RtQlplM2UwdklVS2pzcUpVRmhhUG91MUlxa2E2QU9PTXVuNWxaMUQvNVBnb2YvOTFOWTdIYzd5TXA4Wjd4a1VJZEhEa216U3VrSk5XTjNvV2VYVURsZDdFUkV4Ym4zZ2xYSEVLRjFkZzVJRm4rejIvV0xJbnFlSGpZa2xrOE8rdnh6YlZpSUVWWkM0TXErUG1EMDU4Nk9qdklQTlZhWkpaMllUZmlJRmZJUUh5Y2hoaEhOVDFTdko3TnRXaG1RMHZFc2tJY3JBPSIsImFsZyI6IlJTQS1PQUVQLTUxMiJ9XX19XX0sIm1lc3NhZ2UiOm51bGwsInNjb3BlIjpbeyJpZCI6MSwiY2lyY3VpdElkIjoiY3JlZGVudGlhbEF0b21pY1F1ZXJ5U2lnVjIiLCJwcm9vZiI6eyJwaV9hIjpbIjE1ODg0MTQzNjg5MTg2NTYwNzcwNjEzMjc3NTg1Mzk0NzkwMzM5ODMzMjE2NTUxMzM0NDU1MjU5MDU3MTA0NjI1MzMwMDcyNTM0NTEzIiwiMzI3OTA4NzYxMjAyMjcxMjAwMjM0NjI0NjQ0OTExOTM4MjkxMTYyNjAyMDEwNjA0MzQxNDc5ODUzODc5Njk4MzIwNDYyNTU2MTYyNyIsIjEiXSwicGlfYiI6W1siMTc0ODM4Mjc4OTMzNjMwMDgzNTk2NzcxOTc3NTY1ODg3MjU4NzQ4NDc3Nzg3Mzk4OTkzNzAzNDc0MTg4MzIxMDA0ODg4OTQ4NjI1OTIiLCIxODU4MTk5MDQwNDk2MTY2MjM3NTQ2ODg5NTE1NTA2MzM1MjI1Mjk3NzQwNDc0NDExNjU5MDIzNDcxNDMyNjkxNjc4NTg1ODgzNTk2NiJdLFsiMTUwNTY0NjYxMzIxNjMxNzkwNTYzNTY3NDg1NDgxMDM1ODEyMzgwNjU4Nzg3NjM2OTQ5MTE4NjE0NjM4MTI2NzE3NTUyNzM5ODQxNDkiLCI3NDQ4NDU1Mjg5ODEwMTI4MTY1NTUzOTU2Mjc1MDc3NzI2MDQyNDc4OTc0NzY0NzMwMjMxNTY0Mzg5Njc0MTU5NDAwNDgwMTI5ODYiXSxbIjEiLCIwIl1dLCJwaV9jIjpbIjI4NDA0NjIyNTU5OTA5MjM1NjE5MzU1NzU2NjUyNDY5ODY3MDM0MjQyMTc1MzA0NDIzOTUxMzY4NzY4Njg4MTYyOTk5NzkyOTI1NzQiLCI3OTM0MDU2NjA1MTcyNjU4MTQ5MjEyNzAyMzE2NDIxNTg5OTk0ODgyMDIwMjUxMzM1OTkxNDU1OTE3NzI0ODkwMzI1Mjk3MjM4MjM4IiwiMSJdLCJwcm90b2NvbCI6Imdyb3RoMTYiLCJjdXJ2ZSI6ImJuMTI4In0sInB1Yl9zaWduYWxzIjpbIjEiLCIyMTk5NjMxNzg0MzA2ODkxOTQyNTkwMDI4NDIwODg5Mjg3MTIzMzkwMDY5NjI3OTk4MDY5NTYwMjYxMjY4NjQ4OTAxMjA4MTE1NCIsIjIxMjA1MDIxNTQyNzU2Nzc3MDE2ODYwNDY5MTkxMzg1OTAwMTY0MTM1MzQwNDA4NzU2NDY1MDY4MTU4MDY5NTQ3NjQxMDcxMTc3NDk0IiwiMSIsIjI0ODI2ODQ1NTI3MTgyMTY4NDY2NzgyNjcwODI4NDI4Mzc1MTUxNjU2NjQzNzU5MTc0MjE5Njg2Njg2ODE5MDYxMzk5MTYzMzk0IiwiMSIsIjc1NDU4NTYwNzQ3MDMxNDU4OTQ4NjUyMTM5NzcwNTIzMjA4ODMyNTI0MjYzOTc2NTYxMjIwNTkxMzQ3NDI1NTk4NzU5OTU5MjUwMzEiLCIxNjc1MzMwOTk0IiwiNzQ5NzczMjc2MDA4NDgyMzEzODU2NjMyODAxODE0NzYzMDc2NTciLCIwIiwiMjAzNzYwMzM4MzIzNzExMDkxNzc2ODMwNDg0NTYwMTQ1MjU5MDUxMTkxNzM2NzQ5ODU4NDM5MTU0NDU2MzQ3MjYxNjc0NTA5ODk2MzAiLCIwIiwiMiIsIjIwMDAwMTAxIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIl19XX19.eyJwcm9vZiI6eyJwaV9hIjpbIjEwMjk0NzY4MzQ5NzcxOTAwMjgwNjcyMTQzMjkwMDM2MDk0Mjg5OTgyODM2OTU1MDMwMDQwMzE3MjA5NTcxMDQ2NDY5MTgzNDM2NjUwIiwiODQ2NjE1MjIxMzA3NDA2MTMxNDU5NjE5MTcxODAzNjIzMzgyNjEwMjAyMDg0NzM4NTMxMDY3NDg2ODgxODY1OTIyNjIwNDQxNDU2NyIsIjEiXSwicGlfYiI6W1siMTEyMTg5ODIxMDk0Njc1NTU0MDExMDI5ODM5MTc5OTk3OTYyOTc1MjI1MjI2NDI4ODE0Njg3MTkyNTYwMTk0Mzc4NDU4OTQ2OTU4OTAiLCIyMDM0MDI5NzIxOTA1MDgyNDQyNjk1OTQ5OTQ4NDc5MTA5NzAyNDkyMTIxNjI4MzE0ODU4ODEwNTE3NjEyMDU4MzgxNTM2NDg0NTMxMSJdLFsiNDM5NDQ5OTc4MTY2OTE4ODI4Mjc2MzM3NTc2ODE2MTM2NzQwODQ0Mzk4NjY5NTM4ODU3MTcwNDgxNDYxNjI4Njg5ODgwNTM2ODYzOCIsIjExOTEwNjE0NTczMDM3MDUzMzkxODc3OTMzMTU0MjQ0MzM3ODcxOTE1Nzc5MDAzMDkwMzA0OTYxNzM0NjAzNzUxNzEzNTI5NzY4NCJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMjA3Mjk5MjA5MTI3ODE3NDA2MDM5NTQ4OTExNTY2NDkwMDY1MjQzMzE5NzEwNjg4NjQxNzQwMTYyNjYwMDQ5MDUwMTYwNjExNjUzMDMiLCIxMjI0NjMxMzI0NDQxMjIyMzE3NDMwNTQzNjQzOTI2MDk0MjgzMTI5MzA3MTA4MTkzNTYyOTUzMjIzODI3MTgzNDE0MDk3NTE4MTkwNiIsIjEiXSwicHJvdG9jb2wiOiJncm90aDE2IiwiY3VydmUiOiJibjEyOCJ9LCJwdWJfc2lnbmFscyI6WyIyMTk5NjMxNzg0MzA2ODkxOTQyNTkwMDI4NDIwODg5Mjg3MTIzMzkwMDY5NjI3OTk4MDY5NTYwMjYxMjY4NjQ4OTAxMjA4MTE1NCIsIjg2MTgzNjg2NzI2ODA1NTk5NTYxMTc4Mjg4NzI3MzY4OTI4NDY1OTQ2NjIyNDQ4Njc4NjcwMDIyNTkwNjMxNjM5MTk4MzE5MzU1OTIiLCI1MTUzMzUwNDEyMTg5NjMwNzkwNDk5NzAxMTA3MTc1NDc1MjgxNDY1MjQ2NDY3MTc3MzY5NjYyMTE3OTAzNTY1NjUzMDc2NjY4MDIzIl19</code></p> <p>Each part of the token can be parsed into a human-readable string by base 64 decoding.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#header","title":"Header","text":"<p>Defines the feature of the token.</p> <pre><code>{\n    \"alg\": \"groth16\",\n    \"circuitId\": \"authV2\",\n    \"crit\": [\n        \"circuitId\"\n    ],\n    \"typ\": \"application/iden3-zkp-json\"\n}\n</code></pre> <p>alg - is a zero-knowledge algorithm that is used for proof generation.</p> <p>circuitId - is a circuit that is used for proof generation. For authentication - auth circuit must be used.</p> <p>crit - describes the list of header keys that the verifier must support. </p> <p>typ - is the media type of the message. In our case, it is the type of the protocol of the packed message application/iden3-zkp-json.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#payload-message","title":"Payload Message","text":"<p>Contains the message that needs to be shared with another party.</p> <p>In this example, the message is the proof related to the query analysed previously. However, any type of message can be included in the payload. </p> <pre><code>{\n    \"id\": \"5e9ff0bb-9577-43b5-befe-d11ce04dc6e2\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/authorization/1.0/response\",\n    \"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n    \"from\": \"did:polygonid:polygon:mumbai:2qMY7xymaXWdFDt74xR1z8mYrzSYBC1VeSWw6ZhcSP\",\n    \"to\": \"did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs\",\n    \"body\": {\n        \"did_doc\": {\n            \"@context\": [\n                \"https://www.w3.org/ns/did/v1\"\n            ],\n            \"id\": \"did:polygonid:polygon:mumbai:2qMY7xymaXWdFDt74xR1z8mYrzSYBC1VeSWw6ZhcSP\",\n            \"service\": [\n                {\n                    \"id\": \"did:polygonid:polygon:mumbai:2qMY7xymaXWdFDt74xR1z8mYrzSYBC1VeSWw6ZhcSP#push\",\n                    \"type\": \"push-notification\",\n                    \"serviceEndpoint\": \"https://push-staging.polygonid.com/api/v1\",\n                    \"metadata\": {\n                        \"devices\": [\n                            {\n                                \"ciphertext\": \"YeydgZpVEuEDS9Vuz8HF/IUX2EQ/ZvlVf6GaeIebUCM9Hg5nNfhvadJc/BLwnFz2D+Yt/oo2GDbzcf+mpJNp+xv/Yogqn9tCyIUObq7IaZIuESexh/Uat+SfvG87IJK53HJGRILu8W1wHwUyQYxdyaKBikfNtYj7YtWMKGWQ5R6ypZqAPo+f435KcgpxGQ2mTL4tM2jVElZf9UMXDx9uoD+uOlo2PohHjcgP3Kd5jaSlfevOFLsBFValyesmcc2Wjc58+5CMLZnnmJE4VIwCSpwSNofM3QoDA28p4yTuk/UhxTmCsISL7xr6DBks37srRjT6AtAOtBFJMycfNIPP/wTNIEfjzwUswVX6fjswkXnkRqd9Aee+U4cncHS/ul8SmC/8i4lvoO7+8GN15NRZNMhWkM/DMIS+ESVbxBMWIIbTZKEmQ+YtDDba0B8GONIOvf/wx8hSR1/SpL+E08WL58RiJY3nPXoKGY+TmBZe3e0vIUKjsqJUFhaPou1Iqka6AOOMun5lZ1D/5Pgof/91NY7Hc7yMp8Z7xkUIdHDkmzSukJNWN3oWeXUDld7ERExbn3glXHEKF1dg5IFn+z2/WLInqeHjYklk8O+vxzbViIEVZC4Mq+PmD0586OjvIPNVaZJZ2YTfiIFfIQHychhhHNT1SvJ7NtWhmQ0vEskIcrA=\",\n                                \"alg\": \"RSA-OAEP-512\"\n                            }\n                        ]\n                    }\n                }\n            ]\n        },\n        \"message\": null,\n        \"scope\": [\n            {\n                \"id\": 1,\n                \"circuitId\": \"credentialAtomicQuerySigV2\",\n                \"proof\": {\n                    \"pi_a\": [\n                        \"15884143689186560770613277585394790339833216551334455259057104625330072534513\",\n                        \"3279087612022712002346246449119382911626020106043414798538796983204625561627\",\n                        \"1\"\n                    ],\n                    \"pi_b\": [\n                        [\n                            \"17483827893363008359677197756588725874847778739899370347418832100488894862592\",\n                            \"18581990404961662375468895155063352252977404744116590234714326916785858835966\"\n                        ],\n                        [\n                            \"15056466132163179056356748548103581238065878763694911861463812671755273984149\",\n                            \"744845528981012816555395627507772604247897476473023156438967415940048012986\"\n                        ],\n                        [\n                            \"1\",\n                            \"0\"\n                        ]\n                    ],\n                    \"pi_c\": [\n                        \"2840462255990923561935575665246986703424217530442395136876868816299979292574\",\n                        \"7934056605172658149212702316421589994882020251335991455917724890325297238238\",\n                        \"1\"\n                    ],\n                    \"protocol\": \"groth16\",\n                    \"curve\": \"bn128\"\n                },\n                \"pub_signals\": [\n                    \"1\",\n                    \"21996317843068919425900284208892871233900696279980695602612686489012081154\",\n                    \"21205021542756777016860469191385900164135340408756465068158069547641071177494\",\n                    \"1\",\n                    \"24826845527182168466782670828428375151656643759174219686686819061399163394\",\n                    \"1\",\n                    \"7545856074703145894865213977052320883252426397656122059134742559875995925031\",\n                    \"1675330994\",\n                    \"74977327600848231385663280181476307657\",\n                    \"0\",\n                    \"20376033832371109177683048456014525905119173674985843915445634726167450989630\",\n                    \"0\",\n                    \"2\",\n                    \"20000101\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\",\n                    \"0\"\n                ]\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#signature","title":"Signature","text":"<p>It represents a ZK authentication proof based on the <code>auth circuit</code>.</p> <pre><code>{\n    \"proof\": {\n        \"pi_a\": [\n            \"10294768349771900280672143290036094289982836955030040317209571046469183436650\",\n            \"8466152213074061314596191718036233826102020847385310674868818659226204414567\",\n            \"1\"\n        ],\n        \"pi_b\": [\n            [\n                \"11218982109467555401102983917999796297522522642881468719256019437845894695890\",\n                \"20340297219050824426959499484791097024921216283148588105176120583815364845311\"\n            ],\n            [\n                \"4394499781669188282763375768161367408443986695388571704814616286898805368638\",\n                \"119106145730370533918779331542443378719157790030903049617346037517135297684\"\n            ],\n            [\n                \"1\",\n                \"0\"\n            ]\n        ],\n        \"pi_c\": [\n            \"20729920912781740603954891156649006524331971068864174016266004905016061165303\",\n            \"12246313244412223174305436439260942831293071081935629532238271834140975181906\",\n            \"1\"\n        ],\n        \"protocol\": \"groth16\",\n        \"curve\": \"bn128\"\n    },\n    \"pub_signals\": [\n        \"21996317843068919425900284208892871233900696279980695602612686489012081154\",\n        \"8618368672680559956117828872736892846594662244867867002259063163919831935592\",\n        \"5153350412189630790499701107175475281465246467177369662117903565653076668023\"\n    ]\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#difference-between-jwt-and-jwz","title":"Difference between JWT and JWZ","text":"<p>JWT relies on digital signatures for the secure transmission of information. In particular, \"JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA\". (JWT.io). In JWZ, this signature is performed with zero-knowledge. In particular:</p> <ul> <li>The <code>header</code> and the <code>payload</code> get hashed together using the Poseidon hash.</li> <li>The JWZ initiator signs the hashed content using his/her private key.</li> <li>The JWZ creator generates a proof using the authorization circuit to demonstrate that his/her identity signed the content.</li> <li>The proof gets included in the zero- knowledge proof of the JWZ together with the public inputs used inside the circuit to generate the proof.</li> <li>Any third party that accesses the JWZ can verify the proof to check if the information contained in the payload actually originated from that identity and hasn't been tampered with.</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#usage","title":"Usage","text":"<p>JWZ represents the main instrument to communicate securely between parties off-chain. This data primitive integrates seamlessly within web2 architectures for authentication purposes. </p> <p>Here, we used the JWZ to manage the communication between the user and the Verifier. A JWZ can also be used in the communication between the user and the Issuer so that the user can prove his/her identity in order to fetch the claims associated with his/her identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#libraries","title":"Libraries","text":"<ul> <li>js-jwz for JavaScript implementation</li> <li>go-jwz for Go implementation</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/overview/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/overview/#iden3comm-overview","title":"Iden3comm Overview","text":"<p>Iden3comm is the protocol that defines the set of rules and syntax of the data that needs to be communicated while interacting with an Issuer and a Verifier. The protocol lays down the foundation for the semantics and the synchronization that is involved during the communication between two parties.   </p> <p>The Iden3comm protocol defines the structure of the messages, requests, and responses that are quintessential for the exchange of information between the Identity Holder, the Issuer, and the Verifier. It handles the following types of messages, requests, and responses between the entities involved in the communication process:</p> <ul> <li>Authorization Request Messages and Response Body</li> <li>Authorization Response Messages and Response Body</li> <li>Zero-knowledge  Proof Requests and Responses</li> <li>Credential Request Messages for Credential Issuance and Credential Fetching</li> <li>Credential Response Messages for Credential Issuance</li> <li>Iden3 Messages for Message Fetch Requests</li> <li>Revocation Status Request Messages</li> <li>Device Registration Requests</li> </ul> <p></p> <p>For more details on the structure of each type of message, click Iden3comm Protocol.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/","title":"Authenticate","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#to-authenticate-identity-with-issuer","title":"To Authenticate Identity with Issuer","text":"<p>An Integrator, in order to use the services of an Issuer, needs to authenticate itself with that Issuer. For this to happen, the Integrator needs to call the <code>authenticate()</code> method. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#authenticate-identity","title":"Authenticate Identity","text":"<p>The <code>authenticate()</code> method uses  <code>Iden3MessageEntity</code>, <code>did</code>, <code>profileNonce</code>, <code>privateKey</code>, and an optional <code>pushToken</code> as input parameters.</p> <p></p><pre><code>Future&lt;void&gt; authenticate(\n      {required Iden3MessageEntity message,\n      required String did,\n      int? profileNonce,\n      required String privateKey,\n      String? pushToken});\n</code></pre> <code>Iden3MessageEntity</code> is the Iden3 message retrieved from the <code>getIden3Message()</code> method <code>did</code> is the unique ID of the identity. <code>profileNonce</code> is the nonce of the profile of an identity.  <code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity.  <p><code>pushToken</code> lets an Integrator receive the Iden3 messages through push notification.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#steps","title":"Steps","text":"<ol> <li> <p>Retrieve <code>CircuitDataEntity</code> from the loadCircuitFiles. <code>CircuitDataEntity</code> are the circuits used for generating an authentication proof that we share with the Issuer with JWZ.</p> </li> <li> <p>Retrieve iden3message by scanning the QR code and transform it into a string message with <code>getiden3message()</code> method. </p> </li> <li> <p>Get authToken from authenticate() and authenticate Identity with authToken.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#wallet-issuer-interaction-using-authentication","title":"Wallet-Issuer Interaction using Authentication","text":"<p>An Integrator, to interact with an Issuer, needs to authenticate with it first. </p> <ol> <li> <p>On the Polygon ID app (which is based on SDK), an Integrator clicks Connect.</p> <p></p> </li> <li> <p>The Issuer displays a QR code. The Integrator, using the app, scans this code.</p> <p></p> </li> <li> <p>With this, the <code>Authenticate()</code> function (with the identifier, private key and message as the inputs) is executed. The function authenticates the Identity and sends the authentication information (in the form of a big encoded message based on JWZ) to the Issuer.</p> <p></p> <p>Note: Read more on JWZ here.</p> </li> <li> <p>The Issuer receives the data sent by the Integrator and based on its correctness, authenticates or rejects the identity. The wallet analyzes this response from the Issuer.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-proofs/","title":"Get Proof","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-proofs/#to-get-proofs-getproofs","title":"To Get Proofs: <code>getProofs</code>","text":"<p>This function uses identity to generate the zero-knowledge proofs requested by the <code>Iden3Message Entity</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-proofs/#get-proof","title":"Get Proof","text":"<p>The <code>getProofs()</code> method uses <code>Iden3MessageEntity</code>, <code>did</code>, <code>profileNonce</code>, and <code>privateKey</code> as the input parameters and returns a <code>JWZProofEntity</code>.</p> <pre><code>Future&lt;List&lt;JWZProofEntity&gt;&gt; getProofs(\n      {required Iden3MessageEntity message,\n      required String did,\n      int? profileNonce,\n      required String privateKey}); \n</code></pre> <p><code>Iden3MessageEntity</code>: returned from <code>getIden3Message</code> method after a user scans the QR code on Issuer/Verifier website. </p> <p><code>profileNonce</code> is the nonce of the profile of an identity.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique ID of the identity. </p> <p><code>JWZProofEntity</code>is the JWZ message that the Integrator sends to the Issuer/Verifier after scanning the QR code. Read more about JWZ here.</p> <p>Note: The iden3comm's <code>getProofs</code> method retrieves the proofs from the proof request of the Verifier. The actual proof is created by the <code>prove()</code> method, which you will read about in the Proof section of the APIs.  For this to happen, iden3comm makes a call to <code>prove</code>().</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-vocabs/","title":"Get Vocabulary","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-vocabs/#to-get-vocabs-getvocabsfromiden3message","title":"To Get Vocabs: <code>getVocabsFromIden3Message</code>","text":"<p>It gets the vocabulary JSON-LD files to translate the values of the schemas to be used by Integrators in a human-readable form in their apps.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-vocabs/#get-vocabulary","title":"Get Vocabulary","text":"<p>The <code>getVocabsFromIden3Message()</code> method uses <code>Iden3MessageEntity</code> as the input parameter and returns a list of maps of vocabulary JSON-LD files. </p> <pre><code>Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getVocabsFromIden3Message(\n      {required Iden3MessageEntity message}) \n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/iden3-message/","title":"Get Iden3 Message","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/iden3-message/#to-get-iden3-message-getiden3message","title":"To Get Iden3 Message: <code>getIden3Message</code>","text":"<p>All communication between SDK and Issuer/Verifier is done through an <code>Iden3MessageEntity</code>. For example, an Integrator can retrieve this Iden3 message from a message string obtained from an Issuer or a Verifier after scanning a QR code. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/iden3-message/#get-iden3-message","title":"Get Iden3 Message","text":"<p>The <code>getIden3Message()</code> method uses a message String as the input parameter and returns an <code>Iden3MessageEntity</code>.</p> <pre><code>Future&lt;Iden3MessageEntity&gt; getIden3Message({required String message});\n</code></pre> <p>The <code>Iden3MessageEntity</code> is returned with different parsed parameters depending on the type of message.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/overview/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/overview/#identity-wallet-overview","title":"Identity Wallet Overview","text":"<p>An Identity Wallet creates and stores identities for a user. A user can have more than one identity and can have several credentials linked to each identity. An Identity is represented with an Identifier which allows the user's wallet to interact with an Issuer by authenticating itself first(before the credential can be issued). </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/backup-identity/","title":"Backup Identity","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/backup-identity/#to-backup-identity-backupidentity","title":"To Backup Identity: <code>backupIdentity</code>","text":"<p>This method backs up the identity stored on SDK. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/backup-identity/#backup-an-identity","title":"Backup an Identity","text":"<p>A previously stored <code>IdentityEntity</code> on SDK is backed up using <code>backupIdentity()</code> method. The <code>IdentityEntity</code> is backed up from a <code>privateKey</code> associated with the Identity. </p> <pre><code>Future&lt;Map&lt;int, String&gt;?&gt;backupIdentity({\n    required String privateKey, \n    required blockchain, \n    required network\n}); \n</code></pre> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p>The method returns a <code>map</code> of profile nonces and encrypted databases associated with the identity. </p> <p>If an error occurs, the method throws an <code>IdentityException</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/create-identity/","title":"Create Identity","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/create-identity/#to-create-identity-createidentity","title":"To Create Identity: <code>createIdentity</code>","text":"<p>Creating an Identity is the first step that an Integrator needs to follow for using Polygon ID SDK. An identity is created with a unique identifier that is used to:</p> <ul> <li>Authenticate an Integrator/User</li> <li>Authenticate with the Issuer for issuing credentials to the Identity. Then these credentials are securely stored in the wallet.</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/create-identity/#create-an-identity","title":"Create an Identity","text":"<p>In the SDK, an identity is created using <code>createIdentity()</code> function. This is the entry point for any Integrator.</p> <p></p><pre><code>Future&lt;PrivateIdentityEntity&gt; createIdentity({String? secret, required blockchain, required network}); \n\n{\n    return _createIdentityUseCase.execute(\n        param: CreateIdentityParam(\n      secret: secret,\n    ));\n}\n</code></pre> The <code>createIdentity()</code> function creates and stores an <code>IdentityEntity</code> from a secret if it doesn't exist already on the Polygon ID SDK. If the secret is omitted or null, a random one will be used to create a new identity. It returns an identity as a <code>PrivateIdentityEntity</code>. It throws <code>IdentityException</code> if an error occurs. <p>A <code>secret</code> is a random 32-bytes length array. An Integrator can create this secret in the way he finds it better suited for his/her application. It could be an encrypted mnemonic seed phrase generated with BIP39 (a way of creating mnemonic codes) or an Ethereum private key. If, however, no secret is passed as the input parameter, a random one can be generated. Identity's private key is derived using this secret; this secret is then hashed using Keccak 256 to create the identity's private key. This private key is then used to sign messages.  </p> <p>Note: If the secret is null or omitted, the SDK creates a random one for the creation of the new identity. Depending on the length requirement of the secret string, either an Identity is successfully created or an error is displayed in the form of an exception when the function is executed.</p> <p>Please note that the secret is internally converted to a 32-length bytes array in order to be compatible with the SDK. The following rules will be applied:</p> <ul> <li>If the byte array is not of length 32, it will be padded with 0s(zeroes).</li> <li>If the byte array is longer than 32, an exception will be thrown.</li> </ul> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p>The role of <code>createIdentity()</code> is to create a <code>PrivateIdentityEntity</code> for an Integrator and then store it on the SDK. The identifier and private key that this function generates are used by the Integrator every time it needs to interact with the Identity using the SDK. The <code>PrivateIdentityEntity</code> is created from the secret and represents an identity.</p> <p>So, in a nutshell, <code>createIdentity()</code> creates and stores an identity on the SDK and returns the <code>PrivateIdentityEntity</code> object to the integrator to be able to operate with the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-did-identifier/","title":"Get DID Identifier","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-did-identifier/#to-get-did-identifier-getdididentifier","title":"To Get DID Identifier: <code>getDiDIdentifier</code>","text":"<p>This function returns an identifier (identity's <code>publicKey</code>) from a <code>privateKey</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-did-identifier/#retrieve-did-identifier","title":"Retrieve DID Identifier","text":"<p><code>getDidIdentifier</code> returns a <code>did</code> Identifier using <code>privateKey</code> and <code>profileNonce</code>.</p> <pre><code>Future&lt;String&gt; getDidIdentifier({\n    required String privateKey, \n    required String blockchain, \n    required String network, \n    int? profileNonce\n}); \n</code></pre> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p><code>profileNonce</code> is the nonce of the profile of an identity. </p> <p>Note: It is worth noting that <code>did</code> is a Decentralized Identifier associated with an identity and enables verifiable identities. A <code>did</code> could be a person, thing, organization, or even an abstract entity. The controller of the <code>did</code> can prove that it is the real owner of the identity without the need of seeking permissions/approvals from any centralized authority. </p> <p>A <code>did</code> is expressed in the following format (as per w3.org standards):</p> <p>did: did method: did method-specific identifier</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identities/","title":"Get Identities","text":"<p># To Get Identities: <code>getIdentities</code></p> <p>We can get a list of public information about all the identities stored on the SDK using <code>getIdentities()</code> function. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identities/#get-a-list-of-identities","title":"Get a List of Identities","text":"<pre><code>Future&lt;List&lt;IdentityEntity&gt;&gt; getIdentities();\n\n{\n   return _getIdentitiesUseCase.execute();\n\n}\n</code></pre> This method returns a list of <code>IdentityEntity</code> associated with the identities stored on the SDK. If an error occurs while retrieving the list of <code>IdentityEntity</code>, it throws <code>IdentityException</code>."},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identity/","title":"Get Identity","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identity/#to-get-identity-getidentity","title":"To Get Identity: <code>getIdentity</code>","text":"<p>We can get an identity stored on the SDK using <code>getIdentity()</code> function. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identity/#get-an-identity","title":"Get an Identity","text":"<pre><code>Future&lt;IdentityEntity&gt; getIdentity(\n      {required String genesisDid, \n      String? privateKey\n});\n</code></pre> <p>The <code>getIdentity()</code> function gets an <code>IdentityEntity</code> from an identifier. It returns an identity as a <code>PrivateIdentityEntity</code> or <code>IdentityEntity</code> (in case <code>privateKey</code> is omitted or invalid for that identifier). </p> <p><code>did</code> is the unique ID of the identity and <code>genesisDid</code> is the <code>did</code> of the first profile of the identity, it is the unique ID of the identity for which profile nonce is 0.</p> <p>Note: It is worth noting that <code>did</code> is a Decentralized Identifier associated with an identity and enables verifiable identities. A <code>did</code> could be a person, thing, organization, or even an abstract entity. The controller of the <code>did</code> can prove that it is the real owner of the identity without the need of seeking permissions/approvals from any centralized authority. </p> <p>A <code>did</code> is expressed in the following format (as per w3.org standards):</p> <p>did: did method: did method-specific identifier</p> <p><code>privateKey</code> is the key that is used to access sensitive information related to an identity. This key is also used to generate proofs using the credentials associated with that identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-state/","title":"Get State","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-state/#to-get-identity-state-getstate","title":"To Get Identity State: <code>getState</code>","text":"<p>This function returns the present state of an identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-state/#get-identity-state","title":"Get Identity State","text":"<pre><code>Future&lt;String&gt; getState(String did)\n</code></pre> getState() returns the identity state from <code>did</code>, which is the unique ID of the identity."},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/remove-identity/","title":"Remove Identity","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/remove-identity/#to-remove-identity-removeidentity","title":"To Remove Identity: <code>removeIdentity</code>","text":"<p>In the SDK, an identity is removed using <code>removeIdentity()</code> method. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/remove-identity/#to-remove-an-identity","title":"To Remove an Identity","text":"<pre><code>Future&lt;void&gt; removeIdentity(\n      {required String genesisDid, required String privateKey}); \n</code></pre> <p>The <code>removeIdentity()</code> function removes a previously created and stored Identity from the SDK, The <code>genesisDiD</code> String and the <code>privateKey</code> are passed as parameters to the function.</p> <p><code>genesisDiD</code> is the unique ID of the identity for which profile nonce as zero. </p> <p><code>privateKey</code> is the key that is used to access sensitive information related to an identity. This key is also used to generate proofs using the credentials associated with that identity.</p> <p>If an error occurs, the function throws an <code>IdentityException</code>. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/restore-identity/","title":"Restore Identity","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/restore-identity/#to-restore-identity-restoreidentity","title":"To Restore Identity: <code>restoreIdentity</code>","text":"<p>Restoring an Identity can be done using an identity backup and the secret used to create the identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/restore-identity/#restore-an-identity","title":"Restore an Identity","text":"<p>In the SDK, an identity is restored using <code>restoreIdentity()</code> function. It restores the <code>IdentityEntity</code> from a <code>privateKey</code>and <code>encryptedIdentityDb</code> (Encrypted Identity Database) associated with the identity. </p> <p></p><pre><code>Future&lt;PrivateIdentityEntity&gt; restoreIdentity(\n      {required String privateKey, required String blockchain, required String network, Map&lt;int, String&gt;? encryptedIdentityDbs});\n\n{\n   return _restoreIdentityUseCase.execute(\n        param: RestoreIdentityParam(\n      secret: secret,\n      identityBackup: encryptedIdentityDb,\n    ));\n}\n</code></pre> It returns an identity as a <code>PrivateIdentityEntity</code>and throws <code>IdentityException</code> if an error occurs. <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p>The <code>encryptedIdentityDbs</code> stores all the sensitive information related to the identity. It is a database where all the information associated with an identity is stored and secured by the identity (credentials, state, etc.). This information is stored in the SDK database and is accessible only by an Identity. The <code>encryptedIdentityDbs</code> is passed as a map of <code>key:value</code> pair where <code>key</code> is <code>profileNonce</code> and <code>value</code> is its corresponding <code>encryptedIdentityDb</code> value.</p> <p>In short, the role of <code>restoreIdentity()</code> is to restore an <code>IdentityEntity</code> for an Integrator and then store it on the SDK. It returns the <code>PrivateIdentityEntity</code> object to the integrator to be able to operate with the identity. </p> <p>Note: <code>profileNonce</code> functionality would be a part of the next release of the Wallet SDK.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/sign/","title":"Sign Message","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/sign/#to-sign-message-sign","title":"To Sign Message: <code>sign</code>","text":"<p>In the SDK, a message can be signed using the <code>sign()</code> function. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/sign/#sign-a-message","title":"Sign a Message","text":"<pre><code> Future&lt;String&gt; sign(\n      {required String privateKey, required String message});\n</code></pre> <p>The <code>sign()</code> function signs a message using the identity's private key.</p> <p>The <code>privateKey</code> and the <code>message</code> are passed as the input parameters to the function and a signature string is returned. </p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>message</code> is the actual message sent by the Integrator and it needs to be signed. </p> <p>Thus the role of <code>sign()</code> is to sign a message string for an Integrator using the identity's <code>privateKey</code>.</p> <p></p> <p>Note: When an Integrator scans a QR code, an Iden3 message is created. This message has a <code>challenge</code> field from which the String <code>message</code> (used as input parameter) is generated. The <code>message</code> is then used to sign with the identity to generate a signature string.</p> <p>The Baby Jubjub private key is used to sign the message mentioned above. Read more about Baby Jubjub Elliptic Curve here.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/overview/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/overview/#profile-selection","title":"Profile Selection","text":"<p>The profiles feature allows users to have greater control over their digital identity and privacy. By default, the wallet provides a general profile (based on <code>genesis id</code>), which generates a reusable identifier that can be used to create multiple connections. Apart from the general profile, users can utilize \u201cprivate\u201d profiles that generate a unique identifier to be used for creating connections.</p> <p>Info</p> <p>If you are interested in knowing more about how this feature works under the hood, check this Iden3 page.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/add-profile/","title":"Add Profile","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/add-profile/#to-add-profile-addprofile","title":"To Add Profile: <code>addProfile</code>","text":"<p>This method adds a profile if there isn't already one associated with the identity derived from the private key and stored in the Polygon ID Sdk.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/add-profile/#add-profile","title":"Add Profile","text":"<pre><code>  Future&lt;void&gt; addProfile(\n      {required String genesisDid,\n      required String privateKey,\n      required BigInt profileNonce});\n</code></pre> <p><code>genesisDid</code> is the unique ID of the identity whose <code>profileNonce</code> is 0.</p> <p>The <code>privateKey</code> is the key used to access all the sensitive info from the identity and also to realize operations like generating proofs</p> <p>The <code>profileNonce</code> is the nonce of the profile used from the identity to obtain the DID identifier. The value must be greater than 0 and less than 2^248.</p> <p>The profile will be added using the current env set with <code>PolygonIdSdk.setEnv</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/get-profiles/","title":"Get Profiles","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/get-profiles/#to-get-profiles-getprofiles","title":"To Get Profiles: <code>getProfiles</code>","text":"<p>This method gets a map of profile nonce as key and profile DID as value, associated with the identity derived from the private key and stored in the Polygon ID SDK.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/get-profiles/#get-profiles","title":"Get Profiles","text":"<pre><code>  Future&lt;Map&lt;BigInt, String&gt;&gt; getProfiles(\n      {required String genesisDid, required String privateKey});\n</code></pre> <p><code>genesisDid</code> is the unique ID of the identity whose <code>profileNonce</code> is 0. </p> <p><code>privateKey</code> is the key used to access all the sensitive info from the identity and also to realize operations like generating proofs.</p> <p>It returns a map of . The returned profiles will come from the current env set with <code>PolygonIdSdk.setEnv</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/remove-profile/","title":"Remove Profile","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/remove-profile/#to-remove-profile-removeprofile","title":"To Remove Profile: <code>removeProfile</code>","text":"<p>This removes a profile from the identity derived from the private key and stored in the Polygon ID SDK.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/remove-profile/#remove-profile","title":"Remove Profile","text":"<pre><code>  Future&lt;void&gt; removeProfile(\n      {required String genesisDid,\n      required String privateKey,\n      required BigInt profileNonce});\n</code></pre> <p><code>genesisDid</code> is the unique ID of the identity whose <code>profileNonce</code> is 0.</p> <p><code>privateKey</code> is the key used to access all the sensitive info from the identity and also to realize operations like generating proofs.</p> <p>The <code>profileNonce</code> is the nonce of the profile used from the identity to obtain the DID identifier. The value must be greater than 0 and less than 2^248.</p> <p>The profile will be removed using the current env set with <code>PolygonIdSdk.setEnv</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/profiles/api/update-profile/","title":"Update Profile","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/overview/","title":"Overview","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/overview/#proof-generation-overview","title":"Proof Generation Overview","text":"<p>The proof generation starts with the Wallet scanning the QR code on the Verifier website/app. This is worth mentioning that the proof-generation process initiates on the Verifier side first with the Verifier generating a Query Request.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/overview/#steps-of-proof-generation","title":"Steps of Proof Generation","text":"<ol> <li> <p>Integrator selects the type of credential for which it seeks verification.</p> </li> <li> <p>Verifier website/app displays the QR code depending on the credential type selected by the Integrator.</p> </li> <li> <p>Integrator scans the QR code. By scanning, the Wallet parses the query-based authentication request shown by the Verifier. Read more about auth requests here.</p> </li> <li> <p>Before the Wallet can generate a proof, it needs to authenticate itself first. Upon successful authentication (a pin or biometrics), the Wallet starts the process of generating either a signature-based proof or a merkle-tree-based proof to be presented to the Verifier. The circuit sends back its response to the Verifier via <code>callbackUrl</code>. </p> </li> <li> <p>After the proof is sent to the Verifier, it analyzes this proof for its authenticity and based on its analysis, verifies the proof.</p> </li> <li> <p>The Verifier shows both the authorization request and the proof information to the Integrator.</p> </li> <li> <p>As the verification is complete, an Integrator can now use the services of the Verifier. For example, if the Verifier is a DAO, the Integrator, upon successful verification, becomes a DAO member and can participate in the voting activities. </p> </li> </ol> <p>Read more about the circuits used for proof generation here.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/api/prove/","title":"Generate Proof","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/api/prove/#to-prove-prove","title":"To Prove: <code>prove</code>","text":"<p>The <code>prove()</code> function generates zero-knowledge proof using the valid credentials requested from the Identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/api/prove/#prove","title":"Prove","text":"<p>The prove() method passes <code>did</code>, <code>profileNonce</code>, <code>claim</code>, <code>circuitData</code>, <code>request</code>, and <code>challenge</code> as input parameters. and generates a JWZ proof. </p> <pre><code>Future&lt;JWZProof&gt; prove(\n      {required String did,\n      int? profileNonce,  \n      required ClaimEntity claim,\n      required CircuitDataEntity circuitData, required ProofScopeRequest request, String? privateKey, String? challenge});\n\n   Future&lt;Stream&lt;DownloadInfo&gt;&gt; get initCircuitsDownloadAndGetInfoStream;\n\n  Future&lt;bool&gt; isAlreadyDownloadedCircuitsFromServer(); \n  }\n</code></pre> <p><code>did</code> is the unique ID of the identity <code>profileNonce</code> is the nonce of the profile of the identity <code>claim</code> is the Verifiable Credential  <code>circuitData</code> are the circuits used for generating a proof <code>request</code> is the proof request information that comes from the Verifier <code>challenge</code> is a message the Verifier requires an Integrator to sign with its identity so that an Integrator can verify its identity</p> <p><code>initCircuitsDownloadAndGetInfoStream()</code> and <code>isAlreadyDownloadedCircuitsFromServer()</code> methods above are used for downloading the circuit files as these circuits are too big to be stored on the SDK. </p> <p>The <code>prove()</code> function generates a <code>JWZProof</code> that fulfills the proof query parameters with valid identity and credentials. This proof is shared by an Integrator with a Verifier. The <code>prove()</code> returns a <code>JWZProof</code> object so that the Integrator is able to verify the requested information (requested from Identity) with the Verifier. </p>"}]}