// [ ] TODO: add reference to the Issuer Node as way to create other credentials
// [ ] TODO: fix lining highlighting
// [ ] TODO: Update all the code snippets to the latest version of the library
// [ ] TODO: update reference to the verification keys in step 4


# Run a Verifier

Any application that wants to authenticate user based on their Polygon ID Identity off-chain must set up a Verifier. A Verifier is made of a Server and a Client. 

The Server generates [the ZK Request](./request-api-guide.md) according to the requirements of the platform. There are two types of authentication:

- [**Basic Auth**](./request-api-guide.md#basic-auth): For example, a platform that issues claims must authenticate users by their identifiers before sharing claims with them. 
- [**Query-based Auth**](./request-api-guide.md#query-based-auth): For example, a platform that gives access only to those users that are over 18 years of age.

The second role of the Server is to execute [Verification](./verification-api-guide.md) of the proof sent by the Identity Wallet.

The Verifier Client is the point of interaction with the user. In its simplest form, a client needs to embed a QR code that displays the zk request generated by the Server. The verification request can also be delivered to users via Deep Linking. After scanning the zk request, the user will generate a proof based on that request locally on their wallet. This proof is therefore sent back to the Verifier Server that verifies whether the proof is valid.

This tutorial is based on the verification of a Claim of Type `KYCAgeCredential` with an attribute `birthday` with a Schema URL `https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld`.

The prerequisite is that users have the [Polygon ID Wallet app](../../wallet/wallet-overview.md) installed and self-issued a claim of type `KYC Age Credential Merklized` using our [Issuer Sandbox](https://issuer-v2.polygonid.me/) 

In this example, the verifier will set up the query: "Prove that you were born before the `2000/01/01`. To set up a different query check out the [ZK Query Language section](./zk-query-language.md)

---
**Note:** The executable code for this section can be found <a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration" target="_blank">here</a>.
--- 

## Verifier Server Setup

1. **Add the authorization package to your project** 

	=== "GoLang"

		``` bash 
		go get github.com/iden3/go-iden3-auth
		```

	=== "Javascript"

		```bash 
		npm i @iden3/js-iden3-auth --save
		```

2. **Set up a server** 

	Initiate a server that contains two endpoints: 

	- GET /api/sign-in: Returns auth request.
	- POST /api/callback: Receives the callback request from the identity wallet containing the proof and verifies it.

	=== "GoLang"

		```go 
		package main

		import (
			"encoding/json"
			"fmt"
			"io"
			"log"
			"net/http"
			"strconv"
			"time"

			"github.com/ethereum/go-ethereum/common"
			"github.com/iden3/go-circuits"
			auth "github.com/iden3/go-iden3-auth"
			"github.com/iden3/go-iden3-auth/loaders"
			"github.com/iden3/go-iden3-auth/pubsignals"
			"github.com/iden3/go-iden3-auth/state"
			"github.com/iden3/iden3comm/protocol"
		)

		func main() {
			http.HandleFunc("/api/sign-in", GetAuthRequest)
			http.HandleFunc("/api/callback", Callback)
			http.ListenAndServe(":8080", nil)
		}

		// Create a map to store the auth requests and their session IDs
		var requestMap = make(map[string]interface{})
		```

	=== "Javascript"

		```js
		const express = require('express');
		const {auth, resolver, loaders} = require('@iden3/js-iden3-auth')
		const getRawBody = require('raw-body')

		const app = express();
		const port = 8080;

		app.get("/api/sign-in", (req, res) => {
			console.log('get Auth Request');
			GetAuthRequest(req,res);
		});

		app.post("/api/callback", (req, res) => {
			console.log('callback');
			Callback(req,res);
		});

		app.listen(port, () => {
			console.log('server running on port 8080');
		});

		// Create a map to store the auth requests and their session IDs
		const requestMap = new Map();
		```

3. **Sign-in endpoint** 

	This endpoint generates the auth request for the user. Using this endpoint, the developers set up the requirements that users must meet in order to authenticate.

	> If created using Polygon ID Platform, the schema URL can be fetched from there and pasted inside your Query

	=== "GoLang"

		```go hl_lines="11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"
		func GetAuthRequest(w http.ResponseWriter, r *http.Request) {

			// Audience is verifier id
			rURL := "<YOUR REMOTE NGROK HOST ON PORT 8080>";
			sessionID := 1
			CallbackURL := "/api/callback"
			Audience := "did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs"

			uri := fmt.Sprintf("%s%s?sessionId=%s", rURL, CallbackURL, strconv.Itoa(sessionID))

			// Generate request for basic authentication
			var request protocol.AuthorizationRequestMessage = auth.CreateAuthorizationRequest("test flow", Audience, uri)

			request.ID = "7f38a193-0918-4a48-9fac-36adfdb8b542"
			request.ThreadID = "7f38a193-0918-4a48-9fac-36adfdb8b542"

			// Add request for a specific proof
			var mtpProofRequest protocol.ZeroKnowledgeProofRequest
			mtpProofRequest.ID = 1
			mtpProofRequest.CircuitID = string(circuits.AtomicQuerySigV2CircuitID)
			mtpProofRequest.Query = map[string]interface{}{
				"allowedIssuers": []string{"*"},
				"credentialSubject": map[string]interface{}{
					"birthday": map[string]interface{}{
						"$lt": 20000101,
					},
				},
				"context": "https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld",
				"type":    "KYCAgeCredential",
			}
			request.Body.Scope = append(request.Body.Scope, mtpProofRequest)

			// Store auth request in map associated with session ID
			requestMap[strconv.Itoa(sessionID)] = request

			msgBytes, _ := json.Marshal(request)

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
			w.Write(msgBytes)
			return
		}
		```

	=== "Javascript"

		```js hl_lines="23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44"
		// GetAuthRequest returns auth request
		async function GetAuthRequest(req,res) {

			// Audience is verifier id
			const hostUrl = '<YOUR REMOTE NGROK HOST ON PORT 8080>'; 
			const sessionId = 1;
			const callbackURL = "/api/callback"
			const audience = "1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ"

			const uri = `${hostUrl}${callbackURL}?sessionId=${sessionId}`;

			// Generate request for basic auth
			const request = auth.createAuthorizationRequestWithMessage(
				'test flow',
				'message to sign',
				audience,
				uri,
			);
			
			request.id = '7f38a193-0918-4a48-9fac-36adfdb8b542';
			request.thid = '7f38a193-0918-4a48-9fac-36adfdb8b542';

			// Add query-based request
			const proofRequest = {
			id: 1,
			circuit_id: 'credentialAtomicQuerySig',
			rules: {
				query: {
				allowedIssuers: ['*'],
				schema: {
					type: 'AgeCredential',
					url: '{add your schema url here}',
				},
				req: {
					dateOfBirth: {
					$lt: 20000101, // dateOfBirth field less then 2000/01/01
					},
				},
				},
			},
			};

			const scope = request.body.scope ?? [];
			request.body.scope = [...scope, proofRequest];

			// Store zk request in map associated with session ID
			requestMap.set(`${sessionId}`, request);

			return res.status(200).set('Content-Type', 'application/json').send(request);

		}
		```
	> Note: The highlighted lines are to be added only if the authentication needs to design a [query](./zk-query-language.md) for a specific proof as in the case of [Query-based Auth](./request-api-guide.md#query-based-auth). When not included, it will perform a [Basic Auth](./request-api-guide.md#basic-auth). 

4. **Callback Endpoint**

	The request generated in the previous endpoint already contains the CallBackURL so that the response generated by the wallet will be automatically forwarded to the server callback function. The callback post endpoint receives the proof generated by the identity wallet. The role of the callback endpoint is to execute the [Verification](verification-api-guide.md) on the proof.

	> To ADD: The identity state `contractAddress` on Polygon Mumbai is 0xEA9aF2088B4a9770fC32A12fD42E61BDD317E655. The public verification keys for iden3 circuits generated after the trusted setup can be found <a href="https://github.com/iden3/tutorial-examples/tree/main/verifier-integration/keys" target="_blank">here</a> and must be added to your project inside a folder called `keys`. Also, don't forget to add the Mumbai RPC endpoint (such as Alchemy or Infura) inside the `ethURL` variable!

	=== "GoLang"

		```go
		// Callback verifies the proof after sign-in callbacks
		func Callback(w http.ResponseWriter, r *http.Request) {

			// Get session ID from request
			sessionID := r.URL.Query().Get("sessionId")

			// extract proof from the request
			tokenBytes, err := io.ReadAll(r.Body)

			// Add Polygon Mumbai RPC node endpoint - needed to read on-chain state
			ethURL := "<RPCNODEURL>"

			// Add identity state contract address
			contractAddress := "0xEA9aF2088B4a9770fC32A12fD42E61BDD317E655"

			// Add prefix for Polygon Mumbai
			resolverPrefix := "polygon:mumbai"

			// Locate the directory that contains circuit's verification keys
			keyDIR := "../keys"

			// Fetch authRequest from sessionID
			authRequest, _ := requestMap[sessionID]

			// load the verifcation key
			var verificationKeyloader = &loaders.FSKeyLoader{Dir: keyDIR}

			// Create a state resolver
			resolver := state.ETHResolver{
				RPCUrl:          ethURL,
				ContractAddress: common.HexToAddress(contractAddress),
			}

			resolvers := map[string]pubsignals.StateResolver{
				resolverPrefix: resolver,
			}

			// Create instance of a verifier
			verifier := auth.NewVerifier(verificationKeyloader, loaders.DefaultSchemaLoader{IpfsURL: "ipfs.io"}, resolver)
			
			// Execute full verification
			authResponse, err := verifier.FullVerify(
				r.Context(),
				string(tokenBytes),
				authRequest.(protocol.AuthorizationRequestMessage),
				pubsignals.WithAcceptedStateTransitionDelay(time.Minute*5))
			if err != nil {
				log.Println(err.Error())
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			userID := authResponse.From

			messageBytes := []byte("User with ID " + userID + " Successfully authenticated")

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(messageBytes)

			return
		}
		```

	=== "Javascript"

		```js
		// Callback verifies the proof after sign-in callbacks
		async function Callback(req,res) {

			// Get session ID from request
			const sessionId = req.query.sessionId;

			// extract proof from the request
			const raw = await getRawBody(req);
			const tokenStr = raw.toString().trim();

			// fetch authRequest from sessionID
			const authRequest = requestMap.get(`${sessionId}`);
				
			// Locate the directory that contains circuit's verification keys
			const verificationKeyloader = new loaders.FSKeyLoader('../keys');
			const sLoader = new loaders.UniversalSchemaLoader('ipfs.io');

			// Add Polygon Mumbai RPC node endpoint - needed to read on-chain state and identity state contract address
			const ethStateResolver = new resolver.EthStateResolver('<Polygon Mumbai RPC NODE>', '0x46Fd04eEa588a3EA7e9F055dd691C688c4148ab3');

			// EXECUTE VERIFICATION
			const verifier = new auth.Verifier(
			verificationKeyloader,
			sLoader, ethStateResolver,
		);


		try {
			authResponse = await verifier.fullVerify(tokenStr, authRequest);
		} catch (error) {
		return res.status(500).send(error);
		}
		return res.status(200).set('Content-Type', 'application/json').send("user with ID: " + authResponse.from + " Succesfully authenticated");
		}
		```

> If you need to deploy an App or to build a Docker container you'll need to bundle the [libwasmer.so](https://github.com/iden3/go-rapidsnark/tree/main/witness) library together with the app. 

## Verifier Client Setup

The Verifier Client must fetch the Auth Request generated by the Server ("/api/sign-in" endpoint) and deliver it to the user via a QR Code. 

To do so, add the <a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration/js/static" target="_blank">Static Folder</a> to your Verifier repository. This folder contains an HTML static webpage that renders a static webpage with the QR code containing the Auth Request.

> To display the QR code inside your frontend, you can use the `express.static` built-in middleware function together with this <a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration/js/static" target="_blank">Static Folder</a> or this [Code Sandbox](https://codesandbox.io/s/yp1pmpjo4z?file=/index.js).

The same request can also be delivered to users via Deep Linking. In order to do so is necessary to encode the `request` file to Base64 Format. The related deep link would be `iden3comm://?i_m={{base64EncodedRequestHere}}`.

1. **Add routing to your Express Server**

	To serve static files, we use the <a href="https://expressjs.com/en/starter/static-files.html" target="_blank">express.static built-in middleware function</a>.

	```js hl_lines="8"
	const express = require('express');
	const {auth, resolver, loaders} = require('@iden3/js-iden3-auth')
	const getRawBody = require('raw-body')

	const app = express();
	const port = 8080;

	app.use(express.static('static'));

	app.get("/api/sign-in", (req, res) => {
		console.log('get Auth Request');
		GetAuthRequest(req,res);
	});

	app.post("/api/callback", (req, res) => {
		console.log('callback');
		Callback(req,res);
	});

	app.listen(port, () => {
		console.log('server running on port 8080');
	});

	// Create a map to store the auth requests and their session IDs
	const requestMap = new Map();
	```

2. **Visit http://localhost:8080/**

	When visiting the URL, the users will need to scan the QR code with their id wallets.

	<div align="center">
	<img src= "../../../imgs/verifier-static-1.png" align="" width="600"/>
	<img src= "../../../imgs/verifier-static-2.png" align="" width="600"/>
	<div align="center"><span style="font-size: 14px;">
	<br>
	<b> Sign Up with Polygon ID - Client Side </b></div>
	<br>
	</div>

3. **Implement Further Logic**

	This tutorial showcased a minimalistic application that leverages Polygon ID libraries for authentication purposes. Developers can leverage the broad set of existing claims held by users to set up any customized Query using our [zk Query Language](./zk-query-language.md) to unleash the full potential of the framework. 

	For example, the concept can be extended to exchanges that require KYC claims, DAOs that require proof-of-personhood claims, or social media applications that intend to re-use users' aggregated reputation.