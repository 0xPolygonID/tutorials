# Run a Verifier

Any application that wants to authenticate users based on their Polygon ID Identity off-chain must set up a Verifier. A Verifier is made of a Server and a Client. 

The Server generates [the ZK Request](./request-api-guide.md) according to the requirements of the platform. There are two types of authentication:

- [**Basic Auth**](./request-api-guide.md#basic-auth): For example, a platform that issues Credentials must authenticate users by their identifiers before sharing Credentials with them. 
- [**Query-based Auth**](./request-api-guide.md#query-based-auth): For example, a platform that gives access only to those users that are over 18 years of age.

The second role of the Server is to execute [Verification](./verification-api-guide.md) of the proof sent by the Identity Wallet.

The Verifier Client is the point of interaction with the user. In its simplest form, a client needs to embed a QR code that displays the zk request generated by the Server. The verification request can also be delivered to users via Deep Linking. After scanning the zk request, the user will generate a proof based on that request locally on their wallet. This proof is therefore sent back to the Verifier Server that verifies whether the proof is valid.

This tutorial is based on the verification of a Credential of Type `KYCAgeCredential` with an attribute `birthday` with a Schema URL `https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld`.

The prerequisite is that users have the [Polygon ID Wallet app](../../wallet/wallet-overview.md) installed and self-issued a Credential of type `KYC Age Credential Merklized` using our [Demo Issuer](https://issuer-demo.polygonid.me/). Further credentials can be issued using the [Issuer Node](../../issuer/issuer-overview.md).

In this example, the verifier will set up the query: "Prove that you were born before the `2000/01/01`. To set up a different query check out the [ZK Query Language section](./zk-query-language.md)

---
**Note:** The executable code for this section can be found <a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration" target="_blank">here</a>.

--- 

## Verifier Server Setup

1. **Add the authorization package to your project** 

	=== "GoLang"

		``` bash 
		go get github.com/iden3/go-iden3-auth
		```

	=== "Javascript"

		```js
		npm i @iden3/js-iden3-auth
		```  

2. **Set up a server** 

	Initiate a server that contains two endpoints: 

	- GET /api/sign-in: Returns auth request.
	- POST /api/callback: Receives the callback request from the identity wallet containing the proof and verifies it.

	=== "GoLang"

		```go 
		package main

		import (
			"encoding/json"
			"fmt"
			"io"
			"log"
			"net/http"
			"strconv"
			"time"

			"github.com/ethereum/go-ethereum/common"
			"github.com/iden3/go-circuits"
			auth "github.com/iden3/go-iden3-auth"
			"github.com/iden3/go-iden3-auth/loaders"
			"github.com/iden3/go-iden3-auth/pubsignals"
			"github.com/iden3/go-iden3-auth/state"
			"github.com/iden3/iden3comm/protocol"
		)

		func main() {
			http.HandleFunc("/api/sign-in", GetAuthRequest)
			http.HandleFunc("/api/callback", Callback)
			http.ListenAndServe(":8080", nil)
		}

		// Create a map to store the auth requests and their session IDs
		var requestMap = make(map[string]interface{})
		```
	
	=== "Javascript"

		```js
		const express = require('express');
		const {auth, resolver, loaders} = require('@iden3/js-iden3-auth')
		const getRawBody = require('raw-body')

		const app = express();
		const port = 8080;

		app.get("/api/sign-in", (req, res) => {
			console.log('get Auth Request');
			GetAuthRequest(req,res);
		});

		app.post("/api/callback", (req, res) => {
			console.log('callback');
			Callback(req,res);
		});

		app.listen(port, () => {
			console.log('server running on port 8080');
		});

		// Create a map to store the auth requests and their session IDs
		const requestMap = new Map();

		```  

3. **Sign-in endpoint** 

	This endpoint generates the auth request for the user. Using this endpoint, the developers set up the requirements that users must meet in order to authenticate.

	> If created using Polygon ID Platform, the schema URL can be fetched from there and pasted inside your Query

	=== "GoLang"

		```go hl_lines="11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"
		func GetAuthRequest(w http.ResponseWriter, r *http.Request) {

			// Audience is verifier id
			rURL := "NGROK URL"
			sessionID := 1
			CallbackURL := "/api/callback"
			Audience := "did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs"

			uri := fmt.Sprintf("%s%s?sessionId=%s", rURL, CallbackURL, strconv.Itoa(sessionID))

			// Generate request for basic authentication
			var request protocol.AuthorizationRequestMessage = auth.CreateAuthorizationRequest("test flow", Audience, uri)

			request.ID = "7f38a193-0918-4a48-9fac-36adfdb8b542"
			request.ThreadID = "7f38a193-0918-4a48-9fac-36adfdb8b542"

			// Add request for a specific proof
			var mtpProofRequest protocol.ZeroKnowledgeProofRequest
			mtpProofRequest.ID = 1
			mtpProofRequest.CircuitID = string(circuits.AtomicQuerySigV2CircuitID)
			mtpProofRequest.Query = map[string]interface{}{
				"allowedIssuers": []string{"*"},
				"credentialSubject": map[string]interface{}{
					"birthday": map[string]interface{}{
						"$lt": 20000101,
					},
				},
				"context": "https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld",
				"type":    "KYCAgeCredential",
			}
			request.Body.Scope = append(request.Body.Scope, mtpProofRequest)

			// Store auth request in map associated with session ID
			requestMap[strconv.Itoa(sessionID)] = request

			// print request
			fmt.Println(request)

			msgBytes, _ := json.Marshal(request)

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
			w.Write(msgBytes)
			return
		}
		```
	
	=== "Javascript"

		```js hl_lines="11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37"
		async function GetAuthRequest(req,res) {

			// Audience is verifier id
			const hostUrl = "<NGROK_URL>";
			const sessionId = 1;
			const callbackURL = "/api/callback"
			const audience = "did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs"

			const uri = `${hostUrl}${callbackURL}?sessionId=${sessionId}`;

			// Generate request for basic authentication
			const request = auth.createAuthorizationRequest(
				'test flow',
				audience,
				uri,
			);
			
			request.id = '7f38a193-0918-4a48-9fac-36adfdb8b542';
			request.thid = '7f38a193-0918-4a48-9fac-36adfdb8b542';

			// Add request for a specific proof
			const proofRequest = {
				id: 1,
				circuitId: 'credentialAtomicQuerySigV2',
				query: {
				  allowedIssuers: ['*'],
				  type: 'KYCAgeCredential',
				  context: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld',
				  credentialSubject: {
					birthday: {
					  $lt: 20000101,
					},
				  },
			  },
			  };
			const scope = request.body.scope ?? [];
			request.body.scope = [...scope, proofRequest];
			 
			// Store auth request in map associated with session ID
			requestMap.set(`${sessionId}`, request);

			return res.status(200).set('Content-Type', 'application/json').send(request);
        }
		```  

	> Note: The highlighted lines are to be added only if the authentication needs to design a [query](./zk-query-language.md) for a specific proof as in the case of [Query-based Auth](./request-api-guide.md#query-based-auth). When not included, it will perform a [Basic Auth](./request-api-guide.md#basic-auth). 

4. **Callback Endpoint**

	The request generated in the previous endpoint already contains the CallBackURL so that the response generated by the wallet will be automatically forwarded to the server callback function. The callback post endpoint receives the proof generated by the identity wallet. The role of the callback endpoint is to execute the [Verification](verification-api-guide.md) on the proof.

	!!!info "Testnet / Mainnet"
		The code samples on this page are using Polygon's Testnet Mumbai, including the smart contract address and the RPC endpoint in the `ethURL` variable. If you want to use the Mainnet, you need to add
		a resolver for it. 

		Mainnet contract address: `0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D`

		DID prefix: `polygon:main`

		```go
		const RPC_URL = 'RPC_URL>';
		const mainContractAddress = "0x624ce98D2d27b20b8f8d521723Df8fC4db71D79D"

		const mainStateResolver = new resolver.EthStateResolver(
			RPC_URL,
			mainContractAddress,
		);

		const resolvers = {
			['polygon:mumbai']: ethStateResolver,
			['polygon:main']: mainStateResolver,
		};
		```

		A Verifier can work with multiple networks simultaneously. Even users and issuers can be on different networks. The verifier library can properly resolve the state of the issuer and the user from the different networks.

	!!!note
		The public verification keys for Iden3 circuits generated after the trusted setup can be found <a href="https://github.com/0xPolygonID/phase2ceremony" target="_blank">here</a> and must be added to your project inside a folder called `keys`. 

	=== "GoLang"

		```go
		// Callback works with sign-in callbacks
		func Callback(w http.ResponseWriter, r *http.Request) {

			// Get session ID from request
			sessionID := r.URL.Query().Get("sessionId")

			// get JWZ token params from the post request
			tokenBytes, _ := io.ReadAll(r.Body)

			// Add Polygon Mumbai RPC node endpoint - needed to read on-chain state
			ethURL := "https://polygon-testnet-rpc.allthatnode.com:8545"

			// Add identity state contract address
			contractAddress := "0x134B1BE34911E39A8397ec6289782989729807a4"

			resolverPrefix := "polygon:mumbai"

			// Locate the directory that contains circuit's verification keys
			keyDIR := "../keys"

			// fetch authRequest from sessionID
			authRequest := requestMap[sessionID]

			// print authRequest
			fmt.Println(authRequest)

			// load the verifcation key
			var verificationKeyloader = &loaders.FSKeyLoader{Dir: keyDIR}
			resolver := state.ETHResolver{
				RPCUrl:          ethURL,
				ContractAddress: common.HexToAddress(contractAddress),
			}

			resolvers := map[string]pubsignals.StateResolver{
				resolverPrefix: resolver,
			}

			// EXECUTE VERIFICATION
			verifier, err := auth.NewVerifierWithExplicitError(verificationKeyloader, loaders.DefaultSchemaLoader{IpfsURL: "ipfs.io"}, resolvers)
			if err != nil {
				log.Println(err.Error())
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			authResponse, err := verifier.FullVerify(
				r.Context(),
				string(tokenBytes),
				authRequest.(protocol.AuthorizationRequestMessage),
				pubsignals.WithAcceptedStateTransitionDelay(time.Minute*5))
			if err != nil {
				log.Println(err.Error())
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			userID := authResponse.From

			messageBytes := []byte("User with ID " + userID + " Successfully authenticated")

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(messageBytes)

			return
		}
		```

	=== "Javascript"

		```js
		async function Callback(req,res) {

			// Get session ID from request
			const sessionId = req.query.sessionId;

			// get JWZ token params from the post request
			const raw = await getRawBody(req);
			const tokenStr = raw.toString().trim();

			const ethURL = '<MUMBAI_RPC_URL>';
			const contractAddress = "0x134B1BE34911E39A8397ec6289782989729807a4"
			const keyDIR = "../keys"

			const ethStateResolver = new resolver.EthStateResolver(
				ethURL,
				contractAddress,
			  );

			const resolvers = {
				['polygon:mumbai']: ethStateResolver,
			};
							 

			// fetch authRequest from sessionID
			const authRequest = requestMap.get(`${sessionId}`);
				
			// Locate the directory that contains circuit's verification keys
			const verificationKeyloader = new loaders.FSKeyLoader(keyDIR);
			const sLoader = new loaders.UniversalSchemaLoader('ipfs.io');

			// EXECUTE VERIFICATION
			const verifier = await Verifier.newVerifier(
				verificationKeyloader,
				resolvers,
				{
					ipfsGatewayURL:"<gateway url>"
				},
			);


		try {
			const opts = {
				AcceptedStateTransitionDelay: 5 * 60 * 1000, // 5 minute
			  };		
			authResponse = await verifier.fullVerify(tokenStr, authRequest, opts);
		} catch (error) {
		return res.status(500).send(error);
		}
		return res.status(200).set('Content-Type', 'application/json').send("user with ID: " + authResponse.from + " Succesfully authenticated");
		}
		```  

> If you need to deploy an App or to build a Docker container, you'll need to bundle the [libwasmer.so](https://github.com/iden3/go-rapidsnark/tree/main/witness) library together with the app. 

## Verifier Client Setup

The Verifier Client must fetch the Auth Request generated by the Server ("/api/sign-in" endpoint) and deliver it to the user via a QR Code. 

> To display the QR code inside your frontend, you can use this [Code Sandbox](https://codesandbox.io/s/yp1pmpjo4z?file=/index.js).

The same request can also be delivered to users via Deep Linking. In order to do so, it is necessary to encode the `request` file to Base64 Format. The related deep link would be `iden3comm://?i_m={{base64EncodedRequestHere}}`.

**Implement Further Logic**

This tutorial showcased a minimalistic application that leverages Polygon ID libraries for authentication purposes. Developers can leverage the broad set of existing Credentials held by users to set up any customized Query using our [zk Query Language](./zk-query-language.md) to unleash the full potential of the framework. 

For example, the concept can be extended to exchanges that require KYC Credentials, DAOs that require proof-of-personhood Credentials, or social media applications that intend to re-use users' aggregated reputation.


To do so, add the <a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration/js/static" target="_blank">Static Folder</a> to your Verifier repository. This folder contains an HTML static webpage that renders a static webpage with the QR code containing the Auth Request.

> To display the QR code inside your frontend, you can use the `express.static` built-in middleware function together with this <a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration/js/static" target="_blank">Static Folder</a> or this [Code Sandbox](https://codesandbox.io/s/yp1pmpjo4z?file=/index.js).


1. **Add routing to your Express Server**

	To serve static files, we use the <a href="https://expressjs.com/en/starter/static-files.html" target="_blank">express.static built-in middleware function</a>.

	```js hl_lines="8"
	const express = require('express');
	const {auth, resolver, loaders} = require('@iden3/js-iden3-auth')
	const getRawBody = require('raw-body')

	const app = express();
	const port = 8080;

	app.use(express.static('static'));

	app.get("/api/sign-in", (req, res) => {
		console.log('get Auth Request');
		GetAuthRequest(req,res);
	});

	app.post("/api/callback", (req, res) => {
		console.log('callback');
		Callback(req,res);
	});

	app.listen(port, () => {
		console.log('server running on port 8080');
	});

	// Create a map to store the auth requests and their session IDs
	const requestMap = new Map();
	```

2. **Visit http://localhost:8080/**

	When visiting the URL, the users will need to scan the QR code with their id wallets.

	<div align="center">
	<img src= "../../../imgs/verifier-static-1.png" align="" width="600"/>
	<img src= "../../../imgs/verifier-static-2.png" align="" width="600"/>
	<div align="center"><span style="font-size: 14px;">
	<br>
	<b> Sign Up with Polygon ID - Client Side </b></div>
	<br>
	</div>
