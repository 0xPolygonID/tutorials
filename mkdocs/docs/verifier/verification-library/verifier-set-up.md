# Run a Verifier

Any application that needs user authentication must set up a Verifier. A Verifier is made of a Server and a Client. 

The Server generates [Auth Requests](./request-api-guide.md) according to the requirements of the platform; There are two types of authentication:

- [**Basic Auth**](./request-api-guide.md#basic-auth), for example a platform that issue claims must authenticate users by their identifier before sharing claims with them. 
- [**Query-based Auth**](./request-api-guide.md#query-based-auth), for example a platform that gates access only to users that are over 18 yo

The second role of the Server is to execute [Verification](./verification-api-guide.md) of the proof sent by the Identity Wallet.

The Verifier Client is the point of interaction with the user. In its simplest form, a client needs to embed a QR code that displays the auth request generated by the Server.

To interact with a Verifier users should have the Polygon ID identity wallet (or any compatible wallet) installed on their devices.

> The executable code for this section can be found [here](https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration)

## Verifier Server Setup

1. **Add the authorization package to your project** 

	=== "GoLang"

		``` bash 
		go get github.com/iden3/go-iden3-auth
		```

	=== "Javascript"

		```bash 
		npm i @iden3/js-iden3-auth --save
		```

2. **Set up a server** 

	Initiate a server that contains two endpoints: 

	- GET /api/sign-in : returns auth request
	- POST /api/callback : receives the callback request from the identity wallet containing the proof and verifies it

	=== "GoLang"

		```go 
		package main

		import (
			"encoding/json"
			"fmt"
			"io"
			"net/http"
			"strconv"
			"time"

			"github.com/iden3/go-circuits"
			auth "github.com/iden3/go-iden3-auth"
			"github.com/iden3/go-iden3-auth/loaders"
			"github.com/iden3/go-iden3-auth/pubsignals"
			"github.com/iden3/go-iden3-auth/state"
			"github.com/iden3/iden3comm/protocol"
		)

		func main() {
			http.HandleFunc("/api/sign-in", GetAuthRequest)
			http.HandleFunc("/api/callback", Callback)
			http.ListenAndServe(":8080", nil)
		}

		// Create a map to store the auth requests and their session IDs
		var requestMap = make(map[string]interface{})
		```

	=== "Javascript"

		```js
		const express = require('express');
		const {auth, resolver, loaders} = require('@iden3/js-iden3-auth')
		const getRawBody = require('raw-body')

		const app = express();
		const port = 8080;

		app.get("/api/sign-in", (req, res) => {
			console.log('get Auth Request');
			GetAuthRequest(req,res);
		});

		app.post("/api/callback", (req, res) => {
			console.log('callback');
			Callback(req,res);
		});

		app.listen(port, () => {
			console.log('server running on port 8080');
		});

		// Create a map to store the auth requests and their session IDs
		const requestMap = new Map();
		```

3. **Sign-in endpoint** 

	This endpoint generates the auth request for the user. Here's where developers set up the requirements that users must meet in order to sign-in. 

	=== "GoLang"

		```go hl_lines="20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39"
		// GetAuthRequest returns auth request
		func GetAuthRequest(w http.ResponseWriter, r *http.Request) {

			// Audience is verifier id
			rURL := "<YOUR REMOTE NGROK HOST>";
			sessionID := 1
			CallbackURL := "/api/callback"
			Audience := "1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ"

			uri := fmt.Sprintf("%s%s?sessionId=%s", rURL, CallbackURL, strconv.Itoa(sessionID))

			var request protocol.AuthorizationRequestMessage

			// Generate request for basic authentication
			request = auth.CreateAuthorizationRequestWithMessage("test flow", "message to sign", Audience, uri)

			request.ID = "7f38a193-0918-4a48-9fac-36adfdb8b542"
			request.ThreadID = "7f38a193-0918-4a48-9fac-36adfdb8b542"

			// Add request for a specific proof
			var mtpProofRequest protocol.ZeroKnowledgeProofRequest
			mtpProofRequest.ID = 1
			mtpProofRequest.CircuitID = string(circuits.AtomicQuerySigCircuitID)
			mtpProofRequest.Rules = map[string]interface{}{
				"query": pubsignals.Query{
					AllowedIssuers: []string{"*"},
					Req: map[string]interface{}{
						"birthDay": map[string]interface{}{
							"$lt": 20000101,
						},
					},
					Schema: protocol.Schema{
						URL:  "https://schema.polygonid.com/jsonld/kyc.json-ld",
						Type: "AgeCredential",
					},
				},
			}

			request.Body.Scope = append(request.Body.Scope, mtpProofRequest)

			// Store auth request in map associated with session ID
			requestMap[strconv.Itoa(sessionID)] = request

			msgBytes, _ := json.Marshal(request)
			

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
			w.Write(msgBytes)
			return
		}
		```

	=== "Javascript"

		```js hl_lines="23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44"
		// GetAuthRequest returns auth request
		async function GetAuthRequest(req,res) {

			// Audience is verifier id
			const hostUrl = '<YOUR REMOTE NGROK HOST>'; 
			const sessionId = 1;
			const callbackURL = "/api/callback"
			const audience = "1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ"

			const uri = `${hostUrl}${callbackURL}?sessionId=${sessionId}`;

			// Generate request for basic authentication
			const request = auth.createAuthorizationRequestWithMessage(
				'test flow',
				'message to sign',
				audience,
				uri,
			);
			
			request.id = '7f38a193-0918-4a48-9fac-36adfdb8b542';
			request.thid = '7f38a193-0918-4a48-9fac-36adfdb8b542';

			// Add request for a specific proof
			const proofRequest = {
			id: 1,
			circuit_id: 'credentialAtomicQuerySig',
			rules: {
				query: {
				allowedIssuers: ['*'],
				schema: {
					type: 'AgeCredential',
					url: 'https://schema.polygonid.com/jsonld/kyc.json-ld',
				},
				req: {
					birthDay: {
					$lt: 20000101, // bithDay field less then 2000/01/01
					},
				},
				},
			},
			};

			const scope = request.body.scope ?? [];
			request.body.scope = [...scope, proofRequest];

			// Store auth request in map associated with session ID
			requestMap.set(`${sessionId}`, request);

			return res.status(200).set('Content-Type', 'application/json').send(request);

		}
		```

	> Note: the highlighted lines are to be added only if the authentication needs to design a [query](./zk-query-language.md) for a specific proof as in the case of [Query-based Auth](./request-api-guide.md#query-based-auth). Without including it will permorm a [Basic Auth](./request-api-guide.md#basic-auth) 

4. **Callback endpoint**

	The request generated in the previous endpoint already contains the CallBackURL so that the response generated by the wallet will be automatically forwarded to the server callback function. The callback post endpoint receives the [JWZ](./jwz.md) containing the proof from the identity wallet. The role of the callback endpoint is to execute the [Verification](verification-api-guide.md) on the proof.

	> To ADD: The identity state `contractAddress` on polygon mainnet is 0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8. The public verification keys for iden3 circuits generated after the trusted setup can be found [here](https://github.com/iden3/tutorial-examples/tree/main/verifier-integration/keys) and must be added to your project inside a folder called `keys`. Also, don't forget to add the RPC endpoint (such as Alchemy or Infura) inside the `ethURL` variable!

	=== "GoLang"

		```go
		// Callback verifies the proof after sign-in callbacks
		func Callback(w http.ResponseWriter, r *http.Request) {

			// Get session ID from request
			sessionID := r.URL.Query().Get("sessionId")

			// get JWZ token params from the post request
			tokenBytes, err := io.ReadAll(r.Body)

			// Add Polygon RPC node endpoint - needed to read on-chain state
			ethURL := "<RPCNODEURL>"

			// Add identity state contract address
			contractAddress := "0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8"

			// Locate the directory that contains circuit's verification keys
			keyDIR := "../keys"

			// fetch authRequest from sessionID
			authRequest, _ := requestMap[sessionID]

			// load the verifcation key
			var verificationKeyloader = &loaders.FSKeyLoader{Dir: keyDIR}
			resolver := state.ETHResolver{
				RPCUrl:   ethURL,
				Contract: contractAddress,
			}

			// EXECUTE VERIFICATION
			verifier := auth.NewVerifier(verificationKeyloader, loaders.DefaultSchemaLoader{IpfsURL: "ipfs.io"}, resolver)
			authResponse, err := verifier.FullVerify(r.Context(), string(tokenBytes),
				authRequest.(protocol.AuthorizationRequestMessage))
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			userID := authResponse.From

			messageBytes := []byte("User with ID " + userID + " Successfully authenticated")

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			w.Write(messageBytes)

			return

		}
		```

	=== "Javascript"

		```js
		// Callback verifies the proof after sign-in callbacks
		async function Callback(req,res) {

			// Get session ID from request
			const sessionId = req.query.sessionId;

			// get JWZ token params from the post request
			const raw = await getRawBody(req);
			const tokenStr = raw.toString().trim();

			// fetch authRequest from sessionID
			const authRequest = requestMap.get(`${sessionId}`);
				
			// Locate the directory that contains circuit's verification keys
			const verificationKeyloader = new loaders.FSKeyLoader('../keys');
			const sLoader = new loaders.UniversalSchemaLoader('ipfs.io');

			// Add Polygon RPC node endpoint - needed to read on-chain state and identity state contract address
			const ethStateResolver = new resolver.EthStateResolver('<RPCNODEURL>', '0xb8a86e138C3fe64CbCba9731216B1a638EEc55c8');

			// EXECUTE VERIFICATION
			const verifier = new auth.Verifier(
			verificationKeyloader,
			sLoader, ethStateResolver,
		);


		try {
			authResponse = await verifier.fullVerify(tokenStr, authRequest);
		} catch (error) {
		return res.status(500).send(error);
		}
		return res.status(200).set('Content-Type', 'application/json').send("user with ID: " + authResponse.from + " Succesfully authenticated");
		}
		```


## Verifier Client Setup

The Verifier Client must fetch the Auth Request generated by the Server ("/api/sign-in" endpoint) and deliver it to the user via a QR Code. 

To do so add the [Static Folder](https://github.com/0xPolygonID/tutorial-examples/tree/main/verifier-integration/js/static) to your Verifier repo. This folder contains a HTML static webpage that renders a static weboage with the QR code containing the auth Request.

1. **Add routing to your Express Server**

	To serve static files, we use the [express.static built-in middleware function](https://expressjs.com/en/starter/static-files.html)

	```js hl_lines="8"
	const express = require('express');
	const {auth, resolver, loaders} = require('@iden3/js-iden3-auth')
	const getRawBody = require('raw-body')

	const app = express();
	const port = 8080;

	app.use(express.static('static'));

	app.get("/api/sign-in", (req, res) => {
		console.log('get Auth Request');
		GetAuthRequest(req,res);
	});

	app.post("/api/callback", (req, res) => {
		console.log('callback');
		Callback(req,res);
	});

	app.listen(port, () => {
		console.log('server running on port 8080');
	});

	// Create a map to store the auth requests and their session IDs
	const requestMap = new Map();
	```

2. **Visit http://localhost:8080/**

	When visiting the url, the user will need to scan the QR code with their ID Wallet

	<div align="center">
	<img src= "../../../imgs/verifier-static-1.png" align="" width="600"/>
	<img src= "../../../imgs/verifier-static-2.png" align="" width="600"/>
	<div align="center"><span style="font-size: 14px;">
	<br>
	<b> Sign Up with Polygon ID - Client Side </b></div>
	<br>
	</div>

3. **Implement Further Logic**

	This tutorial showcased a minimalistic application that leverages Polygon ID Framework for authentication purposeses. Developers can leverage the broad set of existing Claims held by users to set up any customized [Query](./zk-query-language.md) to unleash the full potential of the Framework. 

	For example exchanges that require KYC claim, DAOs that require proof-of-personhood claim or social media applications that wants to re-use users' aggregated reputation.